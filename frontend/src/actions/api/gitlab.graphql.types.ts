export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A `AlertManagementHttpIntegrationID` is a global ID. It is encoded as a string.
   *
   * An example `AlertManagementHttpIntegrationID` is: `"gid://gitlab/AlertManagement::HttpIntegration/1"`.
   */
  AlertManagementHttpIntegrationID: any;
  /**
   * A `AnalyticsDevopsAdoptionEnabledNamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsDevopsAdoptionEnabledNamespaceID` is: `"gid://gitlab/Analytics::DevopsAdoption::EnabledNamespace/1"`.
   */
  AnalyticsDevopsAdoptionEnabledNamespaceID: any;
  /**
   * A `AppSecFuzzingCoverageCorpusID` is a global ID. It is encoded as a string.
   *
   * An example `AppSecFuzzingCoverageCorpusID` is: `"gid://gitlab/AppSec::Fuzzing::Coverage::Corpus/1"`.
   */
  AppSecFuzzingCoverageCorpusID: any;
  /**
   * A `AuditEventsExternalAuditEventDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::ExternalAuditEventDestination/1"`.
   */
  AuditEventsExternalAuditEventDestinationID: any;
  /**
   * A `AuditEventsStreamingHeaderID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::Header/1"`.
   */
  AuditEventsStreamingHeaderID: any;
  /**
   * A `AwardableID` is a global ID. It is encoded as a string.
   *
   * An example `AwardableID` is: `"gid://gitlab/Awardable/1"`.
   */
  AwardableID: any;
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: any;
  /**
   * A `BoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardID` is: `"gid://gitlab/Board/1"`.
   */
  BoardID: any;
  /**
   * A `BoardsEpicBoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicBoardID` is: `"gid://gitlab/Boards::EpicBoard/1"`.
   */
  BoardsEpicBoardID: any;
  /**
   * A `BoardsEpicListID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicListID` is: `"gid://gitlab/Boards::EpicList/1"`.
   */
  BoardsEpicListID: any;
  /**
   * A `CiBuildID` is a global ID. It is encoded as a string.
   *
   * An example `CiBuildID` is: `"gid://gitlab/Ci::Build/1"`.
   */
  CiBuildID: any;
  /**
   * A `CiJobArtifactID` is a global ID. It is encoded as a string.
   *
   * An example `CiJobArtifactID` is: `"gid://gitlab/Ci::JobArtifact/1"`.
   */
  CiJobArtifactID: any;
  /**
   * A `CiPipelineID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineID` is: `"gid://gitlab/Ci::Pipeline/1"`.
   */
  CiPipelineID: any;
  /**
   * A `CiPipelineScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineScheduleID` is: `"gid://gitlab/Ci::PipelineSchedule/1"`.
   */
  CiPipelineScheduleID: any;
  /**
   * A `CiRunnerID` is a global ID. It is encoded as a string.
   *
   * An example `CiRunnerID` is: `"gid://gitlab/Ci::Runner/1"`.
   */
  CiRunnerID: any;
  /**
   * A `ClustersAgentID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentID` is: `"gid://gitlab/Clusters::Agent/1"`.
   */
  ClustersAgentID: any;
  /**
   * A `ClustersAgentTokenID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentTokenID` is: `"gid://gitlab/Clusters::AgentToken/1"`.
   */
  ClustersAgentTokenID: any;
  /**
   * A `ClustersClusterID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersClusterID` is: `"gid://gitlab/Clusters::Cluster/1"`.
   */
  ClustersClusterID: any;
  /**
   * Color represented as a hex code or named color.
   *
   * For example: "#fefefe".
   */
  Color: any;
  /**
   * A `ComplianceManagementFrameworkID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementFrameworkID` is: `"gid://gitlab/ComplianceManagement::Framework/1"`.
   */
  ComplianceManagementFrameworkID: any;
  /**
   * A `ContainerRepositoryID` is a global ID. It is encoded as a string.
   *
   * An example `ContainerRepositoryID` is: `"gid://gitlab/ContainerRepository/1"`.
   */
  ContainerRepositoryID: any;
  /**
   * A `CustomEmojiID` is a global ID. It is encoded as a string.
   *
   * An example `CustomEmojiID` is: `"gid://gitlab/CustomEmoji/1"`.
   */
  CustomEmojiID: any;
  /**
   * A `CustomerRelationsContactID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsContactID` is: `"gid://gitlab/CustomerRelations::Contact/1"`.
   */
  CustomerRelationsContactID: any;
  /**
   * A `CustomerRelationsOrganizationID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsOrganizationID` is: `"gid://gitlab/CustomerRelations::Organization/1"`.
   */
  CustomerRelationsOrganizationID: any;
  /**
   * A `DastProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileID` is: `"gid://gitlab/Dast::Profile/1"`.
   */
  DastProfileID: any;
  /**
   * A `DastProfileScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileScheduleID` is: `"gid://gitlab/Dast::ProfileSchedule/1"`.
   */
  DastProfileScheduleID: any;
  /**
   * A `DastScannerProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastScannerProfileID` is: `"gid://gitlab/DastScannerProfile/1"`.
   */
  DastScannerProfileID: any;
  /**
   * A `DastSiteProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteProfileID` is: `"gid://gitlab/DastSiteProfile/1"`.
   */
  DastSiteProfileID: any;
  /**
   * A `DastSiteTokenID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteTokenID` is: `"gid://gitlab/DastSiteToken/1"`.
   */
  DastSiteTokenID: any;
  /**
   * A `DastSiteValidationID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteValidationID` is: `"gid://gitlab/DastSiteValidation/1"`.
   */
  DastSiteValidationID: any;
  /** Date represented in ISO 8601 */
  Date: any;
  /**
   * A `DependencyProxyManifestID` is a global ID. It is encoded as a string.
   *
   * An example `DependencyProxyManifestID` is: `"gid://gitlab/DependencyProxy::Manifest/1"`.
   */
  DependencyProxyManifestID: any;
  /**
   * A `DesignManagementDesignAtVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignAtVersionID` is: `"gid://gitlab/DesignManagement::DesignAtVersion/1"`.
   */
  DesignManagementDesignAtVersionID: any;
  /**
   * A `DesignManagementDesignID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignID` is: `"gid://gitlab/DesignManagement::Design/1"`.
   */
  DesignManagementDesignID: any;
  /**
   * A `DesignManagementVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementVersionID` is: `"gid://gitlab/DesignManagement::Version/1"`.
   */
  DesignManagementVersionID: any;
  /**
   * A `DiffNoteID` is a global ID. It is encoded as a string.
   *
   * An example `DiffNoteID` is: `"gid://gitlab/DiffNote/1"`.
   */
  DiffNoteID: any;
  /**
   * A `DiscussionID` is a global ID. It is encoded as a string.
   *
   * An example `DiscussionID` is: `"gid://gitlab/Discussion/1"`.
   */
  DiscussionID: any;
  /**
   * Duration between two instants, represented as a fractional number of seconds.
   *
   * For example: 12.3334
   */
  Duration: any;
  /**
   * A `EnvironmentID` is a global ID. It is encoded as a string.
   *
   * An example `EnvironmentID` is: `"gid://gitlab/Environment/1"`.
   */
  EnvironmentID: any;
  /**
   * A `EpicID` is a global ID. It is encoded as a string.
   *
   * An example `EpicID` is: `"gid://gitlab/Epic/1"`.
   */
  EpicID: any;
  /**
   * A `EpicTreeSortingID` is a global ID. It is encoded as a string.
   *
   * An example `EpicTreeSortingID` is: `"gid://gitlab/EpicTreeSorting/1"`.
   */
  EpicTreeSortingID: any;
  /**
   * A `GitlabErrorTrackingDetailedErrorID` is a global ID. It is encoded as a string.
   *
   * An example `GitlabErrorTrackingDetailedErrorID` is: `"gid://gitlab/Gitlab::ErrorTracking::DetailedError/1"`.
   */
  GitlabErrorTrackingDetailedErrorID: any;
  /**
   * A global identifier.
   *
   * A global identifier represents an object uniquely across the application.
   * An example of such an identifier is `"gid://gitlab/User/1"`.
   *
   * Global identifiers are encoded as strings.
   */
  GlobalID: any;
  /**
   * A `GroupID` is a global ID. It is encoded as a string.
   *
   * An example `GroupID` is: `"gid://gitlab/Group/1"`.
   */
  GroupID: any;
  /**
   * A `IncidentManagementEscalationPolicyID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationPolicyID` is: `"gid://gitlab/IncidentManagement::EscalationPolicy/1"`.
   */
  IncidentManagementEscalationPolicyID: any;
  /**
   * A `IncidentManagementEscalationRuleID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationRuleID` is: `"gid://gitlab/IncidentManagement::EscalationRule/1"`.
   */
  IncidentManagementEscalationRuleID: any;
  /**
   * A `IncidentManagementIssuableResourceLinkID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementIssuableResourceLinkID` is: `"gid://gitlab/IncidentManagement::IssuableResourceLink/1"`.
   */
  IncidentManagementIssuableResourceLinkID: any;
  /**
   * A `IncidentManagementOncallParticipantID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallParticipantID` is: `"gid://gitlab/IncidentManagement::OncallParticipant/1"`.
   */
  IncidentManagementOncallParticipantID: any;
  /**
   * A `IncidentManagementOncallRotationID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallRotationID` is: `"gid://gitlab/IncidentManagement::OncallRotation/1"`.
   */
  IncidentManagementOncallRotationID: any;
  /**
   * A `IncidentManagementTimelineEventID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventID` is: `"gid://gitlab/IncidentManagement::TimelineEvent/1"`.
   */
  IncidentManagementTimelineEventID: any;
  /**
   * A `IncidentManagementTimelineEventTagID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventTagID` is: `"gid://gitlab/IncidentManagement::TimelineEventTag/1"`.
   */
  IncidentManagementTimelineEventTagID: any;
  /**
   * A `IntegrationsPrometheusID` is a global ID. It is encoded as a string.
   *
   * An example `IntegrationsPrometheusID` is: `"gid://gitlab/Integrations::Prometheus/1"`.
   * The older format `"gid://gitlab/PrometheusService/1"` was deprecated in 14.1.
   */
  IntegrationsPrometheusID: any;
  /** An ISO 8601-encoded date */
  ISO8601Date: any;
  /**
   * A `IssuableID` is a global ID. It is encoded as a string.
   *
   * An example `IssuableID` is: `"gid://gitlab/Issuable/1"`.
   */
  IssuableID: any;
  /**
   * A `IssueID` is a global ID. It is encoded as a string.
   *
   * An example `IssueID` is: `"gid://gitlab/Issue/1"`.
   */
  IssueID: any;
  /**
   * A `IterationID` is a global ID. It is encoded as a string.
   *
   * An example `IterationID` is: `"gid://gitlab/Iteration/1"`.
   * The older format `"gid://gitlab/EEIteration/1"` was deprecated in 13.3.
   */
  IterationID: any;
  /**
   * A `IterationsCadenceID` is a global ID. It is encoded as a string.
   *
   * An example `IterationsCadenceID` is: `"gid://gitlab/Iterations::Cadence/1"`.
   */
  IterationsCadenceID: any;
  /**
   * A `CommitStatusID` is a global ID. It is encoded as a string.
   *
   * An example `CommitStatusID` is: `"gid://gitlab/CommitStatus/1"`.
   */
  JobID: any;
  /** Represents untyped JSON */
  JSON: any;
  /** JSON object as raw string */
  JsonString: any;
  /**
   * A `LabelID` is a global ID. It is encoded as a string.
   *
   * An example `LabelID` is: `"gid://gitlab/Label/1"`.
   */
  LabelID: any;
  /**
   * A `ListID` is a global ID. It is encoded as a string.
   *
   * An example `ListID` is: `"gid://gitlab/List/1"`.
   */
  ListID: any;
  /**
   * A `MergeRequestID` is a global ID. It is encoded as a string.
   *
   * An example `MergeRequestID` is: `"gid://gitlab/MergeRequest/1"`.
   */
  MergeRequestID: any;
  /**
   * A `MetricsDashboardAnnotationID` is a global ID. It is encoded as a string.
   *
   * An example `MetricsDashboardAnnotationID` is: `"gid://gitlab/Metrics::Dashboard::Annotation/1"`.
   */
  MetricsDashboardAnnotationID: any;
  /**
   * A `MilestoneID` is a global ID. It is encoded as a string.
   *
   * An example `MilestoneID` is: `"gid://gitlab/Milestone/1"`.
   */
  MilestoneID: any;
  /**
   * A `NamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `NamespaceID` is: `"gid://gitlab/Namespace/1"`.
   */
  NamespaceID: any;
  /**
   * A `NamespacesNamespaceBanID` is a global ID. It is encoded as a string.
   *
   * An example `NamespacesNamespaceBanID` is: `"gid://gitlab/Namespaces::NamespaceBan/1"`.
   */
  NamespacesNamespaceBanID: any;
  /**
   * A `NoteableID` is a global ID. It is encoded as a string.
   *
   * An example `NoteableID` is: `"gid://gitlab/Noteable/1"`.
   */
  NoteableID: any;
  /**
   * A `NoteID` is a global ID. It is encoded as a string.
   *
   * An example `NoteID` is: `"gid://gitlab/Note/1"`.
   */
  NoteID: any;
  /**
   * A `PackagesConanFileMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanFileMetadatumID` is: `"gid://gitlab/Packages::Conan::FileMetadatum/1"`.
   */
  PackagesConanFileMetadatumID: any;
  /**
   * A `PackagesConanMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanMetadatumID` is: `"gid://gitlab/Packages::Conan::Metadatum/1"`.
   */
  PackagesConanMetadatumID: any;
  /**
   * A `PackagesDependencyID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyID` is: `"gid://gitlab/Packages::Dependency/1"`.
   */
  PackagesDependencyID: any;
  /**
   * A `PackagesDependencyLinkID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyLinkID` is: `"gid://gitlab/Packages::DependencyLink/1"`.
   */
  PackagesDependencyLinkID: any;
  /**
   * A `PackagesMavenMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesMavenMetadatumID` is: `"gid://gitlab/Packages::Maven::Metadatum/1"`.
   */
  PackagesMavenMetadatumID: any;
  /**
   * A `PackagesNugetDependencyLinkMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetDependencyLinkMetadatumID` is: `"gid://gitlab/Packages::Nuget::DependencyLinkMetadatum/1"`.
   */
  PackagesNugetDependencyLinkMetadatumID: any;
  /**
   * A `PackagesNugetMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetMetadatumID` is: `"gid://gitlab/Packages::Nuget::Metadatum/1"`.
   */
  PackagesNugetMetadatumID: any;
  /**
   * A `PackagesPackageFileID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageFileID` is: `"gid://gitlab/Packages::PackageFile/1"`.
   */
  PackagesPackageFileID: any;
  /**
   * A `PackagesPackageID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageID` is: `"gid://gitlab/Packages::Package/1"`.
   */
  PackagesPackageID: any;
  /**
   * A `PackagesPypiMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPypiMetadatumID` is: `"gid://gitlab/Packages::Pypi::Metadatum/1"`.
   */
  PackagesPypiMetadatumID: any;
  /**
   * A `PathLockID` is a global ID. It is encoded as a string.
   *
   * An example `PathLockID` is: `"gid://gitlab/PathLock/1"`.
   */
  PathLockID: any;
  /** String or integer. */
  PayloadAlertFieldPathSegment: any;
  /**
   * A `ProjectID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectID` is: `"gid://gitlab/Project/1"`.
   */
  ProjectID: any;
  /**
   * A `ReleaseID` is a global ID. It is encoded as a string.
   *
   * An example `ReleaseID` is: `"gid://gitlab/Release/1"`.
   */
  ReleaseID: any;
  /**
   * A `ReleasesLinkID` is a global ID. It is encoded as a string.
   *
   * An example `ReleasesLinkID` is: `"gid://gitlab/Releases::Link/1"`.
   */
  ReleasesLinkID: any;
  /**
   * A `SecurityTrainingProviderID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityTrainingProviderID` is: `"gid://gitlab/Security::TrainingProvider/1"`.
   */
  SecurityTrainingProviderID: any;
  /**
   * A `SnippetID` is a global ID. It is encoded as a string.
   *
   * An example `SnippetID` is: `"gid://gitlab/Snippet/1"`.
   */
  SnippetID: any;
  /**
   * A `TerraformStateID` is a global ID. It is encoded as a string.
   *
   * An example `TerraformStateID` is: `"gid://gitlab/Terraform::State/1"`.
   */
  TerraformStateID: any;
  /**
   * Time represented in ISO 8601.
   *
   * For example: "2021-03-09T14:58:50+00:00".
   *
   * See `https://www.iso.org/iso-8601-date-and-time-format.html`.
   */
  Time: any;
  /**
   * A `TimelogID` is a global ID. It is encoded as a string.
   *
   * An example `TimelogID` is: `"gid://gitlab/Timelog/1"`.
   */
  TimelogID: any;
  /**
   * A `TodoableID` is a global ID. It is encoded as a string.
   *
   * An example `TodoableID` is: `"gid://gitlab/Todoable/1"`.
   */
  TodoableID: any;
  /**
   * A `TodoID` is a global ID. It is encoded as a string.
   *
   * An example `TodoID` is: `"gid://gitlab/Todo/1"`.
   */
  TodoID: any;
  /** A regexp containing patterns sourced from user input */
  UntrustedRegexp: any;
  Upload: any;
  /**
   * A `UploadID` is a global ID. It is encoded as a string.
   *
   * An example `UploadID` is: `"gid://gitlab/Upload/1"`.
   */
  UploadID: any;
  /**
   * A `UserID` is a global ID. It is encoded as a string.
   *
   * An example `UserID` is: `"gid://gitlab/User/1"`.
   */
  UserID: any;
  /**
   * A `UsersSavedReplyID` is a global ID. It is encoded as a string.
   *
   * An example `UsersSavedReplyID` is: `"gid://gitlab/Users::SavedReply/1"`.
   */
  UsersSavedReplyID: any;
  /**
   * A `VulnerabilitiesExternalIssueLinkID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesExternalIssueLinkID` is: `"gid://gitlab/Vulnerabilities::ExternalIssueLink/1"`.
   */
  VulnerabilitiesExternalIssueLinkID: any;
  /**
   * A `VulnerabilitiesFindingID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesFindingID` is: `"gid://gitlab/Vulnerabilities::Finding/1"`.
   */
  VulnerabilitiesFindingID: any;
  /**
   * A `VulnerabilitiesScannerID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesScannerID` is: `"gid://gitlab/Vulnerabilities::Scanner/1"`.
   */
  VulnerabilitiesScannerID: any;
  /**
   * A `VulnerabilityID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilityID` is: `"gid://gitlab/Vulnerability/1"`.
   */
  VulnerabilityID: any;
  /**
   * A `WorkItemID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.
   *
   * While we transition from Issues into Work Items this type will temporarily support
   * `IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
   */
  WorkItemID: any;
  /**
   * A `WorkItemsTypeID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsTypeID` is: `"gid://gitlab/WorkItems::Type/1"`.
   */
  WorkItemsTypeID: any;
};

/** Represents the access level of a relationship between a User and object that it is related to */
export type AccessLevel = {
  __typename?: 'AccessLevel';
  /** Integer representation of access level. */
  integerValue?: Maybe<Scalars['Int']>;
  /** String representation of access level. */
  stringValue?: Maybe<AccessLevelEnum>;
};

/** Access level to a resource */
export enum AccessLevelEnum {
  /** No access. */
  NoAccess = 'NO_ACCESS',
  /** Minimal access. */
  MinimalAccess = 'MINIMAL_ACCESS',
  /** Guest access. */
  Guest = 'GUEST',
  /** Reporter access. */
  Reporter = 'REPORTER',
  /** Developer access. */
  Developer = 'DEVELOPER',
  /** Maintainer access. */
  Maintainer = 'MAINTAINER',
  /** Owner access. */
  Owner = 'OWNER'
}

/** Representation of a GitLab group. */
export type AccessLevelGroup = {
  __typename?: 'AccessLevelGroup';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** ID of the group. */
  id: Scalars['ID'];
  /** Name of the group. */
  name: Scalars['String'];
  /** Parent group. */
  parent?: Maybe<AccessLevelGroup>;
  /** Web URL of the group. */
  webUrl: Scalars['String'];
};

/** Representation of a GitLab user. */
export type AccessLevelUser = {
  __typename?: 'AccessLevelUser';
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** ID of the user. */
  id: Scalars['ID'];
  /**
   * Human-readable name of the user.
   * Returns `****` if the user is a project bot and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};

/** Autogenerated input type of AddProjectToSecurityDashboard */
export type AddProjectToSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to be added to Instance Security Dashboard. */
  id: Scalars['ProjectID'];
};

/** Autogenerated return type of AddProjectToSecurityDashboard */
export type AddProjectToSecurityDashboardPayload = {
  __typename?: 'AddProjectToSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project that was added to the Instance Security Dashboard. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of AdminSidekiqQueuesDeleteJobs */
export type AdminSidekiqQueuesDeleteJobsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching user in the context metadata. */
  user?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching user_id in the context metadata. */
  userId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching project in the context metadata. */
  project?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching root_namespace in the context metadata. */
  rootNamespace?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching client_id in the context metadata. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching caller_id in the context metadata. */
  callerId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching remote_ip in the context metadata. */
  remoteIp?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching job_id in the context metadata. */
  jobId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching pipeline_id in the context metadata. */
  pipelineId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching related_class in the context metadata. */
  relatedClass?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching feature_category in the context metadata. */
  featureCategory?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifact_size in the context metadata. */
  artifactSize?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifact_used_cdn in the context metadata. */
  artifactUsedCdn?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifacts_dependencies_size in the context metadata. */
  artifactsDependenciesSize?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifacts_dependencies_count in the context metadata. */
  artifactsDependenciesCount?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching root_caller_id in the context metadata. */
  rootCallerId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching subscription_plan in the context metadata. */
  subscriptionPlan?: InputMaybe<Scalars['String']>;
  /** Delete jobs with the given worker class. */
  workerClass?: InputMaybe<Scalars['String']>;
  /** Name of the queue to delete jobs from. */
  queueName: Scalars['String'];
};

/** Autogenerated return type of AdminSidekiqQueuesDeleteJobs */
export type AdminSidekiqQueuesDeleteJobsPayload = {
  __typename?: 'AdminSidekiqQueuesDeleteJobsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Information about the status of the deletion request. */
  result?: Maybe<DeleteJobsResponse>;
};

/** Configuration details for an Agent */
export type AgentConfiguration = {
  __typename?: 'AgentConfiguration';
  /** Name of the agent. */
  agentName?: Maybe<Scalars['String']>;
};

/** The connection type for AgentConfiguration. */
export type AgentConfigurationConnection = {
  __typename?: 'AgentConfigurationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AgentConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AgentConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AgentConfigurationEdge = {
  __typename?: 'AgentConfigurationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AgentConfiguration>;
};

/** Information about a connected Agent */
export type AgentMetadata = {
  __typename?: 'AgentMetadata';
  /** Agent version commit. */
  commit?: Maybe<Scalars['String']>;
  /** Name of the pod running the Agent. */
  podName?: Maybe<Scalars['String']>;
  /** Namespace of the pod running the Agent. */
  podNamespace?: Maybe<Scalars['String']>;
  /** Agent version tag. */
  version?: Maybe<Scalars['String']>;
};

/** Agent token statuses */
export enum AgentTokenStatus {
  /** Active agent token. */
  Active = 'ACTIVE',
  /** Revoked agent token. */
  Revoked = 'REVOKED'
}

/** Describes an alert from the project's Alert Management */
export type AlertManagementAlert = NoteableInterface & Todoable & {
  __typename?: 'AlertManagementAlert';
  /** Assignees of the alert. */
  assignees?: Maybe<UserCoreConnection>;
  /** Timestamp the alert was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Description of the alert. */
  description?: Maybe<Scalars['String']>;
  /** Alert details. */
  details?: Maybe<Scalars['JSON']>;
  /** URL of the alert detail page. */
  detailsUrl: Scalars['String'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Timestamp the alert ended. */
  endedAt?: Maybe<Scalars['Time']>;
  /** Environment for the alert. */
  environment?: Maybe<Environment>;
  /** Number of events of this alert. */
  eventCount?: Maybe<Scalars['Int']>;
  /** List of hosts the alert came from. */
  hosts?: Maybe<Array<Scalars['String']>>;
  /** Internal ID of the alert. */
  iid: Scalars['ID'];
  /** Issue attached to the alert. */
  issue?: Maybe<Issue>;
  /**
   * Internal ID of the GitLab issue attached to the alert. Deprecated in 13.10: Use issue field.
   * @deprecated Use issue field. Deprecated in 13.10.
   */
  issueIid?: Maybe<Scalars['ID']>;
  /** URL for metrics embed for the alert. */
  metricsDashboardUrl?: Maybe<Scalars['String']>;
  /** Monitoring tool the alert came from. */
  monitoringTool?: Maybe<Scalars['String']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Alert condition for Prometheus. */
  prometheusAlert?: Maybe<PrometheusAlert>;
  /** Runbook for the alert as defined in alert details. */
  runbook?: Maybe<Scalars['String']>;
  /** Service the alert came from. */
  service?: Maybe<Scalars['String']>;
  /** Severity of the alert. */
  severity?: Maybe<AlertManagementSeverity>;
  /** Timestamp the alert was raised. */
  startedAt?: Maybe<Scalars['Time']>;
  /** Status of the alert. */
  status?: Maybe<AlertManagementStatus>;
  /** Title of the alert. */
  title?: Maybe<Scalars['String']>;
  /** To-do items of the current user for the alert. */
  todos?: Maybe<TodoConnection>;
  /** Timestamp the alert was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** URL of the alert. */
  webUrl: Scalars['String'];
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for AlertManagementAlert. */
export type AlertManagementAlertConnection = {
  __typename?: 'AlertManagementAlertConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementAlertEdge = {
  __typename?: 'AlertManagementAlertEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementAlert>;
};

/** Values for sorting alerts */
export enum AlertManagementAlertSort {
  /** Start time by ascending order. */
  StartedAtAsc = 'STARTED_AT_ASC',
  /** Start time by descending order. */
  StartedAtDesc = 'STARTED_AT_DESC',
  /** End time by ascending order. */
  EndedAtAsc = 'ENDED_AT_ASC',
  /** End time by descending order. */
  EndedAtDesc = 'ENDED_AT_DESC',
  /** Created time by ascending order. */
  CreatedTimeAsc = 'CREATED_TIME_ASC',
  /** Created time by descending order. */
  CreatedTimeDesc = 'CREATED_TIME_DESC',
  /** Created time by ascending order. */
  UpdatedTimeAsc = 'UPDATED_TIME_ASC',
  /** Created time by descending order. */
  UpdatedTimeDesc = 'UPDATED_TIME_DESC',
  /** Events count by ascending order. */
  EventCountAsc = 'EVENT_COUNT_ASC',
  /** Events count by descending order. */
  EventCountDesc = 'EVENT_COUNT_DESC',
  /** Severity from less critical to more critical. */
  SeverityAsc = 'SEVERITY_ASC',
  /** Severity from more critical to less critical. */
  SeverityDesc = 'SEVERITY_DESC',
  /** Status by order: `Ignored > Resolved > Acknowledged > Triggered`. */
  StatusAsc = 'STATUS_ASC',
  /** Status by order: `Triggered > Acknowledged > Resolved > Ignored`. */
  StatusDesc = 'STATUS_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Represents total number of alerts for the represented categories */
export type AlertManagementAlertStatusCountsType = {
  __typename?: 'AlertManagementAlertStatusCountsType';
  /** Number of alerts with status ACKNOWLEDGED for the project */
  acknowledged?: Maybe<Scalars['Int']>;
  /** Total number of alerts for the project. */
  all?: Maybe<Scalars['Int']>;
  /** Number of alerts with status IGNORED for the project */
  ignored?: Maybe<Scalars['Int']>;
  /** Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project. */
  open?: Maybe<Scalars['Int']>;
  /** Number of alerts with status RESOLVED for the project */
  resolved?: Maybe<Scalars['Int']>;
  /** Number of alerts with status TRIGGERED for the project */
  triggered?: Maybe<Scalars['Int']>;
};

/** Filters the alerts based on given domain */
export enum AlertManagementDomainFilter {
  /** Alerts for operations domain. */
  Operations = 'operations',
  /**
   * Alerts for threat monitoring domain. Deprecated in 15.0: Network policies are
   * deprecated and will be removed in GitLab 16.0.
   * @deprecated Network policies are deprecated and will be removed in GitLab 16.0. Deprecated in 15.0.
   */
  ThreatMonitoring = 'threat_monitoring'
}

/** An endpoint and credentials used to accept alerts for a project */
export type AlertManagementHttpIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementHttpIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Extract alert fields from payload example for custom mapping. */
  payloadAlertFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /** The custom mapping of GitLab alert attributes to fields from the payload_example. */
  payloadAttributeMappings?: Maybe<Array<AlertManagementPayloadAlertMappingField>>;
  /** Example of an alert payload. */
  payloadExample?: Maybe<Scalars['JsonString']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for AlertManagementHttpIntegration. */
export type AlertManagementHttpIntegrationConnection = {
  __typename?: 'AlertManagementHttpIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementHttpIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementHttpIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementHttpIntegrationEdge = {
  __typename?: 'AlertManagementHttpIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementHttpIntegration>;
};

export type AlertManagementIntegration = {
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for AlertManagementIntegration. */
export type AlertManagementIntegrationConnection = {
  __typename?: 'AlertManagementIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementIntegrationEdge = {
  __typename?: 'AlertManagementIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementIntegration>;
};

/** Values of types of integrations */
export enum AlertManagementIntegrationType {
  /** Prometheus integration. */
  Prometheus = 'PROMETHEUS',
  /** Integration with any monitoring tool. */
  Http = 'HTTP'
}

/** Parsed field from an alert used for custom mappings */
export type AlertManagementPayloadAlertField = {
  __typename?: 'AlertManagementPayloadAlertField';
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** Field that are available while modifying the custom mapping attributes for an HTTP integration */
export type AlertManagementPayloadAlertFieldInput = {
  /** GitLab alert field name. */
  fieldName: AlertManagementPayloadAlertFieldName;
  /** Path to value inside payload JSON. */
  path: Array<Scalars['PayloadAlertFieldPathSegment']>;
  /** Human-readable label of the payload path. */
  label?: InputMaybe<Scalars['String']>;
  /** Type of the parsed value. */
  type: AlertManagementPayloadAlertFieldType;
};

/** Values for alert field names used in the custom mapping */
export enum AlertManagementPayloadAlertFieldName {
  /** The title of the incident. */
  Title = 'TITLE',
  /** A high-level summary of the problem. */
  Description = 'DESCRIPTION',
  /** The time of the incident. */
  StartTime = 'START_TIME',
  /** The resolved time of the incident. */
  EndTime = 'END_TIME',
  /** The affected service. */
  Service = 'SERVICE',
  /** The name of the associated monitoring tool. */
  MonitoringTool = 'MONITORING_TOOL',
  /** One or more hosts, as to where this incident occurred. */
  Hosts = 'HOSTS',
  /** The severity of the alert. */
  Severity = 'SEVERITY',
  /** The unique identifier of the alert. This can be used to group occurrences of the same alert. */
  Fingerprint = 'FINGERPRINT',
  /** The name of the associated GitLab environment. */
  GitlabEnvironmentName = 'GITLAB_ENVIRONMENT_NAME'
}

/** Values for alert field types used in the custom mapping */
export enum AlertManagementPayloadAlertFieldType {
  /** Array field type. */
  Array = 'ARRAY',
  /** DateTime field type. */
  Datetime = 'DATETIME',
  /** String field type. */
  String = 'STRING'
}

/** Parsed field (with its name) from an alert used for custom mappings */
export type AlertManagementPayloadAlertMappingField = {
  __typename?: 'AlertManagementPayloadAlertMappingField';
  /** GitLab alert field name. */
  fieldName?: Maybe<AlertManagementPayloadAlertFieldName>;
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** An endpoint and credentials used to accept Prometheus alerts for a project */
export type AlertManagementPrometheusIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementPrometheusIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** Alert severity values */
export enum AlertManagementSeverity {
  /** Critical severity */
  Critical = 'CRITICAL',
  /** High severity */
  High = 'HIGH',
  /** Medium severity */
  Medium = 'MEDIUM',
  /** Low severity */
  Low = 'LOW',
  /** Info severity */
  Info = 'INFO',
  /** Unknown severity */
  Unknown = 'UNKNOWN'
}

/** Alert status values */
export enum AlertManagementStatus {
  /** Investigation has not started. */
  Triggered = 'TRIGGERED',
  /** Someone is actively investigating the problem. */
  Acknowledged = 'ACKNOWLEDGED',
  /** The problem has been addressed. */
  Resolved = 'RESOLVED',
  /** No action will be taken. */
  Ignored = 'IGNORED'
}

/** Autogenerated input type of AlertSetAssignees */
export type AlertSetAssigneesInput = {
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Usernames to assign to the alert. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of AlertSetAssignees */
export type AlertSetAssigneesPayload = {
  __typename?: 'AlertSetAssigneesPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of AlertTodoCreate */
export type AlertTodoCreateInput = {
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AlertTodoCreate */
export type AlertTodoCreatePayload = {
  __typename?: 'AlertTodoCreatePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Data associated with configuring API fuzzing scans in GitLab CI */
export type ApiFuzzingCiConfiguration = {
  __typename?: 'ApiFuzzingCiConfiguration';
  /** All available scan modes. */
  scanModes?: Maybe<Array<ApiFuzzingScanMode>>;
  /** All default scan profiles. */
  scanProfiles?: Maybe<Array<ApiFuzzingScanProfile>>;
};

/** Autogenerated input type of ApiFuzzingCiConfigurationCreate */
export type ApiFuzzingCiConfigurationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /**
   * File path or URL to the file that defines the API surface for scanning. Must
   * be in the format specified by the `scanMode` argument.
   */
  apiSpecificationFile: Scalars['String'];
  /** CI variable containing the password for authenticating with the target API. */
  authPassword?: InputMaybe<Scalars['String']>;
  /** CI variable containing the username for authenticating with the target API. */
  authUsername?: InputMaybe<Scalars['String']>;
  /** Mode for API fuzzing scans. */
  scanMode: ApiFuzzingScanMode;
  /** Name of a default profile to use for scanning. Ex: Quick-10. */
  scanProfile?: InputMaybe<Scalars['String']>;
  /** URL for the target of API fuzzing scans. */
  target: Scalars['String'];
};

/** Autogenerated return type of ApiFuzzingCiConfigurationCreate */
export type ApiFuzzingCiConfigurationCreatePayload = {
  __typename?: 'ApiFuzzingCiConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * A YAML snippet that can be inserted into the project's `.gitlab-ci.yml` to set
   * up API fuzzing scans. Deprecated in 14.6: The configuration snippet is now
   * generated client-side.
   * @deprecated The configuration snippet is now generated client-side. Deprecated in 14.6.
   */
  configurationYaml?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * Location at which the project's `.gitlab-ci.yml` file can be edited in the
   * browser. Deprecated in 14.6: The configuration snippet is now generated client-side.
   * @deprecated The configuration snippet is now generated client-side. Deprecated in 14.6.
   */
  gitlabCiYamlEditPath?: Maybe<Scalars['String']>;
};

/** All possible ways to specify the API surface for an API fuzzing scan. */
export enum ApiFuzzingScanMode {
  /** The API surface is specified by a HAR file. */
  Har = 'HAR',
  /** The API surface is specified by a OPENAPI file. */
  Openapi = 'OPENAPI',
  /** The API surface is specified by a POSTMAN file. */
  Postman = 'POSTMAN'
}

/** An API Fuzzing scan profile. */
export type ApiFuzzingScanProfile = {
  __typename?: 'ApiFuzzingScanProfile';
  /** Short description of the profile. */
  description?: Maybe<Scalars['String']>;
  /** Unique name of the profile. */
  name?: Maybe<Scalars['String']>;
  /** Syntax highlighted HTML representation of the YAML. */
  yaml?: Maybe<Scalars['String']>;
};

/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRule = {
  __typename?: 'ApprovalProjectRule';
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** List of users eligible to approve merge requests for this approval rule. */
  eligibleApprovers?: Maybe<UserCoreConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Name of the rule. */
  name?: Maybe<Scalars['String']>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
};


/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRuleEligibleApproversArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ApprovalProjectRule. */
export type ApprovalProjectRuleConnection = {
  __typename?: 'ApprovalProjectRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApprovalProjectRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ApprovalProjectRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ApprovalProjectRuleEdge = {
  __typename?: 'ApprovalProjectRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ApprovalProjectRule>;
};

/** Describes a rule for who can approve merge requests. */
export type ApprovalRule = {
  __typename?: 'ApprovalRule';
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** Indicates if the rule is satisfied. */
  approved?: Maybe<Scalars['Boolean']>;
  /** List of users defined in the rule that approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** Indicates if the rule contains approvers from a hidden group. */
  containsHiddenGroups?: Maybe<Scalars['Boolean']>;
  /** List of all users eligible to approve the merge request (defined explicitly and from associated groups). */
  eligibleApprovers?: Maybe<Array<UserCore>>;
  /** List of groups added as approvers for the rule. */
  groups?: Maybe<GroupConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Name of the rule. */
  name?: Maybe<Scalars['String']>;
  /** Indicates if the rule was overridden for the merge request. */
  overridden?: Maybe<Scalars['Boolean']>;
  /** Named section of the Code Owners file that the rule applies to. */
  section?: Maybe<Scalars['String']>;
  /** Source rule used to create the rule. */
  sourceRule?: Maybe<ApprovalRule>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
  /** List of users added as approvers for the rule. */
  users?: Maybe<UserCoreConnection>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleApprovedByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The kind of an approval rule. */
export enum ApprovalRuleType {
  /** A `regular` approval rule. */
  Regular = 'REGULAR',
  /** A `code_owner` approval rule. */
  CodeOwner = 'CODE_OWNER',
  /** A `report_approver` approval rule. */
  ReportApprover = 'REPORT_APPROVER',
  /** A `any_approver` approval rule. */
  AnyApprover = 'ANY_APPROVER'
}

/** Autogenerated input type of ArtifactDestroy */
export type ArtifactDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the artifact to delete. */
  id: Scalars['CiJobArtifactID'];
};

/** Autogenerated return type of ArtifactDestroy */
export type ArtifactDestroyPayload = {
  __typename?: 'ArtifactDestroyPayload';
  /** Deleted artifact. */
  artifact?: Maybe<CiJobArtifact>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents a vulnerability asset type. */
export type AssetType = {
  __typename?: 'AssetType';
  /** Name of the asset. */
  name: Scalars['String'];
  /** Type of the asset. */
  type: Scalars['String'];
  /** URL of the asset. */
  url: Scalars['String'];
};

/** Assignee ID wildcard values */
export enum AssigneeWildcardId {
  /** No assignee is assigned. */
  None = 'NONE',
  /** An assignee is assigned. */
  Any = 'ANY'
}

/** Autogenerated input type of AuditEventsStreamingDestinationEventsAdd */
export type AuditEventsStreamingDestinationEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationEventsAdd */
export type AuditEventsStreamingDestinationEventsAddPayload = {
  __typename?: 'AuditEventsStreamingDestinationEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Event type filters present. */
  eventTypeFilters?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersCreate */
export type AuditEventsStreamingHeadersCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
  /** Destination to associate header with. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersCreate */
export type AuditEventsStreamingHeadersCreatePayload = {
  __typename?: 'AuditEventsStreamingHeadersCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersDestroy */
export type AuditEventsStreamingHeadersDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to delete. */
  headerId: Scalars['AuditEventsStreamingHeaderID'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersDestroy */
export type AuditEventsStreamingHeadersDestroyPayload = {
  __typename?: 'AuditEventsStreamingHeadersDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersUpdate */
export type AuditEventsStreamingHeadersUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to update. */
  headerId: Scalars['AuditEventsStreamingHeaderID'];
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersUpdate */
export type AuditEventsStreamingHeadersUpdatePayload = {
  __typename?: 'AuditEventsStreamingHeadersUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updates header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Represents a HTTP header key/value that belongs to an audit streaming destination. */
export type AuditEventStreamingHeader = {
  __typename?: 'AuditEventStreamingHeader';
  /** ID of the header. */
  id: Scalars['ID'];
  /** Key of the header. */
  key: Scalars['String'];
  /** Value of the header. */
  value: Scalars['String'];
};

/** The connection type for AuditEventStreamingHeader. */
export type AuditEventStreamingHeaderConnection = {
  __typename?: 'AuditEventStreamingHeaderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventStreamingHeaderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventStreamingHeader>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventStreamingHeaderEdge = {
  __typename?: 'AuditEventStreamingHeaderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventStreamingHeader>;
};

/** User availability status */
export enum AvailabilityEnum {
  /** Not Set */
  NotSet = 'NOT_SET',
  /** Busy */
  Busy = 'BUSY'
}

/** An emoji awarded by a user */
export type AwardEmoji = {
  __typename?: 'AwardEmoji';
  /** Emoji description. */
  description: Scalars['String'];
  /** Emoji as an icon. */
  emoji: Scalars['String'];
  /** Emoji name. */
  name: Scalars['String'];
  /** Emoji in Unicode. */
  unicode: Scalars['String'];
  /** Unicode version for this emoji. */
  unicodeVersion: Scalars['String'];
  /** User who awarded the emoji. */
  user: UserCore;
};

/** Autogenerated input type of AwardEmojiAdd */
export type AwardEmojiAddInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** Emoji name. */
  name: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AwardEmojiAdd */
export type AwardEmojiAddPayload = {
  __typename?: 'AwardEmojiAddPayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for AwardEmoji. */
export type AwardEmojiConnection = {
  __typename?: 'AwardEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AwardEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AwardEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AwardEmojiEdge = {
  __typename?: 'AwardEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AwardEmoji>;
};

/** Autogenerated input type of AwardEmojiRemove */
export type AwardEmojiRemoveInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** Emoji name. */
  name: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AwardEmojiRemove */
export type AwardEmojiRemovePayload = {
  __typename?: 'AwardEmojiRemovePayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AwardEmojiToggle */
export type AwardEmojiToggleInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** Emoji name. */
  name: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AwardEmojiToggle */
export type AwardEmojiTogglePayload = {
  __typename?: 'AwardEmojiTogglePayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Indicates the status of the emoji. True if the toggle awarded the emoji, and false if the toggle removed the emoji. */
  toggledOn: Scalars['Boolean'];
};

export type BaseService = Service & {
  __typename?: 'BaseService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};

export type Blob = Entry & {
  __typename?: 'Blob';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** LFS ID of the blob. */
  lfsOid?: Maybe<Scalars['String']>;
  /** Blob mode in numeric format. */
  mode?: Maybe<Scalars['String']>;
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']>;
  /** Web URL of the blob. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for Blob. */
export type BlobConnection = {
  __typename?: 'BlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Blob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BlobEdge = {
  __typename?: 'BlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Blob>;
};

/** Represents how the blob content should be displayed */
export type BlobViewer = {
  __typename?: 'BlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean'];
  /** Content file type. */
  fileType: Scalars['String'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** Types of blob viewers */
export enum BlobViewersType {
  /** Rich blob viewers type. */
  Rich = 'rich',
  /** Simple blob viewers type. */
  Simple = 'simple',
  /** Auxiliary blob viewers type. */
  Auxiliary = 'auxiliary'
}

/** Represents a project or group issue board */
export type Board = {
  __typename?: 'Board';
  /** Board assignee. */
  assignee?: Maybe<UserCore>;
  /** Timestamp of when the board was created. */
  createdAt: Scalars['Time'];
  /** Epics associated with board issues. */
  epics?: Maybe<BoardEpicConnection>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']>;
  /** ID (global ID) of the board. */
  id: Scalars['ID'];
  /** Board iteration. */
  iteration?: Maybe<Iteration>;
  /** Board iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Lists of the board. */
  lists?: Maybe<BoardListConnection>;
  /** Board milestone. */
  milestone?: Maybe<Milestone>;
  /** Name of the board. */
  name?: Maybe<Scalars['String']>;
  /** Timestamp of when the board was last updated. */
  updatedAt: Scalars['Time'];
  /** Web path of the board. */
  webPath: Scalars['String'];
  /** Web URL of the board. */
  webUrl: Scalars['String'];
  /** Weight of the board. */
  weight?: Maybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardEpicsArgs = {
  issueFilters?: InputMaybe<BoardIssueInput>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardListsArgs = {
  id?: InputMaybe<Scalars['ListID']>;
  issueFilters?: InputMaybe<BoardIssueInput>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Board. */
export type BoardConnection = {
  __typename?: 'BoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Board>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BoardEdge = {
  __typename?: 'BoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Board>;
};

/** Represents an epic on an issue board */
export type BoardEpic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'BoardEpic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of award emojis associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']>;
  /** Count of epics blocking this epic. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Epics blocking this epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that this epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  color?: Maybe<Scalars['String']>;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID'];
  /** Internal ID of the epic. */
  iid: Scalars['ID'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean'];
  /** Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  textColor?: Maybe<Scalars['String']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** User preferences for the epic on the issue board. */
  userPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Web path of the epic. */
  webPath: Scalars['String'];
  /** Web URL of the epic. */
  webUrl: Scalars['String'];
};


/** Represents an epic on an issue board */
export type BoardEpicAncestorsArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicChildrenArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic on an issue board */
export type BoardEpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

/** The connection type for BoardEpic. */
export type BoardEpicConnection = {
  __typename?: 'BoardEpicConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardEpic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BoardEpicCreate */
export type BoardEpicCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to create is in. */
  groupPath: Scalars['ID'];
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID'];
  /** Global ID of the epic board list in which epic will be created. */
  listId: Scalars['BoardsEpicListID'];
  /** Title of the epic. */
  title: Scalars['String'];
};

/** Autogenerated return type of BoardEpicCreate */
export type BoardEpicCreatePayload = {
  __typename?: 'BoardEpicCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after creation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type BoardEpicEdge = {
  __typename?: 'BoardEpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardEpic>;
};

/** Represents user preferences for a board epic */
export type BoardEpicUserPreferences = {
  __typename?: 'BoardEpicUserPreferences';
  /** Indicates epic should be displayed as collapsed. */
  collapsed: Scalars['Boolean'];
};

export type BoardIssueInput = {
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by epic ID. Incompatible with epicWildcardId. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']>>;
  /** List of negated arguments. */
  not?: InputMaybe<NegatedBoardIssueInput>;
  /** List of arguments with inclusive OR. */
  or?: InputMaybe<UnionedIssueFilterInput>;
  /** Search query for issue title or description. */
  search?: InputMaybe<Scalars['String']>;
  /** Filter by assignee wildcard. Incompatible with assigneeUsername. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Filter by epic ID wildcard. Incompatible with epicId. */
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Filter by a list of iteration cadence IDs. */
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  /** Filter by weight ID wildcard. Incompatible with weight. */
  weightWildcardId?: InputMaybe<WeightWildcardId>;
  /** Health status of the issue, "none" and "any" values are supported. */
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
};

/** Represents a list for an issue board */
export type BoardList = {
  __typename?: 'BoardList';
  /** Assignee in the list. */
  assignee?: Maybe<UserCore>;
  /** Indicates if the list is collapsed for this user. */
  collapsed?: Maybe<Scalars['Boolean']>;
  /** ID (global ID) of the list. */
  id: Scalars['ID'];
  /** Board issues. */
  issues?: Maybe<IssueConnection>;
  /** Count of issues in the list. */
  issuesCount?: Maybe<Scalars['Int']>;
  /** Iteration of the list. */
  iteration?: Maybe<Iteration>;
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Current limit metric for the list. */
  limitMetric?: Maybe<ListLimitMetric>;
  /** Type of the list. */
  listType: Scalars['String'];
  /** Maximum number of issues in the list. */
  maxIssueCount?: Maybe<Scalars['Int']>;
  /** Maximum weight of issues in the list. */
  maxIssueWeight?: Maybe<Scalars['Int']>;
  /** Milestone of the list. */
  milestone?: Maybe<Milestone>;
  /** Position of list within the board. */
  position?: Maybe<Scalars['Int']>;
  /** Title of the list. */
  title: Scalars['String'];
  /** Total weight of all issues in the list. */
  totalWeight?: Maybe<Scalars['Int']>;
};


/** Represents a list for an issue board */
export type BoardListIssuesArgs = {
  filters?: InputMaybe<BoardIssueInput>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BoardList. */
export type BoardListConnection = {
  __typename?: 'BoardListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BoardListCreate */
export type BoardListCreateInput = {
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardID'];
  /** Global ID of an existing milestone. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Global ID of an existing iteration. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** Global ID of an existing user. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
};

/** Autogenerated return type of BoardListCreate */
export type BoardListCreatePayload = {
  __typename?: 'BoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue list in the issue board. */
  list?: Maybe<BoardList>;
};

/** An edge in a connection. */
export type BoardListEdge = {
  __typename?: 'BoardListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardList>;
};

/** Autogenerated input type of BoardListUpdateLimitMetrics */
export type BoardListUpdateLimitMetricsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the list. */
  listId: Scalars['ListID'];
  /** New limit metric type for the list. */
  limitMetric?: InputMaybe<ListLimitMetric>;
  /** New maximum issue count limit. */
  maxIssueCount?: InputMaybe<Scalars['Int']>;
  /** New maximum issue weight limit. */
  maxIssueWeight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of BoardListUpdateLimitMetrics */
export type BoardListUpdateLimitMetricsPayload = {
  __typename?: 'BoardListUpdateLimitMetricsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated list. */
  list?: Maybe<BoardList>;
};

export type Branch = {
  __typename?: 'Branch';
  /** Commit for the branch. */
  commit?: Maybe<Commit>;
  /** Name of the branch. */
  name: Scalars['String'];
};

/** Branch protection details for a branch rule. */
export type BranchProtection = {
  __typename?: 'BranchProtection';
  /** Toggle force push to the branch for users with write access. */
  allowForcePush: Scalars['Boolean'];
  /** Enforce code owner approvals before allowing a merge. */
  codeOwnerApprovalRequired: Scalars['Boolean'];
  /** Details about who can merge when this branch is the source branch. */
  mergeAccessLevels?: Maybe<MergeAccessLevelConnection>;
  /** Details about who can push when this branch is the source branch. */
  pushAccessLevels?: Maybe<PushAccessLevelConnection>;
  /** Details about who can unprotect this branch. */
  unprotectAccessLevels?: Maybe<UnprotectAccessLevelConnection>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionMergeAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionPushAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionUnprotectAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** List of branch rules for a project, grouped by branch name. */
export type BranchRule = {
  __typename?: 'BranchRule';
  /** Merge request approval rules configured for this branch rule. */
  approvalRules?: Maybe<ApprovalProjectRuleConnection>;
  /** Branch protections configured for this branch rule. */
  branchProtection: BranchProtection;
  /** Timestamp of when the branch rule was created. */
  createdAt: Scalars['Time'];
  /** External status checks configured for this branch rule. */
  externalStatusChecks?: Maybe<ExternalStatusCheckConnection>;
  /** Check if this branch rule protects the project's default branch. */
  isDefault: Scalars['Boolean'];
  /** Number of existing branches that match this branch rule. */
  matchingBranchesCount: Scalars['Int'];
  /** Branch name, with wildcards, for the branch rules. */
  name: Scalars['String'];
  /** Timestamp of when the branch rule was last updated. */
  updatedAt: Scalars['Time'];
};


/** List of branch rules for a project, grouped by branch name. */
export type BranchRuleApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** List of branch rules for a project, grouped by branch name. */
export type BranchRuleExternalStatusChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BranchRule. */
export type BranchRuleConnection = {
  __typename?: 'BranchRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BranchRuleEdge = {
  __typename?: 'BranchRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BranchRule>;
};

/** Autogenerated input type of BulkEnableDevopsAdoptionNamespaces */
export type BulkEnableDevopsAdoptionNamespacesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** List of Namespace IDs. */
  namespaceIds: Array<Scalars['NamespaceID']>;
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
};

/** Autogenerated return type of BulkEnableDevopsAdoptionNamespaces */
export type BulkEnableDevopsAdoptionNamespacesPayload = {
  __typename?: 'BulkEnableDevopsAdoptionNamespacesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Enabled namespaces after mutation. */
  enabledNamespaces?: Maybe<Array<DevopsAdoptionEnabledNamespace>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of BulkRunnerDelete */
export type BulkRunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IDs of the runners to delete. */
  ids?: InputMaybe<Array<Scalars['CiRunnerID']>>;
};

/** Autogenerated return type of BulkRunnerDelete */
export type BulkRunnerDeletePayload = {
  __typename?: 'BulkRunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Number of records effectively deleted. Only present if operation was performed synchronously. */
  deletedCount?: Maybe<Scalars['Int']>;
  /** IDs of records effectively deleted. Only present if operation was performed synchronously. */
  deletedIds?: Maybe<Array<Scalars['CiRunnerID']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents the total number of issues and their weights for a particular day */
export type BurnupChartDailyTotals = {
  __typename?: 'BurnupChartDailyTotals';
  /** Number of closed issues as of this day. */
  completedCount: Scalars['Int'];
  /** Total weight of closed issues as of this day. */
  completedWeight: Scalars['Int'];
  /** Date for burnup totals. */
  date: Scalars['ISO8601Date'];
  /** Number of issues as of this day. */
  scopeCount: Scalars['Int'];
  /** Total weight of issues as of this day. */
  scopeWeight: Scalars['Int'];
};

export type CiApplicationSettings = {
  __typename?: 'CiApplicationSettings';
  /** Whether to keep the latest jobs artifacts. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']>;
};

export type CiBuildNeed = {
  __typename?: 'CiBuildNeed';
  /** ID of the BuildNeed. */
  id: Scalars['ID'];
  /** Name of the job we need to complete. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for CiBuildNeed. */
export type CiBuildNeedConnection = {
  __typename?: 'CiBuildNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiBuildNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiBuildNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiBuildNeedEdge = {
  __typename?: 'CiBuildNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiBuildNeed>;
};

/** Autogenerated input type of CiCdSettingsUpdate */
export type CiCdSettingsUpdateInput = {
  /** Full Path of the project the settings belong to. */
  fullPath: Scalars['ID'];
  /** Indicates if the latest artifact should be kept for this project. */
  keepLatestArtifact?: InputMaybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in this project have restricted access to other projects. */
  jobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge pipelines are enabled for the project. */
  mergePipelinesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge trains are enabled for the project. */
  mergeTrainsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CiCdSettingsUpdate */
export type CiCdSettingsUpdatePayload = {
  __typename?: 'CiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: ProjectCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type CiConfig = {
  __typename?: 'CiConfig';
  /** Linting errors. */
  errors?: Maybe<Array<Scalars['String']>>;
  /** List of included files. */
  includes?: Maybe<Array<CiConfigInclude>>;
  /** Merged CI configuration YAML. */
  mergedYaml?: Maybe<Scalars['String']>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiConfigStageConnection>;
  /** Status of linting, can be either valid or invalid. */
  status?: Maybe<CiConfigStatus>;
  /** Linting warnings. */
  warnings?: Maybe<Array<Scalars['String']>>;
};


export type CiConfigStagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CiConfigGroup = {
  __typename?: 'CiConfigGroup';
  /** Jobs in group. */
  jobs?: Maybe<CiConfigJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']>;
  /** Size of the job group. */
  size?: Maybe<Scalars['Int']>;
};


export type CiConfigGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigGroup. */
export type CiConfigGroupConnection = {
  __typename?: 'CiConfigGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigGroupEdge = {
  __typename?: 'CiConfigGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigGroup>;
};

export type CiConfigInclude = {
  __typename?: 'CiConfigInclude';
  /** File blob location. It can be masked if it contains masked variables, e.g., "https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml". */
  blob?: Maybe<Scalars['String']>;
  /** Current project scope, e.g., "gitlab-org/gitlab". */
  contextProject?: Maybe<Scalars['String']>;
  /** Current sha scope. */
  contextSha?: Maybe<Scalars['String']>;
  /**
   * Extra information for the `include`, which can contain `job_name`, `project`,
   * and `ref`. Values can be masked if they contain masked variables.
   */
  extra?: Maybe<Scalars['JSON']>;
  /** File location. It can be masked if it contains masked variables, e.g., ".gitlab/ci/build-images.gitlab-ci.yml". */
  location?: Maybe<Scalars['String']>;
  /** File raw location. It can be masked if it contains masked variables, e.g., "https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml". */
  raw?: Maybe<Scalars['String']>;
  /** Include type. */
  type?: Maybe<CiConfigIncludeType>;
};

/** Include type. */
export enum CiConfigIncludeType {
  /** Remote include. */
  Remote = 'remote',
  /** Local include. */
  Local = 'local',
  /** Project file include. */
  File = 'file',
  /** Template include. */
  Template = 'template'
}

export type CiConfigJob = {
  __typename?: 'CiConfigJob';
  /** Override a set of commands that are executed after the job. */
  afterScript?: Maybe<Array<Scalars['String']>>;
  /** Allow job to fail. */
  allowFailure?: Maybe<Scalars['Boolean']>;
  /** Override a set of commands that are executed before the job. */
  beforeScript?: Maybe<Array<Scalars['String']>>;
  /** Name of an environment to which the job deploys. */
  environment?: Maybe<Scalars['String']>;
  /** Limit when jobs are not created. */
  except?: Maybe<CiConfigJobRestriction>;
  /** Name of the job group. */
  groupName?: Maybe<Scalars['String']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']>;
  /** Builds that must complete before the jobs run. */
  needs?: Maybe<CiConfigNeedConnection>;
  /** Jobs are created when these conditions do not apply. */
  only?: Maybe<CiConfigJobRestriction>;
  /** Shell script that is executed by a runner. */
  script?: Maybe<Array<Scalars['String']>>;
  /** Name of the job stage. */
  stage?: Maybe<Scalars['String']>;
  /** List of tags that are used to select a runner. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** When to run the job. */
  when?: Maybe<Scalars['String']>;
};


export type CiConfigJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigJob. */
export type CiConfigJobConnection = {
  __typename?: 'CiConfigJobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigJobEdge = {
  __typename?: 'CiConfigJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigJob>;
};

export type CiConfigJobRestriction = {
  __typename?: 'CiConfigJobRestriction';
  /** Git refs the job restriction applies to. */
  refs?: Maybe<Array<Scalars['String']>>;
};

export type CiConfigNeed = {
  __typename?: 'CiConfigNeed';
  /** Name of the need. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for CiConfigNeed. */
export type CiConfigNeedConnection = {
  __typename?: 'CiConfigNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigNeedEdge = {
  __typename?: 'CiConfigNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigNeed>;
};

export type CiConfigStage = {
  __typename?: 'CiConfigStage';
  /** Groups of jobs for the stage. */
  groups?: Maybe<CiConfigGroupConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']>;
};


export type CiConfigStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigStage. */
export type CiConfigStageConnection = {
  __typename?: 'CiConfigStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigStageEdge = {
  __typename?: 'CiConfigStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigStage>;
};

/** Values for YAML processor result */
export enum CiConfigStatus {
  /** Configuration file is valid. */
  Valid = 'VALID',
  /** Configuration file is not valid. */
  Invalid = 'INVALID'
}

/** CI/CD config variables. */
export type CiConfigVariable = {
  __typename?: 'CiConfigVariable';
  /** Description for the CI/CD config variable. */
  description?: Maybe<Scalars['String']>;
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Value options for the variable. */
  valueOptions?: Maybe<Array<Scalars['String']>>;
};

export type CiGroup = {
  __typename?: 'CiGroup';
  /** Detailed status of the group. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** ID for a group. */
  id: Scalars['String'];
  /** Jobs in group. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']>;
  /** Size of the group. */
  size?: Maybe<Scalars['Int']>;
};


export type CiGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiGroup. */
export type CiGroupConnection = {
  __typename?: 'CiGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupEdge = {
  __typename?: 'CiGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroup>;
};

/** CI/CD variables for a group. */
export type CiGroupVariable = CiVariable & {
  __typename?: 'CiGroupVariable';
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiGroupVariable. */
export type CiGroupVariableConnection = {
  __typename?: 'CiGroupVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupVariableEdge>>>;
  /** Maximum amount of group CI/CD variables. */
  limit: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroupVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupVariableEdge = {
  __typename?: 'CiGroupVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroupVariable>;
};

/** CI/CD variables for a GitLab instance. */
export type CiInstanceVariable = CiVariable & {
  __typename?: 'CiInstanceVariable';
  /**
   * Scope defining the environments that can use the variable. Deprecated in 15.3:
   * No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.
   */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiInstanceVariable. */
export type CiInstanceVariableConnection = {
  __typename?: 'CiInstanceVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiInstanceVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiInstanceVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiInstanceVariableEdge = {
  __typename?: 'CiInstanceVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiInstanceVariable>;
};

export type CiJob = {
  __typename?: 'CiJob';
  /** Indicates the job is active. */
  active: Scalars['Boolean'];
  /** Whether the job is allowed to fail. */
  allowFailure: Scalars['Boolean'];
  /** Artifacts generated by the job. */
  artifacts?: Maybe<CiJobArtifactConnection>;
  /** URL for browsing the artifact's archive. */
  browseArtifactsPath?: Maybe<Scalars['String']>;
  /** Indicates the job can be canceled. */
  cancelable: Scalars['Boolean'];
  /** Path to the commit that triggered the job. */
  commitPath?: Maybe<Scalars['String']>;
  /** Coverage level of the job. */
  coverage?: Maybe<Scalars['Float']>;
  /** When the job was created. */
  createdAt: Scalars['Time'];
  /** Whether the job was created by a tag. */
  createdByTag: Scalars['Boolean'];
  /** Detailed status of the job. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Downstream pipeline for a bridge. */
  downstreamPipeline?: Maybe<Pipeline>;
  /** Duration of the job in seconds. */
  duration?: Maybe<Scalars['Int']>;
  /** When a job has finished running. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** ID of the job. */
  id?: Maybe<Scalars['JobID']>;
  /** Indicates the type of job. */
  kind: CiJobKind;
  /** Whether the job has a manual action. */
  manualJob?: Maybe<Scalars['Boolean']>;
  /** Variables added to a manual job when the job is triggered. */
  manualVariables?: Maybe<CiManualVariableConnection>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']>;
  /** References to builds that must complete before the jobs run. */
  needs?: Maybe<CiBuildNeedConnection>;
  /** Pipeline the job belongs to. */
  pipeline?: Maybe<Pipeline>;
  /** Indicates the job can be played. */
  playable: Scalars['Boolean'];
  /**
   * Jobs that must complete before the job runs. Returns `BuildNeed`, which is the
   * needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise.
   */
  previousStageJobsOrNeeds?: Maybe<JobNeedUnionConnection>;
  /** When the job was enqueued and marked as pending. */
  queuedAt?: Maybe<Scalars['Time']>;
  /** How long the job was enqueued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']>;
  /** Ref name of the job. */
  refName?: Maybe<Scalars['String']>;
  /** Path to the ref. */
  refPath?: Maybe<Scalars['String']>;
  /** Indicates that the job has been retried. */
  retried?: Maybe<Scalars['Boolean']>;
  /** Indicates the job can be retried. */
  retryable: Scalars['Boolean'];
  /** Schedule for the build. */
  scheduledAt?: Maybe<Scalars['Time']>;
  /** Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise. */
  schedulingType?: Maybe<Scalars['String']>;
  /** Short SHA1 ID of the commit. */
  shortSha: Scalars['String'];
  /** Stage of the job. */
  stage?: Maybe<CiStage>;
  /** When the job was started. */
  startedAt?: Maybe<Scalars['Time']>;
  /** Status of the job. */
  status?: Maybe<CiJobStatus>;
  /** Indicates the job is stuck. */
  stuck: Scalars['Boolean'];
  /** Tags for the current job. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** Whether the job was triggered. */
  triggered?: Maybe<Scalars['Boolean']>;
  /** Permissions for the current user on the resource */
  userPermissions: JobPermissions;
  /** Web path of the job. */
  webPath?: Maybe<Scalars['String']>;
};


export type CiJobArtifactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobManualVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobPreviousStageJobsOrNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CiJobArtifact = {
  __typename?: 'CiJobArtifact';
  /** URL for downloading the artifact's file. */
  downloadPath?: Maybe<Scalars['String']>;
  /** Expiry date of the artifact. */
  expireAt?: Maybe<Scalars['Time']>;
  /** File type of the artifact. */
  fileType?: Maybe<JobArtifactFileType>;
  /** ID of the artifact. */
  id: Scalars['CiJobArtifactID'];
  /** File name of the artifact. */
  name?: Maybe<Scalars['String']>;
  /** Size of the artifact in bytes. */
  size: Scalars['Int'];
};

/** The connection type for CiJobArtifact. */
export type CiJobArtifactConnection = {
  __typename?: 'CiJobArtifactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobArtifactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobArtifact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobArtifactEdge = {
  __typename?: 'CiJobArtifactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobArtifact>;
};

/** The connection type for CiJob. */
export type CiJobConnection = {
  __typename?: 'CiJobConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJob. */
export type CiJobConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type CiJobEdge = {
  __typename?: 'CiJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJob>;
};

export enum CiJobKind {
  /** Standard CI job. */
  Build = 'BUILD',
  /** Bridge CI job connecting a parent and child pipeline. */
  Bridge = 'BRIDGE'
}

export enum CiJobStatus {
  /** A job that is created. */
  Created = 'CREATED',
  /** A job that is waiting for resource. */
  WaitingForResource = 'WAITING_FOR_RESOURCE',
  /** A job that is preparing. */
  Preparing = 'PREPARING',
  /** A job that is pending. */
  Pending = 'PENDING',
  /** A job that is running. */
  Running = 'RUNNING',
  /** A job that is success. */
  Success = 'SUCCESS',
  /** A job that is failed. */
  Failed = 'FAILED',
  /** A job that is canceled. */
  Canceled = 'CANCELED',
  /** A job that is skipped. */
  Skipped = 'SKIPPED',
  /** A job that is manual. */
  Manual = 'MANUAL',
  /** A job that is scheduled. */
  Scheduled = 'SCHEDULED'
}

/** Autogenerated input type of CiJobTokenScopeAddProject */
export type CiJobTokenScopeAddProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID'];
  /** Project to be added to the CI job token scope. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated return type of CiJobTokenScopeAddProject */
export type CiJobTokenScopeAddProjectPayload = {
  __typename?: 'CiJobTokenScopeAddProjectPayload';
  /** CI job token's scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CiJobTokenScopeRemoveProject */
export type CiJobTokenScopeRemoveProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID'];
  /** Project to be removed from the CI job token scope. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated return type of CiJobTokenScopeRemoveProject */
export type CiJobTokenScopeRemoveProjectPayload = {
  __typename?: 'CiJobTokenScopeRemoveProjectPayload';
  /** CI job token's scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type CiJobTokenScopeType = {
  __typename?: 'CiJobTokenScopeType';
  /** Allow list of projects that can be accessed by CI Job tokens created by this project. */
  projects: ProjectConnection;
};


export type CiJobTokenScopeTypeProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** CI/CD variables given to a manual job. */
export type CiManualVariable = CiVariable & {
  __typename?: 'CiManualVariable';
  /**
   * Scope defining the environments that can use the variable. Deprecated in 15.3:
   * No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.
   */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiManualVariable. */
export type CiManualVariableConnection = {
  __typename?: 'CiManualVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiManualVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiManualVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiManualVariableEdge = {
  __typename?: 'CiManualVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiManualVariable>;
};

export type CiMinutesNamespaceMonthlyUsage = {
  __typename?: 'CiMinutesNamespaceMonthlyUsage';
  /** Total number of minutes used by all projects in the namespace. */
  minutes?: Maybe<Scalars['Int']>;
  /** Month related to the usage data. */
  month?: Maybe<Scalars['String']>;
  /** Month related to the usage data in ISO 8601 date format. */
  monthIso8601?: Maybe<Scalars['ISO8601Date']>;
  /** CI/CD minutes usage data for projects in the namespace. */
  projects?: Maybe<CiMinutesProjectMonthlyUsageConnection>;
  /** Total duration (in seconds) of shared runners use by the namespace for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']>;
};


export type CiMinutesNamespaceMonthlyUsageProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiMinutesNamespaceMonthlyUsage. */
export type CiMinutesNamespaceMonthlyUsageConnection = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesNamespaceMonthlyUsageEdge = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesNamespaceMonthlyUsage>;
};

export type CiMinutesProjectMonthlyUsage = {
  __typename?: 'CiMinutesProjectMonthlyUsage';
  /** Number of CI/CD minutes used by the project in the month. */
  minutes?: Maybe<Scalars['Int']>;
  /**
   * Name of the project. Deprecated in 15.6: Use `project.name`.
   * @deprecated Use `project.name`. Deprecated in 15.6.
   */
  name?: Maybe<Scalars['String']>;
  /** Project having the recorded usage. */
  project?: Maybe<Project>;
  /** Total duration (in seconds) of shared runners use by the project for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']>;
};

/** The connection type for CiMinutesProjectMonthlyUsage. */
export type CiMinutesProjectMonthlyUsageConnection = {
  __typename?: 'CiMinutesProjectMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesProjectMonthlyUsageEdge = {
  __typename?: 'CiMinutesProjectMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesProjectMonthlyUsage>;
};

/** CI/CD variables for a project. */
export type CiProjectVariable = CiVariable & {
  __typename?: 'CiProjectVariable';
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiProjectVariable. */
export type CiProjectVariableConnection = {
  __typename?: 'CiProjectVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiProjectVariableEdge>>>;
  /** Maximum amount of project CI/CD variables. */
  limit: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiProjectVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiProjectVariableEdge = {
  __typename?: 'CiProjectVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiProjectVariable>;
};

export type CiRunner = {
  __typename?: 'CiRunner';
  /** Access level of the runner. */
  accessLevel: CiRunnerAccessLevel;
  /**
   * Indicates the runner is allowed to receive jobs. Deprecated in 14.8: Use paused.
   * @deprecated Use paused. Deprecated in 14.8.
   */
  active: Scalars['Boolean'];
  /** Admin URL of the runner. Only available for administrators. */
  adminUrl?: Maybe<Scalars['String']>;
  /** Architecture provided by the the runner. */
  architectureName?: Maybe<Scalars['String']>;
  /** Timestamp of last contact from this runner. */
  contactedAt?: Maybe<Scalars['Time']>;
  /** Timestamp of creation of this runner. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Description of the runner. */
  description?: Maybe<Scalars['String']>;
  /** Admin form URL of the runner. Only available for administrators. */
  editAdminUrl?: Maybe<Scalars['String']>;
  /** Executor last advertised by the runner. */
  executorName?: Maybe<Scalars['String']>;
  /** Groups the runner is associated with. For group runners only. */
  groups?: Maybe<GroupConnection>;
  /** ID of the runner. */
  id: Scalars['CiRunnerID'];
  /** IP address of the runner. */
  ipAddress?: Maybe<Scalars['String']>;
  /** Number of jobs processed by the runner (limited to 1000, plus one to indicate that more items exist). */
  jobCount?: Maybe<Scalars['Int']>;
  /** Jobs assigned to the runner. This field can only be resolved for one runner in any single request. */
  jobs?: Maybe<CiJobConnection>;
  /** Indicates the runner is locked. */
  locked?: Maybe<Scalars['Boolean']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `maintenance_note` */
  maintenanceNoteHtml?: Maybe<Scalars['String']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: Maybe<Scalars['Int']>;
  /** Project that owns the runner. For project runners only. */
  ownerProject?: Maybe<Project>;
  /** Indicates the runner is paused and not available to run jobs. */
  paused: Scalars['Boolean'];
  /** Platform provided by the runner. */
  platformName?: Maybe<Scalars['String']>;
  /** Private projects' "minutes cost factor" associated with the runner (GitLab.com only). */
  privateProjectsMinutesCostFactor?: Maybe<Scalars['Float']>;
  /** Number of projects that the runner is associated with. */
  projectCount?: Maybe<Scalars['Int']>;
  /** Find projects the runner is associated with. For project runners only. */
  projects?: Maybe<ProjectConnection>;
  /** Public projects' "minutes cost factor" associated with the runner (GitLab.com only). */
  publicProjectsMinutesCostFactor?: Maybe<Scalars['Float']>;
  /** Revision of the runner. */
  revision?: Maybe<Scalars['String']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged: Scalars['Boolean'];
  /** Type of the runner. */
  runnerType: CiRunnerType;
  /** First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID. */
  shortSha?: Maybe<Scalars['String']>;
  /** Status of the runner. */
  status: CiRunnerStatus;
  /** Tags associated with the runner. */
  tagList?: Maybe<Array<Scalars['String']>>;
  /** Runner token expiration time. */
  tokenExpiresAt?: Maybe<Scalars['Time']>;
  /**
   * Availability of upgrades for the runner. Introduced in 14.10: This feature is
   * in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 14.10.
   */
  upgradeStatus?: Maybe<CiRunnerUpgradeStatus>;
  /** Permissions for the current user on the resource */
  userPermissions: RunnerPermissions;
  /** Version of the runner. */
  version?: Maybe<Scalars['String']>;
};


export type CiRunnerGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiRunnerJobsArgs = {
  statuses?: InputMaybe<Array<CiJobStatus>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiRunnerProjectsArgs = {
  membership?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']>;
  topics?: InputMaybe<Array<Scalars['String']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum CiRunnerAccessLevel {
  /** A runner that is not protected. */
  NotProtected = 'NOT_PROTECTED',
  /** A runner that is ref protected. */
  RefProtected = 'REF_PROTECTED'
}

/** The connection type for CiRunner. */
export type CiRunnerConnection = {
  __typename?: 'CiRunnerConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiRunnerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiRunner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiRunnerEdge = {
  __typename?: 'CiRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Web URL of the runner edit page. The value depends on where you put this field
   * in the query. You can use it for projects or groups.
   */
  editUrl?: Maybe<Scalars['String']>;
  /** The item at the end of the edge. */
  node?: Maybe<CiRunner>;
  /** Web URL of the runner. The value depends on where you put this field in the query. You can use it for projects or groups. */
  webUrl?: Maybe<Scalars['String']>;
};

/** Values for filtering runners in namespaces. The previous type name `RunnerMembershipFilter` was deprecated in 15.4. */
export enum CiRunnerMembershipFilter {
  /** Include runners that have a direct relationship. */
  Direct = 'DIRECT',
  /**
   * Include runners that have either a direct or inherited relationship. These
   * runners can be specific to a project or a group.
   */
  Descendants = 'DESCENDANTS',
  /**
   * Include all runners. This list includes runners for all projects in the group
   * and subgroups, as well as for the parent groups and instance. Introduced in
   * 15.5: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.5.
   */
  AllAvailable = 'ALL_AVAILABLE'
}

/** Values for sorting runners */
export enum CiRunnerSort {
  /** Ordered by contacted_at in ascending order. */
  ContactedAsc = 'CONTACTED_ASC',
  /** Ordered by contacted_at in descending order. */
  ContactedDesc = 'CONTACTED_DESC',
  /** Ordered by created_at in ascending order. */
  CreatedAsc = 'CREATED_ASC',
  /** Ordered by created_at in descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Ordered by token_expires_at in ascending order. */
  TokenExpiresAtAsc = 'TOKEN_EXPIRES_AT_ASC',
  /** Ordered by token_expires_at in descending order. */
  TokenExpiresAtDesc = 'TOKEN_EXPIRES_AT_DESC'
}

export enum CiRunnerStatus {
  /**
   * Runner that is not paused. Deprecated in 14.6: This was renamed.
   * @deprecated This was renamed. Please use `CiRunner.paused`. Deprecated in 14.6.
   */
  Active = 'ACTIVE',
  /**
   * Runner that is paused. Deprecated in 14.6: This was renamed.
   * @deprecated This was renamed. Please use `CiRunner.paused`. Deprecated in 14.6.
   */
  Paused = 'PAUSED',
  /** Runner that contacted this instance within the last 2 hours. */
  Online = 'ONLINE',
  /**
   * Runner that has not contacted this instance within the last 2 hours. Will be
   * considered `STALE` if offline for more than 3 months.
   */
  Offline = 'OFFLINE',
  /** Runner that has not contacted this instance within the last 3 months. */
  Stale = 'STALE',
  /** Runner that has never contacted this instance. */
  NeverContacted = 'NEVER_CONTACTED'
}

export enum CiRunnerType {
  /** A runner that is instance type. */
  InstanceType = 'INSTANCE_TYPE',
  /** A runner that is group type. */
  GroupType = 'GROUP_TYPE',
  /** A runner that is project type. */
  ProjectType = 'PROJECT_TYPE'
}

export enum CiRunnerUpgradeStatus {
  /** Runner version is not valid. */
  Invalid = 'INVALID',
  /** Upgrade is not available for the runner. */
  NotAvailable = 'NOT_AVAILABLE',
  /** Upgrade is available for the runner. */
  Available = 'AVAILABLE',
  /** Upgrade is available and recommended for the runner. */
  Recommended = 'RECOMMENDED'
}

/** Represents the Geo replication and verification state of a ci_secure_file. */
export type CiSecureFileRegistry = {
  __typename?: 'CiSecureFileRegistry';
  /** ID of the Ci Secure File. */
  ciSecureFileId: Scalars['ID'];
  /** Timestamp when the CiSecureFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the CiSecureFileRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the CiSecureFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the CiSecureFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the CiSecureFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the CiSecureFileRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the CiSecureFileRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the CiSecureFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the CiSecureFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for CiSecureFileRegistry. */
export type CiSecureFileRegistryConnection = {
  __typename?: 'CiSecureFileRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiSecureFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiSecureFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiSecureFileRegistryEdge = {
  __typename?: 'CiSecureFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiSecureFileRegistry>;
};

export type CiStage = {
  __typename?: 'CiStage';
  /** Detailed status of the stage. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Group of jobs for the stage. */
  groups?: Maybe<CiGroupConnection>;
  /** ID of the stage. */
  id: Scalars['ID'];
  /** Jobs for the stage. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']>;
  /** Status of the pipeline stage. */
  status?: Maybe<Scalars['String']>;
};


export type CiStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiStageJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiStage. */
export type CiStageConnection = {
  __typename?: 'CiStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiStageEdge = {
  __typename?: 'CiStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiStage>;
};

/** GitLab CI/CD configuration template. */
export type CiTemplate = {
  __typename?: 'CiTemplate';
  /** Contents of the CI template. */
  content: Scalars['String'];
  /** Name of the CI template. */
  name: Scalars['String'];
};

export type CiVariable = {
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** Attributes for defining a CI/CD variable. */
export type CiVariableInput = {
  /** Name of the variable. */
  key: Scalars['String'];
  /** Value of the variable. */
  value: Scalars['String'];
};

export enum CiVariableType {
  /** Env var type. */
  EnvVar = 'ENV_VAR',
  /** File type. */
  File = 'FILE'
}

export type ClusterAgent = {
  __typename?: 'ClusterAgent';
  /** Recent activity for the cluster agent. */
  activityEvents?: Maybe<ClusterAgentActivityEventConnection>;
  /** Active connections for the cluster agent */
  connections?: Maybe<ConnectedAgentConnection>;
  /** Timestamp the cluster agent was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User object, containing information about the person who created the agent. */
  createdByUser?: Maybe<UserCore>;
  /** ID of the cluster agent. */
  id: Scalars['ID'];
  /** Name of the cluster agent. */
  name?: Maybe<Scalars['String']>;
  /** Project this cluster agent is associated with. */
  project?: Maybe<Project>;
  /** Tokens associated with the cluster agent. */
  tokens?: Maybe<ClusterAgentTokenConnection>;
  /** Timestamp the cluster agent was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Container images reported on the agent vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /** Web path of the cluster agent. */
  webPath?: Maybe<Scalars['String']>;
};


export type ClusterAgentActivityEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentConnectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentTokensArgs = {
  status?: InputMaybe<AgentTokenStatus>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ClusterAgentActivityEvent = {
  __typename?: 'ClusterAgentActivityEvent';
  /** Agent token associated with the event. */
  agentToken?: Maybe<ClusterAgentToken>;
  /** Type of event. */
  kind?: Maybe<Scalars['String']>;
  /** Severity of the event. */
  level?: Maybe<Scalars['String']>;
  /** Timestamp the event was recorded. */
  recordedAt?: Maybe<Scalars['Time']>;
  /** User associated with the event. */
  user?: Maybe<UserCore>;
};

/** The connection type for ClusterAgentActivityEvent. */
export type ClusterAgentActivityEventConnection = {
  __typename?: 'ClusterAgentActivityEventConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentActivityEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentActivityEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentActivityEventEdge = {
  __typename?: 'ClusterAgentActivityEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentActivityEvent>;
};

/** The connection type for ClusterAgent. */
export type ClusterAgentConnection = {
  __typename?: 'ClusterAgentConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ClusterAgentDelete */
export type ClusterAgentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the cluster agent that will be deleted. */
  id: Scalars['ClustersAgentID'];
};

/** Autogenerated return type of ClusterAgentDelete */
export type ClusterAgentDeletePayload = {
  __typename?: 'ClusterAgentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type ClusterAgentEdge = {
  __typename?: 'ClusterAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgent>;
};

export type ClusterAgentToken = {
  __typename?: 'ClusterAgentToken';
  /** Cluster agent this token is associated with. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Timestamp the token was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User who created the token. */
  createdByUser?: Maybe<UserCore>;
  /** Description of the token. */
  description?: Maybe<Scalars['String']>;
  /** Global ID of the token. */
  id: Scalars['ClustersAgentTokenID'];
  /** Timestamp the token was last used. */
  lastUsedAt?: Maybe<Scalars['Time']>;
  /** Name given to the token. */
  name?: Maybe<Scalars['String']>;
  /** Current status of the token. */
  status?: Maybe<AgentTokenStatus>;
};

/** The connection type for ClusterAgentToken. */
export type ClusterAgentTokenConnection = {
  __typename?: 'ClusterAgentTokenConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the cluster agent that will be associated with the new token. */
  clusterAgentId: Scalars['ClustersAgentID'];
  /** Description of the token. */
  description?: InputMaybe<Scalars['String']>;
  /** Name of the token. */
  name: Scalars['String'];
};

/** Autogenerated return type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreatePayload = {
  __typename?: 'ClusterAgentTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Token secret value. Make sure you save it - you won't be able to access it again. */
  secret?: Maybe<Scalars['String']>;
  /** Token created after mutation. */
  token?: Maybe<ClusterAgentToken>;
};

/** An edge in a connection. */
export type ClusterAgentTokenEdge = {
  __typename?: 'ClusterAgentTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentToken>;
};

/** Autogenerated input type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the agent token that will be revoked. */
  id: Scalars['ClustersAgentTokenID'];
};

/** Autogenerated return type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokePayload = {
  __typename?: 'ClusterAgentTokenRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents the code coverage activity for a group */
export type CodeCoverageActivity = {
  __typename?: 'CodeCoverageActivity';
  /** Average percentage of the different code coverage results available for the group. */
  averageCoverage?: Maybe<Scalars['Float']>;
  /** Number of different code coverage results available for the group. */
  coverageCount?: Maybe<Scalars['Int']>;
  /** Date when the code coverage was created. */
  date: Scalars['Date'];
  /** Number of projects with code coverage results for the group. */
  projectCount?: Maybe<Scalars['Int']>;
};

/** The connection type for CodeCoverageActivity. */
export type CodeCoverageActivityConnection = {
  __typename?: 'CodeCoverageActivityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeCoverageActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeCoverageActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeCoverageActivityEdge = {
  __typename?: 'CodeCoverageActivityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeCoverageActivity>;
};

/** Represents the code coverage summary for a project */
export type CodeCoverageSummary = {
  __typename?: 'CodeCoverageSummary';
  /** Average percentage of the different code coverage results available for the project. */
  averageCoverage?: Maybe<Scalars['Float']>;
  /** Number of different code coverage results available. */
  coverageCount?: Maybe<Scalars['Int']>;
  /** Latest date when the code coverage was created for the project. */
  lastUpdatedOn?: Maybe<Scalars['Date']>;
};

/** Represents a code quality degradation on the pipeline. */
export type CodeQualityDegradation = {
  __typename?: 'CodeQualityDegradation';
  /** Description of the code quality degradation. */
  description: Scalars['String'];
  /** Unique fingerprint to identify the code quality degradation. For example, an MD5 hash. */
  fingerprint: Scalars['String'];
  /** Line on which the code quality degradation occurred. */
  line: Scalars['Int'];
  /** Relative path to the file containing the code quality degradation. */
  path: Scalars['String'];
  /** Status of the degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN). */
  severity: CodeQualityDegradationSeverity;
  /** URL to the file along with line number. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for CodeQualityDegradation. */
export type CodeQualityDegradationConnection = {
  __typename?: 'CodeQualityDegradationConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeQualityDegradationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeQualityDegradation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeQualityDegradationEdge = {
  __typename?: 'CodeQualityDegradationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeQualityDegradation>;
};

export enum CodeQualityDegradationSeverity {
  /** Code Quality degradation has a status of blocker. */
  Blocker = 'BLOCKER',
  /** Code Quality degradation has a status of critical. */
  Critical = 'CRITICAL',
  /** Code Quality degradation has a status of major. */
  Major = 'MAJOR',
  /** Code Quality degradation has a status of minor. */
  Minor = 'MINOR',
  /** Code Quality degradation has a status of info. */
  Info = 'INFO',
  /** Code Quality degradation has a status of unknown. */
  Unknown = 'UNKNOWN'
}

export type Commit = Todoable & {
  __typename?: 'Commit';
  /** Author of the commit. */
  author?: Maybe<UserCore>;
  /** Commit author's email. */
  authorEmail?: Maybe<Scalars['String']>;
  /** Commit authors gravatar. */
  authorGravatar?: Maybe<Scalars['String']>;
  /** Commit authors name. */
  authorName?: Maybe<Scalars['String']>;
  /** Timestamp of when the commit was authored. */
  authoredDate?: Maybe<Scalars['Time']>;
  /** Description of the commit message. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Full title of the commit message. */
  fullTitle?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `full_title` */
  fullTitleHtml?: Maybe<Scalars['String']>;
  /** ID (global ID) of the commit. */
  id: Scalars['ID'];
  /** Raw commit message. */
  message?: Maybe<Scalars['String']>;
  /** Pipelines of the commit ordered latest first. */
  pipelines?: Maybe<PipelineConnection>;
  /** SHA1 ID of the commit. */
  sha: Scalars['String'];
  /** Short SHA1 ID of the commit. */
  shortId: Scalars['String'];
  /** Signature of the commit. */
  signature?: Maybe<CommitSignature>;
  /** Rendered HTML of the commit signature. */
  signatureHtml?: Maybe<Scalars['String']>;
  /** Title of the commit message. */
  title?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Web path of the commit. */
  webPath: Scalars['String'];
  /** Web URL of the commit. */
  webUrl: Scalars['String'];
};


export type CommitPipelinesArgs = {
  status?: InputMaybe<PipelineStatusEnum>;
  scope?: InputMaybe<PipelineScopeEnum>;
  ref?: InputMaybe<Scalars['String']>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CommitAction = {
  /** Action to perform: create, delete, move, update, or chmod. */
  action: CommitActionMode;
  /** Content of the file. */
  content?: InputMaybe<Scalars['String']>;
  /** Encoding of the file. Default is text. */
  encoding?: InputMaybe<CommitEncoding>;
  /** Enables/disables the execute flag on the file. */
  executeFilemode?: InputMaybe<Scalars['Boolean']>;
  /** Full path to the file. */
  filePath: Scalars['String'];
  /** Last known file commit ID. */
  lastCommitId?: InputMaybe<Scalars['String']>;
  /** Original full path to the file being moved. */
  previousPath?: InputMaybe<Scalars['String']>;
};

/** Mode of a commit action */
export enum CommitActionMode {
  /** Create command. */
  Create = 'CREATE',
  /** Delete command. */
  Delete = 'DELETE',
  /** Move command. */
  Move = 'MOVE',
  /** Update command. */
  Update = 'UPDATE',
  /** Chmod command. */
  Chmod = 'CHMOD'
}

/** The connection type for Commit. */
export type CommitConnection = {
  __typename?: 'CommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CommitCreate */
export type CommitCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID'];
  /** Name of the branch to commit into, it can be a new branch. */
  branch: Scalars['String'];
  /** If on a new branch, name of the original branch. */
  startBranch?: InputMaybe<Scalars['String']>;
  /** Raw commit message. */
  message: Scalars['String'];
  /** Array of action hashes to commit as a batch. */
  actions: Array<CommitAction>;
};

/** Autogenerated return type of CommitCreate */
export type CommitCreatePayload = {
  __typename?: 'CommitCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Commit after mutation. */
  commit?: Maybe<Commit>;
  /** ETag path for the commit's pipeline. */
  commitPipelinePath?: Maybe<Scalars['String']>;
  /** Contents of the commit. */
  content?: Maybe<Array<Scalars['String']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type CommitEdge = {
  __typename?: 'CommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Commit>;
};

export enum CommitEncoding {
  /** Text encoding. */
  Text = 'TEXT',
  /** Base64 encoding. */
  Base64 = 'BASE64'
}

/** Represents signing information for a commit */
export type CommitSignature = {
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFramework = {
  __typename?: 'ComplianceFramework';
  /** Hexadecimal representation of compliance framework's label color. */
  color: Scalars['String'];
  /** Default compliance framework for the group. */
  default?: Maybe<Scalars['Boolean']>;
  /** Description of the compliance framework. */
  description: Scalars['String'];
  /** Compliance framework ID. */
  id: Scalars['ID'];
  /** Name of the compliance framework. */
  name: Scalars['String'];
  /**
   * Full path of the compliance pipeline configuration stored in a project
   * repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`
   * **(ULTIMATE)**.
   */
  pipelineConfigurationFullPath?: Maybe<Scalars['String']>;
};

/** The connection type for ComplianceFramework. */
export type ComplianceFrameworkConnection = {
  __typename?: 'ComplianceFrameworkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceFrameworkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceFramework>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceFrameworkEdge = {
  __typename?: 'ComplianceFrameworkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceFramework>;
};

export type ComplianceFrameworkInput = {
  /** New name for the compliance framework. */
  name?: InputMaybe<Scalars['String']>;
  /** New description for the compliance framework. */
  description?: InputMaybe<Scalars['String']>;
  /** New color representation of the compliance framework in hex format. e.g. #FCA121. */
  color?: InputMaybe<Scalars['String']>;
  /** Set this compliance framework as the default framework for the group. */
  default?: InputMaybe<Scalars['Boolean']>;
  /**
   * Full path of the compliance pipeline configuration stored in a project
   * repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`
   * **(ULTIMATE)**.
   */
  pipelineConfigurationFullPath?: InputMaybe<Scalars['String']>;
};

/** Compliance violation associated with a merged merge request. */
export type ComplianceViolation = {
  __typename?: 'ComplianceViolation';
  /** Compliance violation ID. */
  id: Scalars['ID'];
  /** Merge request the compliance violation occurred in. */
  mergeRequest: MergeRequest;
  /** Reason the compliance violation occurred. */
  reason: ComplianceViolationReason;
  /** Severity of the compliance violation. */
  severityLevel: ComplianceViolationSeverity;
  /** User suspected of causing the compliance violation. */
  violatingUser: UserCore;
};

/** The connection type for ComplianceViolation. */
export type ComplianceViolationConnection = {
  __typename?: 'ComplianceViolationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceViolationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceViolation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceViolationEdge = {
  __typename?: 'ComplianceViolationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceViolation>;
};

export type ComplianceViolationInput = {
  /** Filter compliance violations by project. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
  /** Merge requests merged before this date (inclusive). */
  mergedBefore?: InputMaybe<Scalars['Date']>;
  /** Merge requests merged after this date (inclusive). */
  mergedAfter?: InputMaybe<Scalars['Date']>;
};

/** Reason for the compliance violation. */
export enum ComplianceViolationReason {
  /** Approved by merge request author */
  ApprovedByMergeRequestAuthor = 'APPROVED_BY_MERGE_REQUEST_AUTHOR',
  /** Approved by committer */
  ApprovedByCommitter = 'APPROVED_BY_COMMITTER',
  /** Approved by insufficient users */
  ApprovedByInsufficientUsers = 'APPROVED_BY_INSUFFICIENT_USERS'
}

/** Severity of the compliance violation. */
export enum ComplianceViolationSeverity {
  /** Info severity */
  Info = 'INFO',
  /** Low severity */
  Low = 'LOW',
  /** Medium severity */
  Medium = 'MEDIUM',
  /** High severity */
  High = 'HIGH',
  /** Critical severity */
  Critical = 'CRITICAL'
}

/** Compliance violation sort values. */
export enum ComplianceViolationSort {
  /** Severity in descending order, further sorted by ID in descending order. */
  SeverityLevelDesc = 'SEVERITY_LEVEL_DESC',
  /** Severity in ascending order, further sorted by ID in ascending order. */
  SeverityLevelAsc = 'SEVERITY_LEVEL_ASC',
  /** Violation reason in descending order, further sorted by ID in descending order. */
  ViolationReasonDesc = 'VIOLATION_REASON_DESC',
  /** Violation reason in ascending order, further sorted by ID in ascending order. */
  ViolationReasonAsc = 'VIOLATION_REASON_ASC',
  /** Merge request title in descending order, further sorted by ID in descending order. */
  MergeRequestTitleDesc = 'MERGE_REQUEST_TITLE_DESC',
  /** Merge request title in ascending order, further sorted by ID in ascending order. */
  MergeRequestTitleAsc = 'MERGE_REQUEST_TITLE_ASC',
  /** Date merged in descending order, further sorted by ID in descending order. */
  MergedAtDesc = 'MERGED_AT_DESC',
  /** Date merged in ascending order, further sorted by ID in ascending order. */
  MergedAtAsc = 'MERGED_AT_ASC'
}

/** Composer metadata */
export type ComposerMetadata = {
  __typename?: 'ComposerMetadata';
  /** Data of the Composer JSON file. */
  composerJson: PackageComposerJsonType;
  /** Target SHA of the package. */
  targetSha: Scalars['String'];
};

/** Conan file metadata */
export type ConanFileMetadata = PackageFileMetadata & {
  __typename?: 'ConanFileMetadata';
  /** Type of the Conan file. */
  conanFileType: ConanMetadatumFileTypeEnum;
  /** Reference of the Conan package. */
  conanPackageReference?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanFileMetadatumID'];
  /** Revision of the package. */
  packageRevision?: Maybe<Scalars['String']>;
  /** Revision of the Conan recipe. */
  recipeRevision: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Conan metadata */
export type ConanMetadata = {
  __typename?: 'ConanMetadata';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanMetadatumID'];
  /** Channel of the Conan package. */
  packageChannel: Scalars['String'];
  /** Username of the Conan package. */
  packageUsername: Scalars['String'];
  /** Recipe of the Conan package. */
  recipe: Scalars['String'];
  /** Recipe path of the Conan package. */
  recipePath: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Conan file types */
export enum ConanMetadatumFileTypeEnum {
  /** A recipe file type. */
  RecipeFile = 'RECIPE_FILE',
  /** A package file type. */
  PackageFile = 'PACKAGE_FILE'
}

/** Autogenerated input type of ConfigureContainerScanning */
export type ConfigureContainerScanningInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConfigureContainerScanning */
export type ConfigureContainerScanningPayload = {
  __typename?: 'ConfigureContainerScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureDependencyScanning */
export type ConfigureDependencyScanningInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConfigureDependencyScanning */
export type ConfigureDependencyScanningPayload = {
  __typename?: 'ConfigureDependencyScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSastIac */
export type ConfigureSastIacInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConfigureSastIac */
export type ConfigureSastIacPayload = {
  __typename?: 'ConfigureSastIacPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSast */
export type ConfigureSastInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** SAST CI configuration for the project. */
  configuration: SastCiConfigurationInput;
};

/** Autogenerated return type of ConfigureSast */
export type ConfigureSastPayload = {
  __typename?: 'ConfigureSastPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSecretDetection */
export type ConfigureSecretDetectionInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConfigureSecretDetection */
export type ConfigureSecretDetectionPayload = {
  __typename?: 'ConfigureSecretDetectionPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Connection details for an Agent */
export type ConnectedAgent = {
  __typename?: 'ConnectedAgent';
  /** When the connection was established. */
  connectedAt?: Maybe<Scalars['Time']>;
  /** ID of the connection. */
  connectionId?: Maybe<Scalars['BigInt']>;
  /** Information about the Agent. */
  metadata?: Maybe<AgentMetadata>;
};

/** The connection type for ConnectedAgent. */
export type ConnectedAgentConnection = {
  __typename?: 'ConnectedAgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectedAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ConnectedAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConnectedAgentEdge = {
  __typename?: 'ConnectedAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectedAgent>;
};

/** Values for sorting contacts */
export enum ContactSort {
  /** First name in ascending order. */
  FirstNameAsc = 'FIRST_NAME_ASC',
  /** First name in descending order. */
  FirstNameDesc = 'FIRST_NAME_DESC',
  /** Last name in ascending order. */
  LastNameAsc = 'LAST_NAME_ASC',
  /** Last name in descending order. */
  LastNameDesc = 'LAST_NAME_DESC',
  /** Email in ascending order. */
  EmailAsc = 'EMAIL_ASC',
  /** Email in descending order. */
  EmailDesc = 'EMAIL_DESC',
  /** Phone in ascending order. */
  PhoneAsc = 'PHONE_ASC',
  /** Phone in descending order. */
  PhoneDesc = 'PHONE_DESC',
  /** Description in ascending order. */
  DescriptionAsc = 'DESCRIPTION_ASC',
  /** Description in descending order. */
  DescriptionDesc = 'DESCRIPTION_DESC',
  /** Organization in ascending order. */
  OrganizationAsc = 'ORGANIZATION_ASC',
  /** Organization in descending order. */
  OrganizationDesc = 'ORGANIZATION_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Represents the total number of contacts for the represented states. */
export type ContactStateCounts = {
  __typename?: 'ContactStateCounts';
  /** Number of contacts with state `ACTIVE` */
  active?: Maybe<Scalars['Int']>;
  /** Number of contacts with state `ALL` */
  all?: Maybe<Scalars['Int']>;
  /** Number of contacts with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']>;
};

/** A tag expiration policy designed to keep only the images that matter most */
export type ContainerExpirationPolicy = {
  __typename?: 'ContainerExpirationPolicy';
  /** This container expiration policy schedule. */
  cadence: ContainerExpirationPolicyCadenceEnum;
  /** Timestamp of when the container expiration policy was created. */
  createdAt: Scalars['Time'];
  /** Indicates whether this container expiration policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Number of tags to retain. */
  keepN?: Maybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching this regex pattern will expire. */
  nameRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Tags with names matching this regex pattern will be preserved. */
  nameRegexKeep?: Maybe<Scalars['UntrustedRegexp']>;
  /** Next time that this container expiration policy will get executed. */
  nextRunAt?: Maybe<Scalars['Time']>;
  /** Tags older that this will expire. */
  olderThan?: Maybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Timestamp of when the container expiration policy was updated. */
  updatedAt: Scalars['Time'];
};

export enum ContainerExpirationPolicyCadenceEnum {
  /** Every day */
  EveryDay = 'EVERY_DAY',
  /** Every week */
  EveryWeek = 'EVERY_WEEK',
  /** Every two weeks */
  EveryTwoWeeks = 'EVERY_TWO_WEEKS',
  /** Every month */
  EveryMonth = 'EVERY_MONTH',
  /** Every three months */
  EveryThreeMonths = 'EVERY_THREE_MONTHS'
}

export enum ContainerExpirationPolicyKeepEnum {
  /** 1 tag per image name */
  OneTag = 'ONE_TAG',
  /** 5 tags per image name */
  FiveTags = 'FIVE_TAGS',
  /** 10 tags per image name */
  TenTags = 'TEN_TAGS',
  /** 25 tags per image name */
  TwentyFiveTags = 'TWENTY_FIVE_TAGS',
  /** 50 tags per image name */
  FiftyTags = 'FIFTY_TAGS',
  /** 100 tags per image name */
  OneHundredTags = 'ONE_HUNDRED_TAGS'
}

export enum ContainerExpirationPolicyOlderThanEnum {
  /** 7 days until tags are automatically removed */
  SevenDays = 'SEVEN_DAYS',
  /** 14 days until tags are automatically removed */
  FourteenDays = 'FOURTEEN_DAYS',
  /** 30 days until tags are automatically removed */
  ThirtyDays = 'THIRTY_DAYS',
  /** 60 days until tags are automatically removed */
  SixtyDays = 'SIXTY_DAYS',
  /** 90 days until tags are automatically removed */
  NinetyDays = 'NINETY_DAYS'
}

/** A container repository */
export type ContainerRepository = {
  __typename?: 'ContainerRepository';
  /** Can the current user delete the container repository. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']>;
  /** ID of the container repository. */
  id: Scalars['ID'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']>;
  /** URL of the container repository. */
  location: Scalars['String'];
  /** Migration state of the container repository. */
  migrationState: Scalars['String'];
  /** Name of the container repository. */
  name: Scalars['String'];
  /** Path of the container repository. */
  path: Scalars['String'];
  /** Project of the container registry. */
  project: Project;
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Number of tags associated with this image. */
  tagsCount: Scalars['Int'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time'];
};

/** Status of the tags cleanup of a container repository */
export enum ContainerRepositoryCleanupStatus {
  /** Tags cleanup is not scheduled. This is the default state. */
  Unscheduled = 'UNSCHEDULED',
  /** Tags cleanup is scheduled and is going to be executed shortly. */
  Scheduled = 'SCHEDULED',
  /** Tags cleanup has been partially executed. There are still remaining tags to delete. */
  Unfinished = 'UNFINISHED',
  /** Tags cleanup is ongoing. */
  Ongoing = 'ONGOING'
}

/** The connection type for ContainerRepository. */
export type ContainerRepositoryConnection = {
  __typename?: 'ContainerRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Details of a container repository */
export type ContainerRepositoryDetails = {
  __typename?: 'ContainerRepositoryDetails';
  /** Can the current user delete the container repository. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']>;
  /** ID of the container repository. */
  id: Scalars['ID'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']>;
  /** URL of the container repository. */
  location: Scalars['String'];
  /** Migration state of the container repository. */
  migrationState: Scalars['String'];
  /** Name of the container repository. */
  name: Scalars['String'];
  /** Path of the container repository. */
  path: Scalars['String'];
  /** Project of the container registry. */
  project: Project;
  /**
   * Deduplicated size of the image repository in bytes. This is only available on
   * GitLab.com for repositories created after `2021-11-04`.
   */
  size?: Maybe<Scalars['Float']>;
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Tags of the container repository. */
  tags?: Maybe<ContainerRepositoryTagConnection>;
  /** Number of tags associated with this image. */
  tagsCount: Scalars['Int'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time'];
};


/** Details of a container repository */
export type ContainerRepositoryDetailsTagsArgs = {
  sort?: InputMaybe<ContainerRepositoryTagSort>;
  name?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ContainerRepositoryEdge = {
  __typename?: 'ContainerRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepository>;
};

/** Represents the Geo replication and verification state of an Container Repository. */
export type ContainerRepositoryRegistry = {
  __typename?: 'ContainerRepositoryRegistry';
  /** ID of the ContainerRepository. */
  containerRepositoryId: Scalars['ID'];
  /** Timestamp when the ContainerRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the ContainerRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the ContainerRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the ContainerRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the ContainerRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the ContainerRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the ContainerRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the ContainerRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the ContainerRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for ContainerRepositoryRegistry. */
export type ContainerRepositoryRegistryConnection = {
  __typename?: 'ContainerRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerRepositoryRegistryEdge = {
  __typename?: 'ContainerRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryRegistry>;
};

/** Values for sorting container repositories */
export enum ContainerRepositorySort {
  /** Name by ascending order. */
  NameAsc = 'NAME_ASC',
  /** Name by descending order. */
  NameDesc = 'NAME_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Status of a container repository */
export enum ContainerRepositoryStatus {
  /** Delete Scheduled status. */
  DeleteScheduled = 'DELETE_SCHEDULED',
  /** Delete Failed status. */
  DeleteFailed = 'DELETE_FAILED',
  /** Delete Ongoing status. */
  DeleteOngoing = 'DELETE_ONGOING'
}

/** A tag from a container repository */
export type ContainerRepositoryTag = {
  __typename?: 'ContainerRepositoryTag';
  /** Can the current user delete this tag. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the tag was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Digest of the tag. */
  digest?: Maybe<Scalars['String']>;
  /** URL of the tag. */
  location: Scalars['String'];
  /** Name of the tag. */
  name: Scalars['String'];
  /** Path of the tag. */
  path: Scalars['String'];
  /** Revision of the tag. */
  revision?: Maybe<Scalars['String']>;
  /** Short revision of the tag. */
  shortRevision?: Maybe<Scalars['String']>;
  /** Size of the tag. */
  totalSize?: Maybe<Scalars['BigInt']>;
};

/** The connection type for ContainerRepositoryTag. */
export type ContainerRepositoryTagConnection = {
  __typename?: 'ContainerRepositoryTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerRepositoryTagEdge = {
  __typename?: 'ContainerRepositoryTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryTag>;
};

/** Values for sorting tags */
export enum ContainerRepositoryTagSort {
  /** Ordered by name in ascending order. */
  NameAsc = 'NAME_ASC',
  /** Ordered by name in descending order. */
  NameDesc = 'NAME_DESC'
}

/** Represents the contributions of a user. */
export type ContributionAnalyticsContribution = {
  __typename?: 'ContributionAnalyticsContribution';
  /** Number of issues closed by the user. */
  issuesClosed?: Maybe<Scalars['Int']>;
  /** Number of issues created by the user. */
  issuesCreated?: Maybe<Scalars['Int']>;
  /** Number of merge requests approved by the user. */
  mergeRequestsApproved?: Maybe<Scalars['Int']>;
  /** Number of merge requests closed by the user. */
  mergeRequestsClosed?: Maybe<Scalars['Int']>;
  /** Number of merge requests created by the user. */
  mergeRequestsCreated?: Maybe<Scalars['Int']>;
  /** Number of merge requests merged by the user. */
  mergeRequestsMerged?: Maybe<Scalars['Int']>;
  /** Number of repository pushes the user made. */
  repoPushed?: Maybe<Scalars['Int']>;
  /** Total number of events contributed by the user. */
  totalEvents?: Maybe<Scalars['Int']>;
  /** Contributor User object. */
  user?: Maybe<UserCore>;
};

/** The connection type for ContributionAnalyticsContribution. */
export type ContributionAnalyticsContributionConnection = {
  __typename?: 'ContributionAnalyticsContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContributionAnalyticsContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContributionAnalyticsContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContributionAnalyticsContributionEdge = {
  __typename?: 'ContributionAnalyticsContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContributionAnalyticsContribution>;
};

/** Autogenerated input type of CorpusCreate */
export type CorpusCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the corpus package. */
  packageId: Scalars['PackagesPackageID'];
  /** Project the corpus belongs to. */
  fullPath: Scalars['ID'];
};

/** Autogenerated return type of CorpusCreate */
export type CorpusCreatePayload = {
  __typename?: 'CorpusCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Corpus for a coverage fuzzing job. */
export type CoverageFuzzingCorpus = {
  __typename?: 'CoverageFuzzingCorpus';
  /** ID of the corpus. */
  id: Scalars['AppSecFuzzingCoverageCorpusID'];
  /** Package of the corpus. */
  package: PackageDetailsType;
};

/** The connection type for CoverageFuzzingCorpus. */
export type CoverageFuzzingCorpusConnection = {
  __typename?: 'CoverageFuzzingCorpusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CoverageFuzzingCorpusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CoverageFuzzingCorpus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CoverageFuzzingCorpusEdge = {
  __typename?: 'CoverageFuzzingCorpusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CoverageFuzzingCorpus>;
};

/** Autogenerated input type of CreateAlertIssue */
export type CreateAlertIssueInput = {
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateAlertIssue */
export type CreateAlertIssuePayload = {
  __typename?: 'CreateAlertIssuePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of CreateAnnotation */
export type CreateAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the environment to add an annotation to. */
  environmentId?: InputMaybe<Scalars['EnvironmentID']>;
  /** Global ID of the cluster to add an annotation to. */
  clusterId?: InputMaybe<Scalars['ClustersClusterID']>;
  /** Timestamp indicating starting moment to which the annotation relates. */
  startingAt: Scalars['Time'];
  /** Timestamp indicating ending moment to which the annotation relates. */
  endingAt?: InputMaybe<Scalars['Time']>;
  /** Path to a file defining the dashboard on which the annotation should be added. */
  dashboardPath: Scalars['String'];
  /** Description of the annotation. */
  description: Scalars['String'];
};

/** Autogenerated return type of CreateAnnotation */
export type CreateAnnotationPayload = {
  __typename?: 'CreateAnnotationPayload';
  /** Created annotation. */
  annotation?: Maybe<MetricsDashboardAnnotation>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateBoard */
export type CreateBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
};

/** Autogenerated return type of CreateBoard */
export type CreateBoardPayload = {
  __typename?: 'CreateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateBranch */
export type CreateBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID'];
  /** Name of the branch. */
  name: Scalars['String'];
  /** Branch name or commit SHA to create branch from. */
  ref: Scalars['String'];
};

/** Autogenerated return type of CreateBranch */
export type CreateBranchPayload = {
  __typename?: 'CreateBranchPayload';
  /** Branch after mutation. */
  branch?: Maybe<Branch>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateClusterAgent */
export type CreateClusterAgentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the associated project for this cluster agent. */
  projectPath: Scalars['ID'];
  /** Name of the cluster agent. */
  name: Scalars['String'];
};

/** Autogenerated return type of CreateClusterAgent */
export type CreateClusterAgentPayload = {
  __typename?: 'CreateClusterAgentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Cluster agent created after mutation. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateComplianceFramework */
export type CreateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the namespace to add the compliance framework to. */
  namespacePath: Scalars['ID'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of CreateComplianceFramework */
export type CreateComplianceFrameworkPayload = {
  __typename?: 'CreateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created compliance framework. */
  framework?: Maybe<ComplianceFramework>;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Namespace full path the emoji is associated with. */
  groupPath: Scalars['ID'];
  /** Name of the emoji. */
  name: Scalars['String'];
  /** Location of the emoji file. */
  url: Scalars['String'];
};

/** Autogenerated return type of CreateCustomEmoji */
export type CreateCustomEmojiPayload = {
  __typename?: 'CreateCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** New custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateDiffNote */
export type CreateDiffNoteInput = {
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
  /** Content of the note. */
  body: Scalars['String'];
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Position of this note on a diff. */
  position: DiffPositionInput;
};

/** Autogenerated return type of CreateDiffNote */
export type CreateDiffNotePayload = {
  __typename?: 'CreateDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateEpic */
export type CreateEpicInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID'];
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']>>;
  /**
   * Color of the epic. Available only when feature flag `epic_color_highlight` is
   * enabled. This flag is disabled by default, because the feature is experimental
   * and is subject to change without notice.
   */
  color?: InputMaybe<Scalars['Color']>;
};

/** Autogenerated return type of CreateEpic */
export type CreateEpicPayload = {
  __typename?: 'CreateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created epic. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateImageDiffNote */
export type CreateImageDiffNoteInput = {
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
  /** Content of the note. */
  body: Scalars['String'];
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Position of this note on a diff. */
  position: DiffImagePositionInput;
};

/** Autogenerated return type of CreateImageDiffNote */
export type CreateImageDiffNotePayload = {
  __typename?: 'CreateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Project full path the issue is associated with. */
  projectPath: Scalars['ID'];
  /** IID (internal ID) of a project issue. Only admins and project owners can modify. */
  iid?: InputMaybe<Scalars['Int']>;
  /** Title of the issue. */
  title: Scalars['String'];
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** IDs of labels to be added to the issue. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Timestamp when the issue was created. Available only for admins and project owners. */
  createdAt?: InputMaybe<Scalars['Time']>;
  /** IID of a merge request for which to resolve discussions. */
  mergeRequestToResolveDiscussionsOf?: InputMaybe<Scalars['MergeRequestID']>;
  /** ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`. */
  discussionToResolve?: InputMaybe<Scalars['String']>;
  /** Array of user IDs to assign to the issue. */
  assigneeIds?: InputMaybe<Array<Scalars['UserID']>>;
  /** Global ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['IssueID']>;
  /** Global ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['IssueID']>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']>;
  /** ID of an epic to associate the issue with. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Global iteration ID. Mutually exlusive argument with `iterationWildcardId`. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /**
   * Iteration wildcard ID. Supported values are: `CURRENT`. Mutually exclusive
   * argument with `iterationId`. iterationCadenceId also required when this
   * argument is provided.
   */
  iterationWildcardId?: InputMaybe<IssueCreationIterationWildcardId>;
  /** Global iteration cadence ID. Required when `iterationWildcardId` is provided. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
};

/** Autogenerated return type of CreateIssue */
export type CreateIssuePayload = {
  __typename?: 'CreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateIteration */
export type CreateIterationInput = {
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateIteration */
export type CreateIterationPayload = {
  __typename?: 'CreateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
  /** Content of the note. */
  body: Scalars['String'];
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the discussion this note is in reply to. */
  discussionId?: InputMaybe<Scalars['DiscussionID']>;
  /** SHA of the head commit which is used to ensure that the merge request has not been updated since the request was sent. */
  mergeRequestDiffHeadSha?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateNote */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateRequirement */
export type CreateRequirementInput = {
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateRequirement */
export type CreateRequirementPayload = {
  __typename?: 'CreateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of CreateSnippet */
export type CreateSnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Title of the snippet. */
  title: Scalars['String'];
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']>;
  /** Visibility level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
  /** Full path of the project the snippet is associated with. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Paths to files uploaded in the snippet description. */
  uploadedFiles?: InputMaybe<Array<Scalars['String']>>;
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
};

/** Autogenerated return type of CreateSnippet */
export type CreateSnippetPayload = {
  __typename?: 'CreateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Autogenerated input type of CreateTestCase */
export type CreateTestCaseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Test case title. */
  title: Scalars['String'];
  /** Test case description. */
  description?: InputMaybe<Scalars['String']>;
  /** IDs of labels to be added to the test case. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Project full path to create the test case in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of CreateTestCase */
export type CreateTestCasePayload = {
  __typename?: 'CreateTestCasePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Test case created. */
  testCase?: Maybe<Issue>;
};

/** Represents the current license */
export type CurrentLicense = {
  __typename?: 'CurrentLicense';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']>;
  /** Number of billable users on the system. */
  billableUsersCount?: Maybe<Scalars['Int']>;
  /** Date, including grace period, when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID'];
  /** Date when the license was last synced. */
  lastSync?: Maybe<Scalars['Time']>;
  /** Highest number of billable users on the system during the term of the current license. */
  maximumUserCount?: Maybe<Scalars['Int']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of the license. */
  type: Scalars['String'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
  /** Number of users over the paid users in the license. */
  usersOverLicenseCount?: Maybe<Scalars['Int']>;
};

export type CurrentUserTodos = {
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
};


export type CurrentUserTodosCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};

/** A custom emoji uploaded by user */
export type CustomEmoji = {
  __typename?: 'CustomEmoji';
  /** Whether the emoji is an external link. */
  external: Scalars['Boolean'];
  /** ID of the emoji. */
  id: Scalars['CustomEmojiID'];
  /** Name of the emoji. */
  name: Scalars['String'];
  /** Link to file of the emoji. */
  url: Scalars['String'];
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: 'CustomEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: 'CustomEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

export type CustomerRelationsContact = {
  __typename?: 'CustomerRelationsContact';
  /** State of the contact. */
  active: Scalars['Boolean'];
  /** Timestamp the contact was created. */
  createdAt: Scalars['Time'];
  /** Description of or notes for the contact. */
  description?: Maybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: Maybe<Scalars['String']>;
  /** First name of the contact. */
  firstName: Scalars['String'];
  /** Internal ID of the contact. */
  id: Scalars['ID'];
  /** Last name of the contact. */
  lastName: Scalars['String'];
  /** Organization of the contact. */
  organization?: Maybe<CustomerRelationsOrganization>;
  /** Phone number of the contact. */
  phone?: Maybe<Scalars['String']>;
  /** Timestamp the contact was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for CustomerRelationsContact. */
export type CustomerRelationsContactConnection = {
  __typename?: 'CustomerRelationsContactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsContactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsContact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsContactCreate */
export type CustomerRelationsContactCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group for the contact. */
  groupId: Scalars['GroupID'];
  /** Organization for the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']>;
  /** First name of the contact. */
  firstName: Scalars['String'];
  /** Last name of the contact. */
  lastName: Scalars['String'];
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CustomerRelationsContactCreate */
export type CustomerRelationsContactCreatePayload = {
  __typename?: 'CustomerRelationsContactCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type CustomerRelationsContactEdge = {
  __typename?: 'CustomerRelationsContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsContact>;
};

export enum CustomerRelationsContactState {
  /** All available contacts. */
  All = 'all',
  /** Active contacts. */
  Active = 'active',
  /** Inactive contacts. */
  Inactive = 'inactive'
}

/** Autogenerated input type of CustomerRelationsContactUpdate */
export type CustomerRelationsContactUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the contact. */
  id: Scalars['CustomerRelationsContactID'];
  /** Organization of the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']>;
  /** First name of the contact. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Last name of the contact. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']>;
  /** State of the contact. */
  active?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of CustomerRelationsContactUpdate */
export type CustomerRelationsContactUpdatePayload = {
  __typename?: 'CustomerRelationsContactUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type CustomerRelationsOrganization = {
  __typename?: 'CustomerRelationsOrganization';
  /** State of the organization. */
  active: Scalars['Boolean'];
  /** Timestamp the organization was created. */
  createdAt: Scalars['Time'];
  /** Standard billing rate for the organization. */
  defaultRate?: Maybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the organization. */
  id: Scalars['ID'];
  /** Name of the organization. */
  name: Scalars['String'];
  /** Timestamp the organization was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for CustomerRelationsOrganization. */
export type CustomerRelationsOrganizationConnection = {
  __typename?: 'CustomerRelationsOrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsOrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsOrganization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsOrganizationCreate */
export type CustomerRelationsOrganizationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group for the organization. */
  groupId: Scalars['GroupID'];
  /** Name of the organization. */
  name: Scalars['String'];
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CustomerRelationsOrganizationCreate */
export type CustomerRelationsOrganizationCreatePayload = {
  __typename?: 'CustomerRelationsOrganizationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Organization after the mutation. */
  organization?: Maybe<CustomerRelationsOrganization>;
};

/** An edge in a connection. */
export type CustomerRelationsOrganizationEdge = {
  __typename?: 'CustomerRelationsOrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsOrganization>;
};

export enum CustomerRelationsOrganizationState {
  /** All available organizations. */
  All = 'all',
  /** Active organizations. */
  Active = 'active',
  /** Inactive organizations. */
  Inactive = 'inactive'
}

/** Autogenerated input type of CustomerRelationsOrganizationUpdate */
export type CustomerRelationsOrganizationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the organization. */
  id: Scalars['CustomerRelationsOrganizationID'];
  /** Name of the organization. */
  name?: InputMaybe<Scalars['String']>;
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']>;
  /** State of the organization. */
  active?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of CustomerRelationsOrganizationUpdate */
export type CustomerRelationsOrganizationUpdatePayload = {
  __typename?: 'CustomerRelationsOrganizationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Organization after the mutation. */
  organization: CustomerRelationsOrganization;
};

/** Autogenerated input type of DastOnDemandScanCreate */
export type DastOnDemandScanCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
  /** ID of the site profile to be used for the scan. */
  dastSiteProfileId: Scalars['DastSiteProfileID'];
  /** ID of the scanner profile to be used for the scan. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']>;
};

/** Autogenerated return type of DastOnDemandScanCreate */
export type DastOnDemandScanCreatePayload = {
  __typename?: 'DastOnDemandScanCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Represents a DAST Profile */
export type DastProfile = {
  __typename?: 'DastProfile';
  /** Associated branch. */
  branch?: Maybe<DastProfileBranch>;
  /** Associated profile schedule. */
  dastProfileSchedule?: Maybe<DastProfileSchedule>;
  /** Associated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Associated site profile. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Description of the scan. */
  description?: Maybe<Scalars['String']>;
  /** Relative web path to the edit page of a profile. */
  editPath?: Maybe<Scalars['String']>;
  /** ID of the profile. */
  id: Scalars['DastProfileID'];
  /** Name of the profile. */
  name?: Maybe<Scalars['String']>;
};

/** Represents a DAST Profile Branch */
export type DastProfileBranch = {
  __typename?: 'DastProfileBranch';
  /** Indicates whether or not the branch exists. */
  exists?: Maybe<Scalars['Boolean']>;
  /** Name of the branch. */
  name?: Maybe<Scalars['String']>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadence = {
  __typename?: 'DastProfileCadence';
  /** Duration of the DAST profile cadence. */
  duration?: Maybe<Scalars['Int']>;
  /** Unit for the duration of DAST profile cadence. */
  unit?: Maybe<DastProfileCadenceUnit>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadenceInput = {
  /** Unit for the duration of DAST Profile Cadence. */
  unit?: InputMaybe<DastProfileCadenceUnit>;
  /** Duration of the DAST Profile Cadence. */
  duration?: InputMaybe<Scalars['Int']>;
};

/** Unit for the duration of Dast Profile Cadence. */
export enum DastProfileCadenceUnit {
  /** DAST Profile Cadence duration in days. */
  Day = 'DAY',
  /** DAST Profile Cadence duration in weeks. */
  Week = 'WEEK',
  /** DAST Profile Cadence duration in months. */
  Month = 'MONTH',
  /** DAST Profile Cadence duration in years. */
  Year = 'YEAR'
}

/** The connection type for DastProfile. */
export type DastProfileConnection = {
  __typename?: 'DastProfileConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastProfileCreate */
export type DastProfileCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the profile belongs to. */
  fullPath: Scalars['ID'];
  /** Represents a DAST Profile Schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** Name of the profile. */
  name: Scalars['String'];
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']>;
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']>;
  /** ID of the site profile to be associated. */
  dastSiteProfileId: Scalars['DastSiteProfileID'];
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId: Scalars['DastScannerProfileID'];
  /** Run scan using profile after creation. Defaults to false. */
  runAfterCreate?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastProfileCreate */
export type DastProfileCreatePayload = {
  __typename?: 'DastProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. Requires `runAfterCreate` to be set to `true`. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DastProfileDelete */
export type DastProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID'];
};

/** Autogenerated return type of DastProfileDelete */
export type DastProfileDeletePayload = {
  __typename?: 'DastProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastProfileEdge = {
  __typename?: 'DastProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastProfile>;
};

/** Autogenerated input type of DastProfileRun */
export type DastProfileRunInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the profile to be used for the scan. */
  id: Scalars['DastProfileID'];
};

/** Autogenerated return type of DastProfileRun */
export type DastProfileRunPayload = {
  __typename?: 'DastProfileRunPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Represents a DAST profile schedule. */
export type DastProfileSchedule = {
  __typename?: 'DastProfileSchedule';
  /** Status of the DAST profile schedule. */
  active?: Maybe<Scalars['Boolean']>;
  /** Cadence of the DAST profile schedule. */
  cadence?: Maybe<DastProfileCadence>;
  /** ID of the DAST profile schedule. */
  id: Scalars['DastProfileScheduleID'];
  /** Next run time of the DAST profile schedule in the given timezone. */
  nextRunAt?: Maybe<Scalars['Time']>;
  /** Status of the current owner of the DAST profile schedule. */
  ownerValid?: Maybe<Scalars['Boolean']>;
  /** Start time of the DAST profile schedule in the given timezone. */
  startsAt?: Maybe<Scalars['Time']>;
  /** Time zone of the start time of the DAST profile schedule. */
  timezone?: Maybe<Scalars['String']>;
};

/** Input type for DAST Profile Schedules */
export type DastProfileScheduleInput = {
  /** Status of a Dast Profile Schedule. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Start time of a Dast Profile Schedule. */
  startsAt?: InputMaybe<Scalars['Time']>;
  /** Time Zone for the Start time of a Dast Profile Schedule. */
  timezone?: InputMaybe<Scalars['String']>;
  /** Cadence of a Dast Profile Schedule. */
  cadence?: InputMaybe<DastProfileCadenceInput>;
};

/** Autogenerated input type of DastProfileUpdate */
export type DastProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID'];
  /** Represents a DAST profile schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** Name of the profile. */
  name?: InputMaybe<Scalars['String']>;
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']>;
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']>;
  /** ID of the site profile to be associated. */
  dastSiteProfileId?: InputMaybe<Scalars['DastSiteProfileID']>;
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']>;
  /** Run scan using profile after update. Defaults to false. */
  runAfterUpdate?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastProfileUpdate */
export type DastProfileUpdatePayload = {
  __typename?: 'DastProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * The URL of the pipeline that was created. Requires the input argument
   * `runAfterUpdate` to be set to `true` when calling the mutation, otherwise no
   * pipeline will be created.
   */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Scan method to be used by the scanner. */
export enum DastScanMethodType {
  /** Website scan method. */
  Website = 'WEBSITE',
  /** OpenAPI scan method. */
  Openapi = 'OPENAPI',
  /** HAR scan method. */
  Har = 'HAR',
  /** Postman scan method. */
  PostmanCollection = 'POSTMAN_COLLECTION'
}

/** Represents a DAST scanner profile */
export type DastScannerProfile = {
  __typename?: 'DastScannerProfile';
  /** Relative web path to the edit page of a scanner profile. */
  editPath?: Maybe<Scalars['String']>;
  /** ID of the DAST scanner profile. */
  id: Scalars['DastScannerProfileID'];
  /** Name of the DAST scanner profile. */
  profileName?: Maybe<Scalars['String']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']>>;
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: Maybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages: Scalars['Boolean'];
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: Maybe<Scalars['Int']>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: Maybe<Scalars['Int']>;
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider: Scalars['Boolean'];
};

/** The connection type for DastScannerProfile. */
export type DastScannerProfileConnection = {
  __typename?: 'DastScannerProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastScannerProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastScannerProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastScannerProfileCreate */
export type DastScannerProfileCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the scanner profile belongs to. */
  fullPath: Scalars['ID'];
  /** Name of the scanner profile. */
  profileName: Scalars['String'];
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: InputMaybe<Scalars['Int']>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: InputMaybe<Scalars['Int']>;
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastScannerProfileCreate */
export type DastScannerProfileCreatePayload = {
  __typename?: 'DastScannerProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']>;
};

/** Autogenerated input type of DastScannerProfileDelete */
export type DastScannerProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the scanner profile to be deleted. */
  id: Scalars['DastScannerProfileID'];
};

/** Autogenerated return type of DastScannerProfileDelete */
export type DastScannerProfileDeletePayload = {
  __typename?: 'DastScannerProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastScannerProfileEdge = {
  __typename?: 'DastScannerProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastScannerProfile>;
};

/** Autogenerated input type of DastScannerProfileUpdate */
export type DastScannerProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the scanner profile to be updated. */
  id: Scalars['DastScannerProfileID'];
  /** Name of the scanner profile. */
  profileName: Scalars['String'];
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout: Scalars['Int'];
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout: Scalars['Int'];
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastScannerProfileUpdate */
export type DastScannerProfileUpdatePayload = {
  __typename?: 'DastScannerProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']>;
};

export enum DastScanTypeEnum {
  /** Passive DAST scan. This scan will not make active attacks against the target site. */
  Passive = 'PASSIVE',
  /** Active DAST scan. This scan will make active attacks against the target site. */
  Active = 'ACTIVE'
}

/** Represents a DAST Site Profile */
export type DastSiteProfile = {
  __typename?: 'DastSiteProfile';
  /** Target authentication details. */
  auth?: Maybe<DastSiteProfileAuth>;
  /** Relative web path to the edit page of a site profile. */
  editPath?: Maybe<Scalars['String']>;
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: Maybe<Array<Scalars['String']>>;
  /** ID of the site profile. */
  id: Scalars['DastSiteProfileID'];
  /** Normalized URL of the target to be scanned. */
  normalizedTargetUrl?: Maybe<Scalars['String']>;
  /** Name of the site profile. */
  profileName?: Maybe<Scalars['String']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']>>;
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: Maybe<Scalars['String']>;
  /** Scan File Path used as input for the scanner. Will always return `null` if `dast_api_scanner` feature flag is disabled. */
  scanFilePath?: Maybe<Scalars['String']>;
  /** Scan method used by the scanner. Always returns `null` if `dast_api_scanner` feature flag is disabled. */
  scanMethod?: Maybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: Maybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: Maybe<Scalars['String']>;
  /** Permissions for the current user on the resource */
  userPermissions: DastSiteProfilePermissions;
  /** Site profile validation start time. */
  validationStartedAt?: Maybe<Scalars['Time']>;
  /** Current validation status of the site profile. */
  validationStatus?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** Input type for DastSiteProfile authentication */
export type DastSiteProfileAuth = {
  __typename?: 'DastSiteProfileAuth';
  /** Indicates whether authentication is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Redacted password to authenticate with on the target website. */
  password?: Maybe<Scalars['String']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: Maybe<Scalars['String']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: Maybe<Scalars['String']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: Maybe<Scalars['String']>;
  /** Username to authenticate with on the target website. */
  username?: Maybe<Scalars['String']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: Maybe<Scalars['String']>;
};

/** Input type for DastSiteProfile authentication */
export type DastSiteProfileAuthInput = {
  /** Indicates whether authentication is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: InputMaybe<Scalars['String']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: InputMaybe<Scalars['String']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: InputMaybe<Scalars['String']>;
  /** Username to authenticate with on the target. */
  username?: InputMaybe<Scalars['String']>;
  /** Password to authenticate with on the target. */
  password?: InputMaybe<Scalars['String']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: InputMaybe<Scalars['String']>;
};

/** The connection type for DastSiteProfile. */
export type DastSiteProfileConnection = {
  __typename?: 'DastSiteProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteProfileCreate */
export type DastSiteProfileCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the site profile. */
  profileName: Scalars['String'];
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** Scan method by the scanner. Is not saved or updated if `dast_api_scanner` feature flag is disabled. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /**
   * File Path or URL used as input for the scan method. Will not be saved or
   * updated if `dast_api_scanner` feature flag is disabled.
   */
  scanFilePath?: InputMaybe<Scalars['String']>;
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']>;
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
  /** URLs to skip during an authenticated scan. Defaults to `[]`. */
  excludedUrls?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of DastSiteProfileCreate */
export type DastSiteProfileCreatePayload = {
  __typename?: 'DastSiteProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Site Profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']>;
};

/** Autogenerated input type of DastSiteProfileDelete */
export type DastSiteProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the site profile to be deleted. */
  id: Scalars['DastSiteProfileID'];
};

/** Autogenerated return type of DastSiteProfileDelete */
export type DastSiteProfileDeletePayload = {
  __typename?: 'DastSiteProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastSiteProfileEdge = {
  __typename?: 'DastSiteProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteProfile>;
};

/** Check permissions for the current user on site profile */
export type DastSiteProfilePermissions = {
  __typename?: 'DastSiteProfilePermissions';
  /** Indicates the user can perform `create_on_demand_dast_scan` on this resource */
  createOnDemandDastScan: Scalars['Boolean'];
};

/** Autogenerated input type of DastSiteProfileUpdate */
export type DastSiteProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the site profile. */
  profileName: Scalars['String'];
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** Scan method by the scanner. Is not saved or updated if `dast_api_scanner` feature flag is disabled. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /**
   * File Path or URL used as input for the scan method. Will not be saved or
   * updated if `dast_api_scanner` feature flag is disabled.
   */
  scanFilePath?: InputMaybe<Scalars['String']>;
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']>;
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** ID of the site profile to be updated. */
  id: Scalars['DastSiteProfileID'];
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of DastSiteProfileUpdate */
export type DastSiteProfileUpdatePayload = {
  __typename?: 'DastSiteProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Site profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']>;
};

export enum DastSiteProfileValidationStatusEnum {
  /** No site validation exists. */
  None = 'NONE',
  /** Site validation process has not started. */
  PendingValidation = 'PENDING_VALIDATION',
  /** Site validation process is in progress. */
  InprogressValidation = 'INPROGRESS_VALIDATION',
  /** Site validation process finished successfully. */
  PassedValidation = 'PASSED_VALIDATION',
  /** Site validation process finished but failed. */
  FailedValidation = 'FAILED_VALIDATION'
}

/** Autogenerated input type of DastSiteTokenCreate */
export type DastSiteTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site token belongs to. */
  fullPath: Scalars['ID'];
  /** URL of the target to be validated. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DastSiteTokenCreate */
export type DastSiteTokenCreatePayload = {
  __typename?: 'DastSiteTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** ID of the site token. */
  id?: Maybe<Scalars['DastSiteTokenID']>;
  /** Current validation status of the target. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
  /** Token string. */
  token?: Maybe<Scalars['String']>;
};

/** Represents a DAST Site Validation */
export type DastSiteValidation = {
  __typename?: 'DastSiteValidation';
  /** Global ID of the site validation. */
  id: Scalars['DastSiteValidationID'];
  /** Normalized URL of the target to be validated. */
  normalizedTargetUrl?: Maybe<Scalars['String']>;
  /** Status of the site validation. */
  status: DastSiteProfileValidationStatusEnum;
  /** Timestamp of when the validation started. */
  validationStartedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DastSiteValidation. */
export type DastSiteValidationConnection = {
  __typename?: 'DastSiteValidationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteValidationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteValidation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteValidationCreate */
export type DastSiteValidationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
  /** ID of the site token. */
  dastSiteTokenId: Scalars['DastSiteTokenID'];
  /** Path to be requested during validation. */
  validationPath: Scalars['String'];
  /** Validation strategy to be used. */
  strategy?: InputMaybe<DastSiteValidationStrategyEnum>;
};

/** Autogenerated return type of DastSiteValidationCreate */
export type DastSiteValidationCreatePayload = {
  __typename?: 'DastSiteValidationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** ID of the site validation. */
  id?: Maybe<Scalars['DastSiteValidationID']>;
  /** Current validation status. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** An edge in a connection. */
export type DastSiteValidationEdge = {
  __typename?: 'DastSiteValidationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteValidation>;
};

/** Autogenerated input type of DastSiteValidationRevoke */
export type DastSiteValidationRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site validation belongs to. */
  fullPath: Scalars['ID'];
  /** Normalized URL of the target to be revoked. */
  normalizedTargetUrl: Scalars['String'];
};

/** Autogenerated return type of DastSiteValidationRevoke */
export type DastSiteValidationRevokePayload = {
  __typename?: 'DastSiteValidationRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export enum DastSiteValidationStatusEnum {
  /** Site validation process has not started. */
  PendingValidation = 'PENDING_VALIDATION',
  /** Site validation process is in progress. */
  InprogressValidation = 'INPROGRESS_VALIDATION',
  /** Site validation process finished successfully. */
  PassedValidation = 'PASSED_VALIDATION',
  /** Site validation process finished but failed. */
  FailedValidation = 'FAILED_VALIDATION'
}

export enum DastSiteValidationStrategyEnum {
  /** Text file validation. */
  TextFile = 'TEXT_FILE',
  /** Header validation. */
  Header = 'HEADER',
  /** Meta tag validation. */
  MetaTag = 'META_TAG'
}

export enum DastTargetTypeEnum {
  /** Website target. */
  Website = 'WEBSITE',
  /** API target. */
  Api = 'API'
}

/** Color of the data visualization palette */
export enum DataVisualizationColorEnum {
  /** Blue color */
  Blue = 'BLUE',
  /** Orange color */
  Orange = 'ORANGE',
  /** Aqua color */
  Aqua = 'AQUA',
  /** Green color */
  Green = 'GREEN',
  /** Magenta color */
  Magenta = 'MAGENTA'
}

/** Weight of the data visualization palette */
export enum DataVisualizationWeightEnum {
  /** 50 weight */
  Weight_50 = 'WEIGHT_50',
  /** 100 weight */
  Weight_100 = 'WEIGHT_100',
  /** 200 weight */
  Weight_200 = 'WEIGHT_200',
  /** 300 weight */
  Weight_300 = 'WEIGHT_300',
  /** 400 weight */
  Weight_400 = 'WEIGHT_400',
  /** 500 weight */
  Weight_500 = 'WEIGHT_500',
  /** 600 weight */
  Weight_600 = 'WEIGHT_600',
  /** 700 weight */
  Weight_700 = 'WEIGHT_700',
  /** 800 weight */
  Weight_800 = 'WEIGHT_800',
  /** 900 weight */
  Weight_900 = 'WEIGHT_900',
  /** 950 weight */
  Weight_950 = 'WEIGHT_950'
}

/** Autogenerated input type of DeleteAnnotation */
export type DeleteAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the annotation to delete. */
  id: Scalars['MetricsDashboardAnnotationID'];
};

/** Autogenerated return type of DeleteAnnotation */
export type DeleteAnnotationPayload = {
  __typename?: 'DeleteAnnotationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The response from the AdminSidekiqQueuesDeleteJobs mutation */
export type DeleteJobsResponse = {
  __typename?: 'DeleteJobsResponse';
  /** Whether or not the entire queue was processed in time; if not, retrying the same request is safe. */
  completed?: Maybe<Scalars['Boolean']>;
  /** Number of matching jobs deleted. */
  deletedJobs?: Maybe<Scalars['Int']>;
  /** Queue size after processing. */
  queueSize?: Maybe<Scalars['Int']>;
};

/** Represents metadata associated with a dependency link */
export type DependencyLinkMetadata = NugetDependencyLinkMetadata;

/** Dependency proxy blob */
export type DependencyProxyBlob = {
  __typename?: 'DependencyProxyBlob';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Name of the blob. */
  fileName: Scalars['String'];
  /** Size of the blob file. */
  size: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** The connection type for DependencyProxyBlob. */
export type DependencyProxyBlobConnection = {
  __typename?: 'DependencyProxyBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyBlobEdge = {
  __typename?: 'DependencyProxyBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlob>;
};

/** Represents the Geo replication and verification state of a dependency_proxy_blob */
export type DependencyProxyBlobRegistry = {
  __typename?: 'DependencyProxyBlobRegistry';
  /** Timestamp when the DependencyProxyBlobRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Dependency Proxy Blob. */
  dependencyProxyBlobId: Scalars['ID'];
  /** ID of the DependencyProxyBlobRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the DependencyProxyBlobRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the DependencyProxyBlobRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the DependencyProxyBlobRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the DependencyProxyBlobRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the DependencyProxyBlobRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the DependencyProxyBlobRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the DependencyProxyBlobRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DependencyProxyBlobRegistry. */
export type DependencyProxyBlobRegistryConnection = {
  __typename?: 'DependencyProxyBlobRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlobRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyBlobRegistryEdge = {
  __typename?: 'DependencyProxyBlobRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlobRegistry>;
};

/** Group-level Dependency Proxy TTL policy settings */
export type DependencyProxyImageTtlGroupPolicy = {
  __typename?: 'DependencyProxyImageTtlGroupPolicy';
  /** Timestamp of creation. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled: Scalars['Boolean'];
  /** Number of days to retain a cached image file. */
  ttl?: Maybe<Scalars['Int']>;
  /** Timestamp of the most recent update. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** Dependency proxy manifest */
export type DependencyProxyManifest = {
  __typename?: 'DependencyProxyManifest';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Digest of the manifest. */
  digest: Scalars['String'];
  /** Name of the manifest. */
  fileName: Scalars['String'];
  /** ID of the manifest. */
  id: Scalars['DependencyProxyManifestID'];
  /** Name of the image. */
  imageName: Scalars['String'];
  /** Size of the manifest file. */
  size: Scalars['String'];
  /** Status of the manifest (default, pending_destruction, processing, error) */
  status: DependencyProxyManifestStatus;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** The connection type for DependencyProxyManifest. */
export type DependencyProxyManifestConnection = {
  __typename?: 'DependencyProxyManifestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyManifestEdge = {
  __typename?: 'DependencyProxyManifestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyManifest>;
};

export enum DependencyProxyManifestStatus {
  /** Dependency proxy manifest has a status of default. */
  Default = 'DEFAULT',
  /** Dependency proxy manifest has a status of pending_destruction. */
  PendingDestruction = 'PENDING_DESTRUCTION',
  /** Dependency proxy manifest has a status of processing. */
  Processing = 'PROCESSING',
  /** Dependency proxy manifest has a status of error. */
  Error = 'ERROR'
}

/** Group-level Dependency Proxy settings */
export type DependencyProxySetting = {
  __typename?: 'DependencyProxySetting';
  /** Indicates whether the dependency proxy is enabled for the group. */
  enabled: Scalars['Boolean'];
};

/** The deployment of an environment */
export type Deployment = {
  __typename?: 'Deployment';
  /** Commit details of the deployment. */
  commit?: Maybe<Commit>;
  /** When the deployment record was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** When the deployment finished. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** Global ID of the deployment. */
  id?: Maybe<Scalars['ID']>;
  /** Project-level internal ID of the deployment. */
  iid?: Maybe<Scalars['ID']>;
  /** Pipeline job of the deployment. */
  job?: Maybe<CiJob>;
  /** Git-Ref that the deployment ran on. */
  ref?: Maybe<Scalars['String']>;
  /** Git-SHA that the deployment ran on. */
  sha?: Maybe<Scalars['String']>;
  /** Status of the deployment. */
  status?: Maybe<DeploymentStatus>;
  /** True or false if the deployment ran on a Git-tag. */
  tag?: Maybe<Scalars['Boolean']>;
  /** User who executed the deployment. */
  triggerer?: Maybe<UserCore>;
  /** When the deployment record was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** Approval of the deployment. */
export type DeploymentApproval = {
  __typename?: 'DeploymentApproval';
  /** Additional comment. */
  comment?: Maybe<Scalars['String']>;
  /** When the user approved/rejected first time. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Whether the deployment was approved/rejected. */
  status?: Maybe<DeploymentsApprovalStatus>;
  /** When the user updated the approval. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User who approved or rejected the deployment. */
  user?: Maybe<UserCore>;
};

/** Approval summary of the deployment. */
export type DeploymentApprovalSummary = {
  __typename?: 'DeploymentApprovalSummary';
  /** Approval Rules for the deployment. */
  rules?: Maybe<Array<ProtectedEnvironmentApprovalRuleForSummary>>;
  /** Status of the approvals. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** Total pending approval count. */
  totalPendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Total number of required approvals. */
  totalRequiredApprovals?: Maybe<Scalars['Int']>;
};

/** Status of the deployment approval summary. */
export enum DeploymentApprovalSummaryStatus {
  /** Summarized deployment approval status that is approved. */
  Approved = 'APPROVED',
  /** Summarized deployment approval status that is rejected. */
  Rejected = 'REJECTED',
  /** Summarized deployment approval status that is pending approval. */
  PendingApproval = 'PENDING_APPROVAL'
}

/** The connection type for Deployment. */
export type DeploymentConnection = {
  __typename?: 'DeploymentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** The details of the deployment */
export type DeploymentDetails = {
  __typename?: 'DeploymentDetails';
  /** Approval summary of the deployment. */
  approvalSummary?: Maybe<DeploymentApprovalSummary>;
  /** Commit details of the deployment. */
  commit?: Maybe<Commit>;
  /** When the deployment record was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** When the deployment finished. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** Global ID of the deployment. */
  id?: Maybe<Scalars['ID']>;
  /** Project-level internal ID of the deployment. */
  iid?: Maybe<Scalars['ID']>;
  /** Pipeline job of the deployment. */
  job?: Maybe<CiJob>;
  /** Git-Ref that the deployment ran on. */
  ref?: Maybe<Scalars['String']>;
  /** Git-SHA that the deployment ran on. */
  sha?: Maybe<Scalars['String']>;
  /** Status of the deployment. */
  status?: Maybe<DeploymentStatus>;
  /** True or false if the deployment ran on a Git-tag. */
  tag?: Maybe<Scalars['Boolean']>;
  /** Git tags that contain this deployment. */
  tags?: Maybe<Array<DeploymentTag>>;
  /** User who executed the deployment. */
  triggerer?: Maybe<UserCore>;
  /** When the deployment record was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** An edge in a connection. */
export type DeploymentEdge = {
  __typename?: 'DeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Deployment>;
};

/** Status of the deployment approval. */
export enum DeploymentsApprovalStatus {
  /** A deployment approval that is approved. */
  Approved = 'APPROVED',
  /** A deployment approval that is rejected. */
  Rejected = 'REJECTED'
}

/** Values for ordering deployments by a specific field */
export type DeploymentsOrderByInput = {
  /** Order by Created time. */
  createdAt?: InputMaybe<SortDirectionEnum>;
  /** Order by Finished time. */
  finishedAt?: InputMaybe<SortDirectionEnum>;
};

/** All deployment statuses. */
export enum DeploymentStatus {
  /** A deployment that is created. */
  Created = 'CREATED',
  /** A deployment that is running. */
  Running = 'RUNNING',
  /** A deployment that is success. */
  Success = 'SUCCESS',
  /** A deployment that is failed. */
  Failed = 'FAILED',
  /** A deployment that is canceled. */
  Canceled = 'CANCELED',
  /** A deployment that is skipped. */
  Skipped = 'SKIPPED',
  /** A deployment that is blocked. */
  Blocked = 'BLOCKED'
}

/** Tags for a given deployment */
export type DeploymentTag = {
  __typename?: 'DeploymentTag';
  /** Name of this git tag. */
  name?: Maybe<Scalars['String']>;
  /** Path for this tag. */
  path?: Maybe<Scalars['String']>;
};

/** All environment deployment tiers. */
export enum DeploymentTier {
  /** Production. */
  Production = 'PRODUCTION',
  /** Staging. */
  Staging = 'STAGING',
  /** Testing. */
  Testing = 'TESTING',
  /** Development. */
  Development = 'DEVELOPMENT',
  /** Other. */
  Other = 'OTHER'
}

/** A single design */
export type Design = CurrentUserTodos & DesignFields & NoteableInterface & Todoable & {
  __typename?: 'Design';
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
  /** All versions related to this design ordered newest first. */
  versions: DesignVersionConnection;
  /** URL of the design. */
  webUrl: Scalars['String'];
};


/** A single design */
export type DesignCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** A single design */
export type DesignDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A single design */
export type DesignNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A single design */
export type DesignVersionsArgs = {
  earlierOrEqualToSha?: InputMaybe<Scalars['String']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A design pinned to a specific version. The image field reflects the design as of the associated version */
export type DesignAtVersion = DesignFields & {
  __typename?: 'DesignAtVersion';
  /** Underlying design. */
  design: Design;
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
  /** Version this design-at-versions is pinned to. */
  version: DesignVersion;
};

/** The connection type for DesignAtVersion. */
export type DesignAtVersionConnection = {
  __typename?: 'DesignAtVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignAtVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignAtVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignAtVersionEdge = {
  __typename?: 'DesignAtVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignAtVersion>;
};

/** A collection of designs */
export type DesignCollection = {
  __typename?: 'DesignCollection';
  /** Copy state of the design collection. */
  copyState?: Maybe<DesignCollectionCopyState>;
  /** Find a specific design. */
  design?: Maybe<Design>;
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** All designs for the design collection. */
  designs: DesignConnection;
  /** Issue associated with the design collection. */
  issue: Issue;
  /** Project associated with the design collection. */
  project: Project;
  /** A specific version. */
  version?: Maybe<DesignVersion>;
  /** All versions related to all designs, ordered newest first. */
  versions: DesignVersionConnection;
};


/** A collection of designs */
export type DesignCollectionDesignArgs = {
  id?: InputMaybe<Scalars['DesignManagementDesignID']>;
  filename?: InputMaybe<Scalars['String']>;
};


/** A collection of designs */
export type DesignCollectionDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID'];
};


/** A collection of designs */
export type DesignCollectionDesignsArgs = {
  atVersion?: InputMaybe<Scalars['DesignManagementVersionID']>;
  filenames?: InputMaybe<Array<Scalars['String']>>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A collection of designs */
export type DesignCollectionVersionArgs = {
  id?: InputMaybe<Scalars['DesignManagementVersionID']>;
  sha?: InputMaybe<Scalars['String']>;
};


/** A collection of designs */
export type DesignCollectionVersionsArgs = {
  earlierOrEqualToSha?: InputMaybe<Scalars['String']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Copy state of a DesignCollection */
export enum DesignCollectionCopyState {
  /** The DesignCollection has no copy in progress */
  Ready = 'READY',
  /** The DesignCollection is being copied */
  InProgress = 'IN_PROGRESS',
  /** The DesignCollection encountered an error during a copy */
  Error = 'ERROR'
}

/** The connection type for Design. */
export type DesignConnection = {
  __typename?: 'DesignConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Design>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignEdge = {
  __typename?: 'DesignEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Design>;
};

export type DesignFields = {
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
};

export type DesignManagement = {
  __typename?: 'DesignManagement';
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** Find a version. */
  version?: Maybe<DesignVersion>;
};


export type DesignManagementDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID'];
};


export type DesignManagementVersionArgs = {
  id: Scalars['DesignManagementVersionID'];
};

/** Autogenerated input type of DesignManagementDelete */
export type DesignManagementDeleteInput = {
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID'];
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Filenames of the designs to delete. */
  filenames: Array<Scalars['String']>;
};

/** Autogenerated return type of DesignManagementDelete */
export type DesignManagementDeletePayload = {
  __typename?: 'DesignManagementDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** New version in which the designs are deleted. */
  version?: Maybe<DesignVersion>;
};

/** Autogenerated input type of DesignManagementMove */
export type DesignManagementMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the design to move. */
  id: Scalars['DesignManagementDesignID'];
  /** ID of the immediately preceding design. */
  previous?: InputMaybe<Scalars['DesignManagementDesignID']>;
  /** ID of the immediately following design. */
  next?: InputMaybe<Scalars['DesignManagementDesignID']>;
};

/** Autogenerated return type of DesignManagementMove */
export type DesignManagementMovePayload = {
  __typename?: 'DesignManagementMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Current state of the collection. */
  designCollection?: Maybe<DesignCollection>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DesignManagementUpload */
export type DesignManagementUploadInput = {
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID'];
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Files to upload. */
  files: Array<Scalars['Upload']>;
};

/** Autogenerated return type of DesignManagementUpload */
export type DesignManagementUploadPayload = {
  __typename?: 'DesignManagementUploadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Designs that were uploaded by the mutation. */
  designs: Array<Design>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Any designs that were skipped from the upload due to there being no change to their content since their last version */
  skippedDesigns: Array<Design>;
};

/** A specific version in which designs were added, modified or deleted */
export type DesignVersion = {
  __typename?: 'DesignVersion';
  /** Author of the version. */
  author: UserCore;
  /** Timestamp of when the version was created. */
  createdAt: Scalars['Time'];
  /** A particular design as of this version, provided it is visible at this version. */
  designAtVersion: DesignAtVersion;
  /** All designs that were changed in the version. */
  designs: DesignConnection;
  /** All designs that are visible at this version, as of this version. */
  designsAtVersion: DesignAtVersionConnection;
  /** ID of the design version. */
  id: Scalars['ID'];
  /** SHA of the design version. */
  sha: Scalars['ID'];
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignAtVersionArgs = {
  designId?: InputMaybe<Scalars['DesignManagementDesignID']>;
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['DesignManagementDesignAtVersionID']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsAtVersionArgs = {
  filenames?: InputMaybe<Array<Scalars['String']>>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DesignVersion. */
export type DesignVersionConnection = {
  __typename?: 'DesignVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignVersionEdge = {
  __typename?: 'DesignVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignVersion>;
};

/** Mutation event of a design within a version */
export enum DesignVersionEvent {
  /** No change. */
  None = 'NONE',
  /** A creation event */
  Creation = 'CREATION',
  /** A modification event */
  Modification = 'MODIFICATION',
  /** A deletion event */
  Deletion = 'DELETION'
}

/** Autogenerated input type of DestroyBoard */
export type DestroyBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardID'];
};

/** Autogenerated input type of DestroyBoardList */
export type DestroyBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the list to destroy. Only label lists are accepted. */
  listId: Scalars['ListID'];
};

/** Autogenerated return type of DestroyBoardList */
export type DestroyBoardListPayload = {
  __typename?: 'DestroyBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** List after mutation. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of DestroyBoard */
export type DestroyBoardPayload = {
  __typename?: 'DestroyBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyComplianceFramework */
export type DestroyComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the compliance framework to destroy. */
  id: Scalars['ComplianceManagementFrameworkID'];
};

/** Autogenerated return type of DestroyComplianceFramework */
export type DestroyComplianceFrameworkPayload = {
  __typename?: 'DestroyComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyContainerRepository */
export type DestroyContainerRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID'];
};

/** Autogenerated return type of DestroyContainerRepository */
export type DestroyContainerRepositoryPayload = {
  __typename?: 'DestroyContainerRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Container repository policy after scheduling the deletion. */
  containerRepository: ContainerRepository;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyContainerRepositoryTags */
export type DestroyContainerRepositoryTagsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID'];
  /** Container repository tag(s) to delete. Total number can't be greater than 20 */
  tagNames: Array<Scalars['String']>;
};

/** Autogenerated return type of DestroyContainerRepositoryTags */
export type DestroyContainerRepositoryTagsPayload = {
  __typename?: 'DestroyContainerRepositoryTagsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Deleted container repository tags. */
  deletedTagNames: Array<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyCustomEmoji */
export type DestroyCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the custom emoji to destroy. */
  id: Scalars['CustomEmojiID'];
};

/** Autogenerated return type of DestroyCustomEmoji */
export type DestroyCustomEmojiPayload = {
  __typename?: 'DestroyCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Deleted custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyEpicBoard */
export type DestroyEpicBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardsEpicBoardID'];
};

/** Autogenerated return type of DestroyEpicBoard */
export type DestroyEpicBoardPayload = {
  __typename?: 'DestroyEpicBoardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic board after mutation. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyNote */
export type DestroyNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the note to destroy. */
  id: Scalars['NoteID'];
};

/** Autogenerated return type of DestroyNote */
export type DestroyNotePayload = {
  __typename?: 'DestroyNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of DestroyPackageFile */
export type DestroyPackageFileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Package file. */
  id: Scalars['PackagesPackageFileID'];
};

/** Autogenerated return type of DestroyPackageFile */
export type DestroyPackageFilePayload = {
  __typename?: 'DestroyPackageFilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackageFiles */
export type DestroyPackageFilesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID'];
  /** IDs of the Package file. */
  ids: Array<Scalars['PackagesPackageFileID']>;
};

/** Autogenerated return type of DestroyPackageFiles */
export type DestroyPackageFilesPayload = {
  __typename?: 'DestroyPackageFilesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackage */
export type DestroyPackageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Package. */
  id: Scalars['PackagesPackageID'];
};

/** Autogenerated return type of DestroyPackage */
export type DestroyPackagePayload = {
  __typename?: 'DestroyPackagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackages */
export type DestroyPackagesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global IDs of the Packages. Max 20 */
  ids: Array<Scalars['PackagesPackageID']>;
};

/** Autogenerated return type of DestroyPackages */
export type DestroyPackagesPayload = {
  __typename?: 'DestroyPackagesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroySnippet */
export type DestroySnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to destroy. */
  id: Scalars['SnippetID'];
};

/** Autogenerated return type of DestroySnippet */
export type DestroySnippetPayload = {
  __typename?: 'DestroySnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Detailed representation of whether a GitLab merge request can be merged. */
export enum DetailedMergeStatus {
  /** Merge status has not been checked. */
  Unchecked = 'UNCHECKED',
  /** Currently checking for mergeability. */
  Checking = 'CHECKING',
  /** Branch can be merged. */
  Mergeable = 'MERGEABLE',
  /** Can not merge the source into the target branch, potential conflict. */
  BrokenStatus = 'BROKEN_STATUS',
  /** Pipeline must succeed before merging. */
  CiMustPass = 'CI_MUST_PASS',
  /** Pipeline is still running. */
  CiStillRunning = 'CI_STILL_RUNNING',
  /** Discussions must be resolved before merging. */
  DiscussionsNotResolved = 'DISCUSSIONS_NOT_RESOLVED',
  /** Merge request must not be draft before merging. */
  DraftStatus = 'DRAFT_STATUS',
  /** Merge request must be open before merging. */
  NotOpen = 'NOT_OPEN',
  /** Merge request must be approved before merging. */
  NotApproved = 'NOT_APPROVED',
  /** Merge request is blocked by another merge request. */
  BlockedStatus = 'BLOCKED_STATUS',
  /** There are denied policies for the merge request. */
  PoliciesDenied = 'POLICIES_DENIED',
  /** Status checks must pass. */
  ExternalStatusChecks = 'EXTERNAL_STATUS_CHECKS'
}

export type DetailedStatus = {
  __typename?: 'DetailedStatus';
  /** Action information for the status. This includes method, button title, icon, path, and title. */
  action?: Maybe<StatusAction>;
  /** Path of the details for the status. */
  detailsPath?: Maybe<Scalars['String']>;
  /** Favicon of the status. */
  favicon?: Maybe<Scalars['String']>;
  /** Group of the status. */
  group?: Maybe<Scalars['String']>;
  /** Indicates if the status has further details. */
  hasDetails?: Maybe<Scalars['Boolean']>;
  /** Icon of the status. */
  icon?: Maybe<Scalars['String']>;
  /** ID for a detailed status. */
  id: Scalars['String'];
  /** Label of the status. */
  label?: Maybe<Scalars['String']>;
  /** Text of the status. */
  text?: Maybe<Scalars['String']>;
  /** Tooltip associated with the status. */
  tooltip?: Maybe<Scalars['String']>;
};

/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespace = {
  __typename?: 'DevopsAdoptionEnabledNamespace';
  /** Namespace where data should be displayed. */
  displayNamespace?: Maybe<Namespace>;
  /** ID of the enabled namespace. */
  id: Scalars['ID'];
  /** Metrics snapshot for previous month for the enabled namespace. */
  latestSnapshot?: Maybe<DevopsAdoptionSnapshot>;
  /** Namespace which should be calculated. */
  namespace?: Maybe<Namespace>;
  /** Data snapshots of the namespace. */
  snapshots?: Maybe<DevopsAdoptionSnapshotConnection>;
};


/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespaceSnapshotsArgs = {
  endTimeBefore?: InputMaybe<Scalars['Time']>;
  endTimeAfter?: InputMaybe<Scalars['Time']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DevopsAdoptionEnabledNamespace. */
export type DevopsAdoptionEnabledNamespaceConnection = {
  __typename?: 'DevopsAdoptionEnabledNamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionEnabledNamespaceEdge = {
  __typename?: 'DevopsAdoptionEnabledNamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionEnabledNamespace>;
};

/** Snapshot */
export type DevopsAdoptionSnapshot = {
  __typename?: 'DevopsAdoptionSnapshot';
  /** Total number of projects with existing CODEOWNERS file. */
  codeOwnersUsedCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled coverage fuzzing. */
  coverageFuzzingEnabledCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled DAST. */
  dastEnabledCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled dependency scanning. */
  dependencyScanningEnabledCount?: Maybe<Scalars['Int']>;
  /** At least one deployment succeeded. */
  deploySucceeded: Scalars['Boolean'];
  /** End time for the snapshot where the data points were collected. */
  endTime: Scalars['Time'];
  /** At least one issue was opened. */
  issueOpened: Scalars['Boolean'];
  /** At least one merge request was approved. */
  mergeRequestApproved: Scalars['Boolean'];
  /** At least one merge request was opened. */
  mergeRequestOpened: Scalars['Boolean'];
  /** At least one pipeline succeeded. */
  pipelineSucceeded: Scalars['Boolean'];
  /** Time the snapshot was recorded. */
  recordedAt: Scalars['Time'];
  /** At least one runner was used. */
  runnerConfigured: Scalars['Boolean'];
  /** Total number of projects with enabled SAST. */
  sastEnabledCount?: Maybe<Scalars['Int']>;
  /** Start time for the snapshot where the data points were collected. */
  startTime: Scalars['Time'];
  /** Total number of projects. */
  totalProjectsCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with vulnerability management used at least once. */
  vulnerabilityManagementUsedCount?: Maybe<Scalars['Int']>;
};

/** The connection type for DevopsAdoptionSnapshot. */
export type DevopsAdoptionSnapshotConnection = {
  __typename?: 'DevopsAdoptionSnapshotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionSnapshotEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionSnapshot>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionSnapshotEdge = {
  __typename?: 'DevopsAdoptionSnapshotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionSnapshot>;
};

export type DiffImagePositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
  /**
   * The paths of the file that was changed. Both of the properties of this input
   * are optional, but at least one of them is required
   */
  paths: DiffPathsInput;
  /** Total height of the image. */
  height: Scalars['Int'];
  /** Total width of the image. */
  width: Scalars['Int'];
  /** X position of the note. */
  x: Scalars['Int'];
  /** Y position of the note. */
  y: Scalars['Int'];
};

export type DiffPathsInput = {
  /** Path of the file on the HEAD SHA. */
  newPath?: InputMaybe<Scalars['String']>;
  /** Path of the file on the start SHA. */
  oldPath?: InputMaybe<Scalars['String']>;
};

export type DiffPosition = {
  __typename?: 'DiffPosition';
  /** Information about the branch, HEAD, and base at the time of commenting. */
  diffRefs: DiffRefs;
  /** Path of the file that was changed. */
  filePath: Scalars['String'];
  /** Total height of the image. */
  height?: Maybe<Scalars['Int']>;
  /** Line on HEAD SHA that was changed. */
  newLine?: Maybe<Scalars['Int']>;
  /** Path of the file on the HEAD SHA. */
  newPath?: Maybe<Scalars['String']>;
  /** Line on start SHA that was changed. */
  oldLine?: Maybe<Scalars['Int']>;
  /** Path of the file on the start SHA. */
  oldPath?: Maybe<Scalars['String']>;
  /** Type of file the position refers to. */
  positionType: DiffPositionType;
  /** Total width of the image. */
  width?: Maybe<Scalars['Int']>;
  /** X position of the note. */
  x?: Maybe<Scalars['Int']>;
  /** Y position of the note. */
  y?: Maybe<Scalars['Int']>;
};

export type DiffPositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
  /**
   * The paths of the file that was changed. Both of the properties of this input
   * are optional, but at least one of them is required
   */
  paths: DiffPathsInput;
  /**
   * Line on HEAD SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff)
   * for more information on how to use this field.
   */
  newLine?: InputMaybe<Scalars['Int']>;
  /**
   * Line on start SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff)
   * for more information on how to use this field.
   */
  oldLine?: InputMaybe<Scalars['Int']>;
};

/** Type of file the position refers to */
export enum DiffPositionType {
  /** Text file. */
  Text = 'text',
  /** An image. */
  Image = 'image'
}

export type DiffRefs = {
  __typename?: 'DiffRefs';
  /** Merge base of the branch the comment was made on. */
  baseSha?: Maybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
};

/** Changes to a single file */
export type DiffStats = {
  __typename?: 'DiffStats';
  /** Number of lines added to this file. */
  additions: Scalars['Int'];
  /** Number of lines deleted from this file. */
  deletions: Scalars['Int'];
  /** File path, relative to repository root. */
  path: Scalars['String'];
};

/** Aggregated summary of changes */
export type DiffStatsSummary = {
  __typename?: 'DiffStatsSummary';
  /** Number of lines added. */
  additions: Scalars['Int'];
  /** Number of lines changed. */
  changes: Scalars['Int'];
  /** Number of lines deleted. */
  deletions: Scalars['Int'];
  /** Number of files changed. */
  fileCount: Scalars['Int'];
};

/** Autogenerated input type of DisableDevopsAdoptionNamespace */
export type DisableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** One or many IDs of the enabled namespaces to disable. */
  id: Array<Scalars['AnalyticsDevopsAdoptionEnabledNamespaceID']>;
};

/** Autogenerated return type of DisableDevopsAdoptionNamespace */
export type DisableDevopsAdoptionNamespacePayload = {
  __typename?: 'DisableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type Discussion = ResolvableInterface & {
  __typename?: 'Discussion';
  /** Timestamp of the discussion's creation. */
  createdAt: Scalars['Time'];
  /** ID of this discussion. */
  id: Scalars['DiscussionID'];
  /** Object which the discussion belongs to. */
  noteable?: Maybe<NoteableType>;
  /** All notes in the discussion. */
  notes: NoteConnection;
  /** ID used to reply to this discussion. */
  replyId: Scalars['DiscussionID'];
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};


export type DiscussionNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Discussion. */
export type DiscussionConnection = {
  __typename?: 'DiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DiscussionEdge = {
  __typename?: 'DiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Discussion>;
};

/** Autogenerated input type of DiscussionToggleResolve */
export type DiscussionToggleResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the discussion. */
  id: Scalars['DiscussionID'];
  /** Will resolve the discussion when true, and unresolve the discussion when false. */
  resolve: Scalars['Boolean'];
};

/** Autogenerated return type of DiscussionToggleResolve */
export type DiscussionToggleResolvePayload = {
  __typename?: 'DiscussionToggleResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Discussion after mutation. */
  discussion?: Maybe<Discussion>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** All information related to DORA metrics. */
export type Dora = {
  __typename?: 'Dora';
  /** DORA metrics for the current group or project. */
  metrics?: Maybe<Array<DoraMetric>>;
};


/** All information related to DORA metrics. */
export type DoraMetricsArgs = {
  metric: DoraMetricType;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  interval?: InputMaybe<DoraMetricBucketingInterval>;
  environmentTier?: InputMaybe<DeploymentTier>;
  environmentTiers?: InputMaybe<Array<DeploymentTier>>;
};

export type DoraMetric = {
  __typename?: 'DoraMetric';
  /** Date of the data point. */
  date?: Maybe<Scalars['String']>;
  /** Value of the data point. */
  value?: Maybe<Scalars['Float']>;
};

/** All possible ways that DORA metrics can be aggregated. */
export enum DoraMetricBucketingInterval {
  /** All data points are combined into a single value. */
  All = 'ALL',
  /** Data points are combined into chunks by month. */
  Monthly = 'MONTHLY',
  /** Data points are combined into chunks by day. */
  Daily = 'DAILY'
}

/** All supported DORA metric types. */
export enum DoraMetricType {
  /** Deployment frequency. */
  DeploymentFrequency = 'DEPLOYMENT_FREQUENCY',
  /** Lead time for changes. */
  LeadTimeForChanges = 'LEAD_TIME_FOR_CHANGES',
  /** Time to restore service. */
  TimeToRestoreService = 'TIME_TO_RESTORE_SERVICE',
  /** Change failure rate. */
  ChangeFailureRate = 'CHANGE_FAILURE_RATE'
}

/** Autogenerated input type of EchoCreate */
export type EchoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Errors to return to the user. */
  errors?: InputMaybe<Array<Scalars['String']>>;
  /** Messages to return to the user. */
  messages?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of EchoCreate */
export type EchoCreatePayload = {
  __typename?: 'EchoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Messages returned to the user. */
  echoes?: Maybe<Array<Scalars['String']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of EnableDevopsAdoptionNamespace */
export type EnableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Namespace ID. */
  namespaceId: Scalars['NamespaceID'];
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
};

/** Autogenerated return type of EnableDevopsAdoptionNamespace */
export type EnableDevopsAdoptionNamespacePayload = {
  __typename?: 'EnableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Enabled namespace after mutation. */
  enabledNamespace?: Maybe<DevopsAdoptionEnabledNamespace>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type Entry = {
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
};

/** Type of a tree entry */
export enum EntryType {
  /** Directory tree type. */
  Tree = 'tree',
  /** File tree type. */
  Blob = 'blob',
  /** Commit tree type. */
  Commit = 'commit'
}

/** Describes where code is deployed for a project */
export type Environment = {
  __typename?: 'Environment';
  /** When the environment is going to be deleted automatically. */
  autoDeleteAt?: Maybe<Scalars['Time']>;
  /** When the environment is going to be stopped automatically. */
  autoStopAt?: Maybe<Scalars['Time']>;
  /** When the environment was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Deployments of the environment. This field can only be resolved for one environment in any single request. */
  deployments?: Maybe<DeploymentConnection>;
  /** Folder name of the environment. */
  environmentType?: Maybe<Scalars['String']>;
  /** External URL of the environment. */
  externalUrl?: Maybe<Scalars['String']>;
  /** ID of the environment. */
  id: Scalars['ID'];
  /** Last deployment of the environment. */
  lastDeployment?: Maybe<Deployment>;
  /** Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned. */
  latestOpenedMostSevereAlert?: Maybe<AlertManagementAlert>;
  /** Metrics dashboard schema for the environment. */
  metricsDashboard?: Maybe<MetricsDashboard>;
  /** Human-readable name of the environment. */
  name: Scalars['String'];
  /** Path to the environment. */
  path: Scalars['String'];
  /** Protected Environments for the environment. */
  protectedEnvironments?: Maybe<ProtectedEnvironmentConnection>;
  /** Slug of the environment. */
  slug?: Maybe<Scalars['String']>;
  /** State of the environment, for example: available/stopped. */
  state: Scalars['String'];
  /** Deployment tier of the environment. */
  tier?: Maybe<DeploymentTier>;
  /** When the environment was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};


/** Describes where code is deployed for a project */
export type EnvironmentDeploymentsArgs = {
  statuses?: InputMaybe<Array<DeploymentStatus>>;
  orderBy?: InputMaybe<DeploymentsOrderByInput>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes where code is deployed for a project */
export type EnvironmentLastDeploymentArgs = {
  status: DeploymentStatus;
};


/** Describes where code is deployed for a project */
export type EnvironmentMetricsDashboardArgs = {
  path: Scalars['String'];
};


/** Describes where code is deployed for a project */
export type EnvironmentProtectedEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Environment. */
export type EnvironmentConnection = {
  __typename?: 'EnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EnvironmentEdge = {
  __typename?: 'EnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Environment>;
};

/** Autogenerated input type of EnvironmentsCanaryIngressUpdate */
export type EnvironmentsCanaryIngressUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the environment to update. */
  id: Scalars['EnvironmentID'];
  /** Weight of the Canary Ingress. */
  weight: Scalars['Int'];
};

/** Autogenerated return type of EnvironmentsCanaryIngressUpdate */
export type EnvironmentsCanaryIngressUpdatePayload = {
  __typename?: 'EnvironmentsCanaryIngressUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an epic */
export type Epic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'Epic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of award emojis associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']>;
  /** Count of epics blocking this epic. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Epics blocking this epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that this epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  color?: Maybe<Scalars['String']>;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID'];
  /** Internal ID of the epic. */
  iid: Scalars['ID'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean'];
  /** Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  textColor?: Maybe<Scalars['String']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** Web path of the epic. */
  webPath: Scalars['String'];
  /** Web URL of the epic. */
  webUrl: Scalars['String'];
};


/** Represents an epic */
export type EpicAncestorsArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicChildrenArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic */
export type EpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of EpicAddIssue */
export type EpicAddIssueInput = {
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project the issue belongs to. */
  projectPath: Scalars['ID'];
  /** IID of the issue to be added. */
  issueIid: Scalars['String'];
};

/** Autogenerated return type of EpicAddIssue */
export type EpicAddIssuePayload = {
  __typename?: 'EpicAddIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Epic-issue relationship. */
  epicIssue?: Maybe<EpicIssue>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an epic board */
export type EpicBoard = {
  __typename?: 'EpicBoard';
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']>;
  /** Global ID of the epic board. */
  id: Scalars['BoardsEpicBoardID'];
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Epic board lists. */
  lists?: Maybe<EpicListConnection>;
  /** Name of the epic board. */
  name?: Maybe<Scalars['String']>;
  /** Web path of the epic board. */
  webPath: Scalars['String'];
  /** Web URL of the epic board. */
  webUrl: Scalars['String'];
};


/** Represents an epic board */
export type EpicBoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic board */
export type EpicBoardListsArgs = {
  id?: InputMaybe<Scalars['BoardsEpicListID']>;
  epicFilters?: InputMaybe<EpicFilters>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicBoard. */
export type EpicBoardConnection = {
  __typename?: 'EpicBoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicBoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicBoard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EpicBoardCreate */
export type EpicBoardCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of EpicBoardCreate */
export type EpicBoardCreatePayload = {
  __typename?: 'EpicBoardCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type EpicBoardEdge = {
  __typename?: 'EpicBoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicBoard>;
};

/** Autogenerated input type of EpicBoardListCreate */
export type EpicBoardListCreateInput = {
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardsEpicBoardID'];
};

/** Autogenerated return type of EpicBoardListCreate */
export type EpicBoardListCreatePayload = {
  __typename?: 'EpicBoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Epic list in the epic board. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardListDestroy */
export type EpicBoardListDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic board list to destroy. */
  listId: Scalars['BoardsEpicListID'];
};

/** Autogenerated return type of EpicBoardListDestroy */
export type EpicBoardListDestroyPayload = {
  __typename?: 'EpicBoardListDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Epic board list. `null` if the board was destroyed successfully. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardUpdate */
export type EpicBoardUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Epic board global ID. */
  id: Scalars['BoardsEpicBoardID'];
};

/** Autogenerated return type of EpicBoardUpdate */
export type EpicBoardUpdatePayload = {
  __typename?: 'EpicBoardUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for Epic. */
export type EpicConnection = {
  __typename?: 'EpicConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Epic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Counts of descendent epics */
export type EpicDescendantCount = {
  __typename?: 'EpicDescendantCount';
  /** Number of closed child epics. */
  closedEpics?: Maybe<Scalars['Int']>;
  /** Number of closed epic issues. */
  closedIssues?: Maybe<Scalars['Int']>;
  /** Number of opened child epics. */
  openedEpics?: Maybe<Scalars['Int']>;
  /** Number of opened epic issues. */
  openedIssues?: Maybe<Scalars['Int']>;
};

/** Total weight of open and closed descendant issues */
export type EpicDescendantWeights = {
  __typename?: 'EpicDescendantWeights';
  /** Total weight of completed (closed) issues in this epic, including epic descendants. */
  closedIssues?: Maybe<Scalars['Int']>;
  /** Total weight of opened issues in this epic, including epic descendants. */
  openedIssues?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type EpicEdge = {
  __typename?: 'EpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Epic>;
};

export type EpicFilters = {
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** Negated epic arguments. */
  not?: InputMaybe<NegatedEpicBoardIssueInput>;
  /** Search query for epic title or description. */
  search?: InputMaybe<Scalars['String']>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
};

/** Health status of child issues */
export type EpicHealthStatus = {
  __typename?: 'EpicHealthStatus';
  /** Number of issues at risk. */
  issuesAtRisk?: Maybe<Scalars['Int']>;
  /** Number of issues that need attention. */
  issuesNeedingAttention?: Maybe<Scalars['Int']>;
  /** Number of issues on track. */
  issuesOnTrack?: Maybe<Scalars['Int']>;
};

/** Relationship between an epic and an issue */
export type EpicIssue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'EpicIssue';
  /**
   * Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean'];
  /** Count of issues blocking this issue. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Issues blocking this issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues this issue is blocking. */
  blockingCount: Scalars['Int'];
  /** Issue this issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Collection of design images associated with this issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Indicates if a project has email notifications disabled: `true` if email notifications are disabled. */
  emailsDisabled: Scalars['Boolean'];
  /** Epic to which this issue belongs. */
  epic?: Maybe<Epic>;
  /** ID of the epic-issue relation. */
  epicIssueId: Scalars['ID'];
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /**
   * Indicates the issue is hidden because the author has been banned. Will always
   * return `null` if `ban_user_feature_flag` feature flag is disabled.
   */
  hidden?: Maybe<Scalars['Boolean']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** Global ID of the epic-issue relation. */
  id?: Maybe<Scalars['ID']>;
  /** Internal ID of the issue. */
  iid: Scalars['ID'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId: Scalars['Int'];
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** URI path of the epic-issue relation. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']>;
  /** State of the issue. */
  state: IssueState;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String'];
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the issue. */
  totalTimeSpent: Scalars['Int'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String'];
  /** Web URL of the issue. */
  webUrl: Scalars['String'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAlertManagementAlertsArgs = {
  iid?: InputMaybe<Scalars['String']>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  domain?: AlertManagementDomainFilter;
  search?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueIssuableResourceLinksArgs = {
  incidentId: Scalars['IssueID'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicIssue. */
export type EpicIssueConnection = {
  __typename?: 'EpicIssueConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int'];
};

/** An edge in a connection. */
export type EpicIssueEdge = {
  __typename?: 'EpicIssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicIssue>;
};

/** Represents an epic board list */
export type EpicList = {
  __typename?: 'EpicList';
  /** Indicates if this list is collapsed for this user. */
  collapsed?: Maybe<Scalars['Boolean']>;
  /** List epics. */
  epics?: Maybe<EpicConnection>;
  /**
   * Count of epics in the list. Deprecated in 14.9: This was renamed.
   * @deprecated This was renamed. Please use `metadata`. Deprecated in 14.9.
   */
  epicsCount?: Maybe<Scalars['Int']>;
  /** Global ID of the board list. */
  id: Scalars['BoardsEpicListID'];
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Type of the list. */
  listType: Scalars['String'];
  /** Epic list metatada. */
  metadata?: Maybe<EpicListMetadata>;
  /** Position of the list within the board. */
  position?: Maybe<Scalars['Int']>;
  /** Title of the list. */
  title: Scalars['String'];
};


/** Represents an epic board list */
export type EpicListEpicsArgs = {
  filters?: InputMaybe<EpicFilters>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicList. */
export type EpicListConnection = {
  __typename?: 'EpicListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EpicListEdge = {
  __typename?: 'EpicListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicList>;
};

/** Represents epic board list metadata */
export type EpicListMetadata = {
  __typename?: 'EpicListMetadata';
  /** Count of epics in the list. */
  epicsCount?: Maybe<Scalars['Int']>;
  /**
   * Total weight of all issues in the list. Introduced in 14.7: This feature is in
   * Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 14.7.
   */
  totalWeight?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of EpicMoveList */
export type EpicMoveListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID'];
  /** ID of the epic to mutate. */
  epicId: Scalars['EpicID'];
  /** ID of the board list that the epic will be moved from. Required if moving between lists. */
  fromListId?: InputMaybe<Scalars['BoardsEpicListID']>;
  /** ID of the list the epic will be in after mutation. */
  toListId: Scalars['BoardsEpicListID'];
  /** ID of epic that should be placed before the current epic. */
  moveBeforeId?: InputMaybe<Scalars['EpicID']>;
  /** ID of epic that should be placed after the current epic. */
  moveAfterId?: InputMaybe<Scalars['EpicID']>;
};

/** Autogenerated return type of EpicMoveList */
export type EpicMoveListPayload = {
  __typename?: 'EpicMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Check permissions for the current user on an epic */
export type EpicPermissions = {
  __typename?: 'EpicPermissions';
  /** Indicates the user can perform `admin_epic` on this resource */
  adminEpic: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_epic` on this resource */
  createEpic: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_epic` on this resource */
  destroyEpic: Scalars['Boolean'];
  /** Indicates the user can perform `read_epic` on this resource */
  readEpic: Scalars['Boolean'];
  /** Indicates the user can perform `read_epic_iid` on this resource */
  readEpicIid: Scalars['Boolean'];
  /** Indicates the user can perform `update_epic` on this resource */
  updateEpic: Scalars['Boolean'];
};

/** Autogenerated input type of EpicSetSubscription */
export type EpicSetSubscriptionInput = {
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
};

/** Autogenerated return type of EpicSetSubscription */
export type EpicSetSubscriptionPayload = {
  __typename?: 'EpicSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Roadmap sort values */
export enum EpicSort {
  /** Sort by start date in descending order. */
  StartDateDesc = 'START_DATE_DESC',
  /** Sort by start date in ascending order. */
  StartDateAsc = 'START_DATE_ASC',
  /** Sort by end date in descending order. */
  EndDateDesc = 'END_DATE_DESC',
  /** Sort by end date in ascending order. */
  EndDateAsc = 'END_DATE_ASC',
  /** Sort by title in descending order. */
  TitleDesc = 'TITLE_DESC',
  /** Sort by title in ascending order. */
  TitleAsc = 'TITLE_ASC',
  /** Sort by created_at by ascending order. */
  CreatedAtAsc = 'CREATED_AT_ASC',
  /** Sort by created_at by descending order. */
  CreatedAtDesc = 'CREATED_AT_DESC',
  /** Sort by updated_at by ascending order. */
  UpdatedAtAsc = 'UPDATED_AT_ASC',
  /** Sort by updated_at by descending order. */
  UpdatedAtDesc = 'UPDATED_AT_DESC'
}

/** State of an epic */
export enum EpicState {
  /** All epics. */
  All = 'all',
  /** Open epics. */
  Opened = 'opened',
  /** Closed epics. */
  Closed = 'closed'
}

/** State event of an epic */
export enum EpicStateEvent {
  /** Reopen the epic. */
  Reopen = 'REOPEN',
  /** Close the epic. */
  Close = 'CLOSE'
}

/** A node of an epic tree. */
export type EpicTreeNodeFieldsInputType = {
  /** ID of the epic issue or epic that is being moved. */
  id: Scalars['EpicTreeSortingID'];
  /** ID of the epic issue or issue the epic or issue is switched with. */
  adjacentReferenceId?: InputMaybe<Scalars['EpicTreeSortingID']>;
  /** Type of switch. Valid values are `after` or `before`. */
  relativePosition?: InputMaybe<MoveType>;
  /** ID of the new parent epic. */
  newParentId?: InputMaybe<Scalars['EpicID']>;
};

/** Autogenerated input type of EpicTreeReorder */
export type EpicTreeReorderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the base epic of the tree. */
  baseEpicId: Scalars['EpicID'];
  /** Parameters for updating the tree positions. */
  moved: EpicTreeNodeFieldsInputType;
};

/** Autogenerated return type of EpicTreeReorder */
export type EpicTreeReorderPayload = {
  __typename?: 'EpicTreeReorderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Epic ID wildcard values */
export enum EpicWildcardId {
  /** No epic is assigned. */
  None = 'NONE',
  /** Any epic is assigned. */
  Any = 'ANY'
}

/** Autogenerated input type of EscalationPolicyCreate */
export type EscalationPolicyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the escalation policy for. */
  projectPath: Scalars['ID'];
  /** Name of the escalation policy. */
  name: Scalars['String'];
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']>;
  /** Steps of the escalation policy. */
  rules: Array<EscalationRuleInput>;
};

/** Autogenerated return type of EscalationPolicyCreate */
export type EscalationPolicyCreatePayload = {
  __typename?: 'EscalationPolicyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyDestroy */
export type EscalationPolicyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Escalation policy internal ID to remove. */
  id: Scalars['IncidentManagementEscalationPolicyID'];
};

/** Autogenerated return type of EscalationPolicyDestroy */
export type EscalationPolicyDestroyPayload = {
  __typename?: 'EscalationPolicyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation policy */
export type EscalationPolicyType = {
  __typename?: 'EscalationPolicyType';
  /** Description of the escalation policy. */
  description?: Maybe<Scalars['String']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationPolicyID']>;
  /** Name of the escalation policy. */
  name?: Maybe<Scalars['String']>;
  /** Steps of the escalation policy. */
  rules?: Maybe<Array<EscalationRuleType>>;
};

/** The connection type for EscalationPolicyType. */
export type EscalationPolicyTypeConnection = {
  __typename?: 'EscalationPolicyTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EscalationPolicyTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EscalationPolicyType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EscalationPolicyTypeEdge = {
  __typename?: 'EscalationPolicyTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyUpdate */
export type EscalationPolicyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementEscalationPolicyID'];
  /** Name of the escalation policy. */
  name?: InputMaybe<Scalars['String']>;
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']>;
  /** Steps of the escalation policy. */
  rules?: InputMaybe<Array<EscalationRuleInput>>;
};

/** Autogenerated return type of EscalationPolicyUpdate */
export type EscalationPolicyUpdatePayload = {
  __typename?: 'EscalationPolicyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation rule */
export type EscalationRuleInput = {
  /** On-call schedule to notify. */
  oncallScheduleIid?: InputMaybe<Scalars['ID']>;
  /** Username of the user to notify. */
  username?: InputMaybe<Scalars['String']>;
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds: Scalars['Int'];
  /** Status required to prevent the rule from activating. */
  status: EscalationRuleStatus;
};

/** Escalation rule statuses */
export enum EscalationRuleStatus {
  /** . */
  Acknowledged = 'ACKNOWLEDGED',
  /** . */
  Resolved = 'RESOLVED'
}

/** Represents an escalation rule for an escalation policy */
export type EscalationRuleType = {
  __typename?: 'EscalationRuleType';
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds?: Maybe<Scalars['Int']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationRuleID']>;
  /** On-call schedule to notify. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
  /** Status required to prevent the rule from activating. */
  status?: Maybe<EscalationRuleStatus>;
  /** User to notify. */
  user?: Maybe<UserCore>;
};

/** Representing an event */
export type Event = {
  __typename?: 'Event';
  /** Action of the event. */
  action: EventAction;
  /** Author of this event. */
  author: UserCore;
  /** When this event was created. */
  createdAt: Scalars['Time'];
  /** ID of the event. */
  id: Scalars['ID'];
  /** When this event was updated. */
  updatedAt: Scalars['Time'];
};

export type Eventable = {
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
};


export type EventableEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Event action */
export enum EventAction {
  /** Created action */
  Created = 'CREATED',
  /** Updated action */
  Updated = 'UPDATED',
  /** Closed action */
  Closed = 'CLOSED',
  /** Reopened action */
  Reopened = 'REOPENED',
  /** Pushed action */
  Pushed = 'PUSHED',
  /** Commented action */
  Commented = 'COMMENTED',
  /** Merged action */
  Merged = 'MERGED',
  /** Joined action */
  Joined = 'JOINED',
  /** Left action */
  Left = 'LEFT',
  /** Destroyed action */
  Destroyed = 'DESTROYED',
  /** Expired action */
  Expired = 'EXPIRED',
  /** Approved action */
  Approved = 'APPROVED'
}

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Event>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/** Autogenerated input type of ExportRequirements */
export type ExportRequirementsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** List requirements by sort order. */
  sort?: InputMaybe<Sort>;
  /** Filter requirements by state. */
  state?: InputMaybe<RequirementState>;
  /** Search query for requirement title. */
  search?: InputMaybe<Scalars['String']>;
  /** Filter requirements by author username. */
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  /** Full project path the requirements are associated with. */
  projectPath: Scalars['ID'];
  /** List of selected requirements fields to be exported. */
  selectedFields?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of ExportRequirements */
export type ExportRequirementsPayload = {
  __typename?: 'ExportRequirementsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestination = {
  __typename?: 'ExternalAuditEventDestination';
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']>;
  /** Group the destination belongs to. */
  group: Group;
  /** List of additional HTTP headers sent with each event. */
  headers: AuditEventStreamingHeaderConnection;
  /** ID of the destination. */
  id: Scalars['ID'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String'];
};


/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestinationHeadersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ExternalAuditEventDestination. */
export type ExternalAuditEventDestinationConnection = {
  __typename?: 'ExternalAuditEventDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalAuditEventDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalAuditEventDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ExternalAuditEventDestinationCreate */
export type ExternalAuditEventDestinationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL. */
  destinationUrl: Scalars['String'];
  /** Group path. */
  groupPath: Scalars['ID'];
  /** Verification token. */
  verificationToken?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ExternalAuditEventDestinationCreate */
export type ExternalAuditEventDestinationCreatePayload = {
  __typename?: 'ExternalAuditEventDestinationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Destination created. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Autogenerated input type of ExternalAuditEventDestinationDestroy */
export type ExternalAuditEventDestinationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of external audit event destination to destroy. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID'];
};

/** Autogenerated return type of ExternalAuditEventDestinationDestroy */
export type ExternalAuditEventDestinationDestroyPayload = {
  __typename?: 'ExternalAuditEventDestinationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type ExternalAuditEventDestinationEdge = {
  __typename?: 'ExternalAuditEventDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalAuditEventDestination>;
};

/** Autogenerated input type of ExternalAuditEventDestinationUpdate */
export type ExternalAuditEventDestinationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of external audit event destination to update. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID'];
  /** Destination URL to change. */
  destinationUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ExternalAuditEventDestinationUpdate */
export type ExternalAuditEventDestinationUpdatePayload = {
  __typename?: 'ExternalAuditEventDestinationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated destination. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Represents an external issue */
export type ExternalIssue = {
  __typename?: 'ExternalIssue';
  /** Timestamp of when the issue was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Type of external tracker. */
  externalTracker?: Maybe<Scalars['String']>;
  /** Relative reference of the issue in the external tracker. */
  relativeReference?: Maybe<Scalars['String']>;
  /** Status of the issue in the external tracker. */
  status?: Maybe<Scalars['String']>;
  /** Title of the issue in the external tracker. */
  title?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** URL to the issue in the external tracker. */
  webUrl?: Maybe<Scalars['String']>;
};

/** Describes an external status check. */
export type ExternalStatusCheck = {
  __typename?: 'ExternalStatusCheck';
  /** External URL for the status check. */
  externalUrl: Scalars['String'];
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Name of the rule. */
  name: Scalars['String'];
};

/** The connection type for ExternalStatusCheck. */
export type ExternalStatusCheckConnection = {
  __typename?: 'ExternalStatusCheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalStatusCheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalStatusCheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ExternalStatusCheckEdge = {
  __typename?: 'ExternalStatusCheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalStatusCheck>;
};

export type FileUpload = {
  __typename?: 'FileUpload';
  /** Global ID of the upload. */
  id: Scalars['UploadID'];
  /** Path of the upload. */
  path: Scalars['String'];
  /** Size of the upload in bytes. */
  size: Scalars['Int'];
};

export type GeoNode = {
  __typename?: 'GeoNode';
  /** Find Ci Secure File registries on this Geo node */
  ciSecureFileRegistries?: Maybe<CiSecureFileRegistryConnection>;
  /** Maximum concurrency of container repository sync for this secondary node. */
  containerRepositoriesMaxCapacity?: Maybe<Scalars['Int']>;
  /**
   * Find Container Repository registries on this Geo node. Ignored if
   * `geo_container_repository_replication` feature flag is disabled. Introduced in
   * 15.5: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.5.
   */
  containerRepositoryRegistries?: Maybe<ContainerRepositoryRegistryConnection>;
  /**
   * Find Dependency Proxy Blob registries on this Geo node. Ignored if
   * `geo_dependency_proxy_blob_replication` feature flag is disabled. Introduced
   * in 15.6: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.6.
   */
  dependencyProxyBlobRegistries?: Maybe<DependencyProxyBlobRegistryConnection>;
  /** Indicates whether this Geo node is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Maximum concurrency of LFS/attachment backfill for this secondary node. */
  filesMaxCapacity?: Maybe<Scalars['Int']>;
  /** Find group wiki repository registries on this Geo node. */
  groupWikiRepositoryRegistries?: Maybe<GroupWikiRepositoryRegistryConnection>;
  /** ID of this GeoNode. */
  id: Scalars['ID'];
  /** URL defined on the primary node secondary nodes should use to contact it. */
  internalUrl?: Maybe<Scalars['String']>;
  /** Find Job Artifact registries on this Geo node. */
  jobArtifactRegistries?: Maybe<JobArtifactRegistryConnection>;
  /** Find LFS object registries on this Geo node. */
  lfsObjectRegistries?: Maybe<LfsObjectRegistryConnection>;
  /** Find merge request diff registries on this Geo node. */
  mergeRequestDiffRegistries?: Maybe<MergeRequestDiffRegistryConnection>;
  /** Interval (in days) in which the repository verification is valid. After expiry, it is reverted. */
  minimumReverificationInterval?: Maybe<Scalars['Int']>;
  /** Unique identifier for this Geo node. */
  name?: Maybe<Scalars['String']>;
  /** Package file registries of the GeoNode. */
  packageFileRegistries?: Maybe<PackageFileRegistryConnection>;
  /** Find Pages Deployment registries on this Geo node */
  pagesDeploymentRegistries?: Maybe<PagesDeploymentRegistryConnection>;
  /** Find pipeline artifact registries on this Geo node. */
  pipelineArtifactRegistries?: Maybe<PipelineArtifactRegistryConnection>;
  /** Indicates whether this Geo node is the primary. */
  primary?: Maybe<Scalars['Boolean']>;
  /** Maximum concurrency of repository backfill for this secondary node. */
  reposMaxCapacity?: Maybe<Scalars['Int']>;
  /** Namespaces that should be synced, if `selective_sync_type` == `namespaces`. */
  selectiveSyncNamespaces?: Maybe<NamespaceConnection>;
  /** Repository storages whose projects should be synced, if `selective_sync_type` == `shards`. */
  selectiveSyncShards?: Maybe<Array<Scalars['String']>>;
  /** Indicates if syncing is limited to only specific groups, or shards. */
  selectiveSyncType?: Maybe<Scalars['String']>;
  /** Find snippet repository registries on this Geo node. */
  snippetRepositoryRegistries?: Maybe<SnippetRepositoryRegistryConnection>;
  /** Indicates if this secondary node will replicate blobs in Object Storage. */
  syncObjectStorage?: Maybe<Scalars['Boolean']>;
  /** Find terraform state version registries on this Geo node. */
  terraformStateVersionRegistries?: Maybe<TerraformStateVersionRegistryConnection>;
  /** Find Upload registries on this Geo node */
  uploadRegistries?: Maybe<UploadRegistryConnection>;
  /** User-facing URL for this Geo node. */
  url?: Maybe<Scalars['String']>;
  /** Maximum concurrency of repository verification for this secondary node. */
  verificationMaxCapacity?: Maybe<Scalars['Int']>;
};


export type GeoNodeCiSecureFileRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeContainerRepositoryRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeDependencyProxyBlobRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeGroupWikiRepositoryRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeJobArtifactRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeLfsObjectRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeMergeRequestDiffRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodePackageFileRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodePagesDeploymentRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodePipelineArtifactRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeSelectiveSyncNamespacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeSnippetRepositoryRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeTerraformStateVersionRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeUploadRegistriesArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of GitlabSubscriptionActivate */
export type GitlabSubscriptionActivateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Activation code received after purchasing a GitLab subscription. */
  activationCode: Scalars['String'];
};

/** Autogenerated return type of GitlabSubscriptionActivate */
export type GitlabSubscriptionActivatePayload = {
  __typename?: 'GitlabSubscriptionActivatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Array of future subscriptions. */
  futureSubscriptions?: Maybe<Array<SubscriptionFutureEntry>>;
  /** Current license. */
  license?: Maybe<CurrentLicense>;
};

/** Role of User */
export enum GitlabSubscriptionsUserRole {
  /** Guest. */
  Guest = 'GUEST',
  /** Reporter. */
  Reporter = 'REPORTER',
  /** Developer. */
  Developer = 'DEVELOPER',
  /** Maintainer. */
  Maintainer = 'MAINTAINER',
  /** Owner. */
  Owner = 'OWNER'
}

/** GPG signature for a signed commit */
export type GpgSignature = CommitSignature & {
  __typename?: 'GpgSignature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** ID of the GPG key. */
  gpgKeyPrimaryKeyid?: Maybe<Scalars['String']>;
  /** User email associated with the GPG key. */
  gpgKeyUserEmail?: Maybe<Scalars['String']>;
  /** User name associated with the GPG key. */
  gpgKeyUserName?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

export type GrafanaIntegration = {
  __typename?: 'GrafanaIntegration';
  /** Timestamp of the issue's creation. */
  createdAt: Scalars['Time'];
  /** Indicates whether Grafana integration is enabled. */
  enabled: Scalars['Boolean'];
  /** URL for the Grafana host for the Grafana integration. */
  grafanaUrl: Scalars['String'];
  /** Internal ID of the Grafana integration. */
  id: Scalars['ID'];
  /** Timestamp of the issue's last activity. */
  updatedAt: Scalars['Time'];
};

export type Group = {
  __typename?: 'Group';
  /** Size limit for repositories in the namespace in bytes. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']>;
  /** Indicates whether to regularly prune stale group runners. Defaults to false. */
  allowStaleRunnerPruning: Scalars['Boolean'];
  /** Indicates whether Auto DevOps is enabled for all projects within this group. */
  autoDevopsEnabled?: Maybe<Scalars['Boolean']>;
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Number of billable users in the group. */
  billableMembersCount?: Maybe<Scalars['Int']>;
  /** A single board of the group. */
  board?: Maybe<Board>;
  /** Boards of the group. */
  boards?: Maybe<BoardConnection>;
  /** List of the group's CI/CD variables. */
  ciVariables?: Maybe<CiGroupVariableConnection>;
  /** Cluster agents associated with projects in the group and its subgroups. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Represents the code coverage activity for this group. */
  codeCoverageActivities?: Maybe<CodeCoverageActivityConnection>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Counts of contacts by state for the group. */
  contactStateCounts?: Maybe<ContactStateCounts>;
  /** Find contacts of this group. */
  contacts?: Maybe<CustomerRelationsContactConnection>;
  /** Container repositories of the group. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the group. */
  containerRepositoriesCount: Scalars['Int'];
  /** Includes at least one project where the repository size exceeds the limit. */
  containsLockedProjects: Scalars['Boolean'];
  /** Provides the aggregated contributions by users within the group and its subgroups */
  contributions?: Maybe<ContributionAnalyticsContributionConnection>;
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean'];
  /**
   * Custom emoji within this namespace. Introduced in 13.6: This feature is in
   * Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 13.6.
   */
  customEmoji?: Maybe<CustomEmojiConnection>;
  /** Number of dependency proxy blobs cached in the group. */
  dependencyProxyBlobCount: Scalars['Int'];
  /** Dependency Proxy blobs. */
  dependencyProxyBlobs?: Maybe<DependencyProxyBlobConnection>;
  /** Number of dependency proxy images cached in the group. */
  dependencyProxyImageCount: Scalars['Int'];
  /** Prefix for pulling images when using the dependency proxy. */
  dependencyProxyImagePrefix: Scalars['String'];
  /** Dependency proxy TTL policy for the group. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Dependency Proxy manifests. */
  dependencyProxyManifests?: Maybe<DependencyProxyManifestConnection>;
  /** Dependency Proxy settings for the group. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Total size of the dependency proxy cached images. */
  dependencyProxyTotalSize: Scalars['String'];
  /** List of descendant groups of this group. */
  descendantGroups?: Maybe<GroupConnection>;
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Group's DORA metrics. */
  dora?: Maybe<Dora>;
  /** Indicates if a group has email notifications disabled. */
  emailsDisabled?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the group has limited users for a free plan. */
  enforceFreeUserCap?: Maybe<Scalars['Boolean']>;
  /** Find a single epic. */
  epic?: Maybe<Epic>;
  /** Find a single epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Find epic boards. */
  epicBoards?: Maybe<EpicBoardConnection>;
  /** Find epics. */
  epics?: Maybe<EpicConnection>;
  /** Indicates if Epics are enabled for namespace */
  epicsEnabled?: Maybe<Scalars['Boolean']>;
  /** External locations that receive audit events belonging to the group. */
  externalAuditEventDestinations?: Maybe<ExternalAuditEventDestinationConnection>;
  /** Full name of the namespace. */
  fullName: Scalars['String'];
  /** Full path of the namespace. */
  fullPath: Scalars['ID'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /** A membership of a user within this group. */
  groupMembers?: Maybe<GroupMemberConnection>;
  /** ID of the namespace. */
  id: Scalars['ID'];
  /** Status of the temporary storage increase. */
  isTemporaryStorageIncreaseEnabled: Scalars['Boolean'];
  /** Issues for projects in this group. */
  issues?: Maybe<IssueConnection>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Label available on this group. */
  label?: Maybe<Label>;
  /** Labels available on this group. */
  labels?: Maybe<LabelConnection>;
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if a group is disabled from getting mentioned. */
  mentionsDisabled?: Maybe<Scalars['Boolean']>;
  /** Compliance violations reported on merge requests merged within the group. */
  mergeRequestViolations?: Maybe<ComplianceViolationConnection>;
  /** Merge requests for projects in this group. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Milestones of the group. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the namespace. */
  name: Scalars['String'];
  /** Counts of organizations by status for the group. */
  organizationStateCounts?: Maybe<OrganizationStateCounts>;
  /** Find organizations of this group. */
  organizations?: Maybe<CustomerRelationsOrganizationConnection>;
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** Packages of the group. This field can only be resolved for one group in any single request. */
  packages?: Maybe<PackageConnection>;
  /** Parent group. */
  parent?: Maybe<Group>;
  /** Path of the namespace. */
  path: Scalars['String'];
  /** Permission level required to create projects in the group. */
  projectCreationLevel?: Maybe<Scalars['String']>;
  /** Projects within this namespace. */
  projects: ProjectConnection;
  /** List of recently visited boards of the group. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** Number of projects in the root namespace where the repository size exceeds the limit. */
  repositorySizeExcessProjectCount: Scalars['Int'];
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if all users in this group are required to set up two-factor authentication. */
  requireTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Indicates if sharing a project with another group within this group is prevented. */
  shareWithGroupLock?: Maybe<Scalars['Boolean']>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /** Group statistics. */
  stats?: Maybe<GroupStats>;
  /** Total storage limit of the root namespace in bytes. */
  storageSizeLimit?: Maybe<Scalars['Float']>;
  /** Permission level required to create subgroups within the group. */
  subgroupCreationLevel?: Maybe<Scalars['String']>;
  /** Date until the temporary storage increase is active. */
  temporaryStorageIncreaseEndsOn?: Maybe<Scalars['Time']>;
  /**
   * Timelog categories for the namespace. Introduced in 15.3: This feature is in
   * Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the group and its subgroups. */
  timelogs: TimelogConnection;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']>;
  /** Total excess repository size of all projects in the root namespace in bytes. */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Time before two-factor authentication is enforced. */
  twoFactorGracePeriod?: Maybe<Scalars['Int']>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']>;
  /** Vulnerabilities reported on the projects in the group and its subgroups. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects in the group and its subgroups. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades: Array<VulnerableProjectsByGrade>;
  /** Vulnerability scanners reported on the project vulnerabilities of the group and its subgroups. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the group and its subgroups. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /** Web URL of the group. */
  webUrl: Scalars['String'];
  /** Work item types available to the group. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
};


export type GroupBillableMembersCountArgs = {
  requestedHostedPlan?: InputMaybe<Scalars['String']>;
};


export type GroupBoardArgs = {
  id: Scalars['BoardID'];
};


export type GroupBoardsArgs = {
  id?: InputMaybe<Scalars['BoardID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupClusterAgentsArgs = {
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupCodeCoverageActivitiesArgs = {
  startDate: Scalars['Date'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupComplianceFrameworksArgs = {
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupContactStateCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsContactState>;
};


export type GroupContactsArgs = {
  sort?: InputMaybe<ContactSort>;
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsContactState>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsContactID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupContainerRepositoriesArgs = {
  name?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContainerRepositorySort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupContributionsArgs = {
  from: Scalars['ISO8601Date'];
  to: Scalars['ISO8601Date'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupCustomEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDependencyProxyBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDependencyProxyManifestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDescendantGroupsArgs = {
  includeParentDescendants?: InputMaybe<Scalars['Boolean']>;
  owned?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupEpicArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
};


export type GroupEpicBoardArgs = {
  id: Scalars['BoardsEpicBoardID'];
};


export type GroupEpicBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupEpicsArgs = {
  timeframe?: InputMaybe<Timeframe>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<EpicState>;
  sort?: InputMaybe<EpicSort>;
  authorUsername?: InputMaybe<Scalars['String']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupExternalAuditEventDestinationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']>>;
  role: GitlabSubscriptionsUserRole;
};


export type GroupGroupMembersArgs = {
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MemberSort>;
  relations?: InputMaybe<Array<GroupMemberRelation>>;
  accessLevels?: InputMaybe<Array<AccessLevelEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupIssuesArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  epicId?: InputMaybe<Scalars['String']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  weight?: InputMaybe<Scalars['String']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupIterationCadencesArgs = {
  id?: InputMaybe<Scalars['IterationsCadenceID']>;
  title?: InputMaybe<Scalars['String']>;
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  automatic?: InputMaybe<Scalars['Boolean']>;
  active?: InputMaybe<Scalars['Boolean']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupIterationsArgs = {
  timeframe?: InputMaybe<Timeframe>;
  state?: InputMaybe<IterationState>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  id?: InputMaybe<Scalars['ID']>;
  iid?: InputMaybe<Scalars['ID']>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  sort?: InputMaybe<IterationSort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupLabelArgs = {
  title: Scalars['String'];
};


export type GroupLabelsArgs = {
  searchTerm?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  onlyGroupLabels?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupMergeRequestViolationsArgs = {
  filters?: InputMaybe<ComplianceViolationInput>;
  sort?: InputMaybe<ComplianceViolationSort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupMilestonesArgs = {
  timeframe?: InputMaybe<Timeframe>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<MilestoneStateEnum>;
  title?: InputMaybe<Scalars['String']>;
  searchTitle?: InputMaybe<Scalars['String']>;
  containingDate?: InputMaybe<Scalars['Time']>;
  sort?: InputMaybe<MilestoneSort>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupOrganizationStateCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
};


export type GroupOrganizationsArgs = {
  sort?: InputMaybe<OrganizationSort>;
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsOrganizationID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupPackagesArgs = {
  sort?: InputMaybe<PackageGroupSort>;
  packageName?: InputMaybe<Scalars['String']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  status?: InputMaybe<PackageStatus>;
  includeVersionless?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupProjectsArgs = {
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupRunnersArgs = {
  paused?: InputMaybe<Scalars['Boolean']>;
  status?: InputMaybe<CiRunnerStatus>;
  type?: InputMaybe<CiRunnerType>;
  tagList?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<CiRunnerSort>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  membership?: InputMaybe<CiRunnerMembershipFilter>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupScanResultPoliciesArgs = {
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupVulnerabilitiesArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  sort?: InputMaybe<VulnerabilitySort>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupVulnerabilitiesCountByDayArgs = {
  startDate: Scalars['ISO8601Date'];
  endDate: Scalars['ISO8601Date'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupVulnerabilityGradesArgs = {
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
};


export type GroupVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupVulnerabilitySeveritiesCountArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
};


export type GroupWorkItemTypesArgs = {
  taskable?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

/** Represents a Group Membership */
export type GroupMember = MemberInterface & {
  __typename?: 'GroupMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Group that a User is a member of. */
  group?: Maybe<Group>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Group notification email for User. Only available for admins. */
  notificationEmail?: Maybe<Scalars['String']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
};


/** Represents a Group Membership */
export type GroupMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** The connection type for GroupMember. */
export type GroupMemberConnection = {
  __typename?: 'GroupMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupMemberEdge = {
  __typename?: 'GroupMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMember>;
};

/** Group member relation */
export enum GroupMemberRelation {
  /** Members in the group itself. */
  Direct = 'DIRECT',
  /** Members in the group's ancestor groups. */
  Inherited = 'INHERITED',
  /** Members in the group's subgroups. */
  Descendants = 'DESCENDANTS',
  /** Invited group's members. */
  SharedFromGroups = 'SHARED_FROM_GROUPS'
}

/** User permission on groups */
export enum GroupPermission {
  /** Groups where the user can create projects. */
  CreateProjects = 'CREATE_PROJECTS',
  /** Groups where the user can transfer projects to. */
  TransferProjects = 'TRANSFER_PROJECTS'
}

export type GroupPermissions = {
  __typename?: 'GroupPermissions';
  /** Indicates the user can perform `create_projects` on this resource */
  createProjects: Scalars['Boolean'];
  /** Indicates the user can perform `read_group` on this resource */
  readGroup: Scalars['Boolean'];
};

/** Contains release-related statistics about a group */
export type GroupReleaseStats = {
  __typename?: 'GroupReleaseStats';
  /** Total number of releases in all descendant projects of the group. */
  releasesCount?: Maybe<Scalars['Int']>;
  /** Percentage of the group's descendant projects that have at least one release. */
  releasesPercentage?: Maybe<Scalars['Int']>;
};

/** Represents the source of a security policy belonging to a group */
export type GroupSecurityPolicySource = {
  __typename?: 'GroupSecurityPolicySource';
  /** Indicates whether this policy is inherited from parent group. */
  inherited: Scalars['Boolean'];
  /** Project the policy is associated with. */
  namespace?: Maybe<Namespace>;
};

/** Contains statistics about a group */
export type GroupStats = {
  __typename?: 'GroupStats';
  /** Statistics related to releases within the group. */
  releaseStats?: Maybe<GroupReleaseStats>;
};

/** Autogenerated input type of GroupUpdate */
export type GroupUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the group that will be updated. */
  fullPath: Scalars['ID'];
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting: SharedRunnersSetting;
};

/** Autogenerated return type of GroupUpdate */
export type GroupUpdatePayload = {
  __typename?: 'GroupUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group after update. */
  group?: Maybe<Group>;
};

/** Represents the Geo sync and verification state of a group wiki repository */
export type GroupWikiRepositoryRegistry = {
  __typename?: 'GroupWikiRepositoryRegistry';
  /** Timestamp when the GroupWikiRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Group Wiki Repository. */
  groupWikiRepositoryId: Scalars['ID'];
  /** ID of the GroupWikiRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the GroupWikiRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the GroupWikiRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the GroupWikiRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the GroupWikiRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the GroupWikiRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for GroupWikiRepositoryRegistry. */
export type GroupWikiRepositoryRegistryConnection = {
  __typename?: 'GroupWikiRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupWikiRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupWikiRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupWikiRepositoryRegistryEdge = {
  __typename?: 'GroupWikiRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupWikiRepositoryRegistry>;
};

/** Health status of an issue or epic */
export enum HealthStatus {
  /** On track */
  OnTrack = 'onTrack',
  /** Needs attention */
  NeedsAttention = 'needsAttention',
  /** At risk */
  AtRisk = 'atRisk'
}

/** Health status of an issue or epic for filtering */
export enum HealthStatusFilter {
  /** No health status is assigned. */
  None = 'NONE',
  /** Any health status is assigned. */
  Any = 'ANY',
  /** On track */
  OnTrack = 'onTrack',
  /** Needs attention */
  NeedsAttention = 'needsAttention',
  /** At risk */
  AtRisk = 'atRisk'
}

/** Helm file metadata */
export type HelmFileMetadata = PackageFileMetadata & {
  __typename?: 'HelmFileMetadata';
  /** Channel of the Helm chart. */
  channel: Scalars['String'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Metadata of the Helm chart. */
  metadata: PackageHelmMetadataType;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Autogenerated input type of HttpIntegrationCreate */
export type HttpIntegrationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID'];
  /** Name of the integration. */
  name: Scalars['String'];
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean'];
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
};

/** Autogenerated return type of HttpIntegrationCreate */
export type HttpIntegrationCreatePayload = {
  __typename?: 'HttpIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationDestroy */
export type HttpIntegrationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to remove. */
  id: Scalars['AlertManagementHttpIntegrationID'];
};

/** Autogenerated return type of HttpIntegrationDestroy */
export type HttpIntegrationDestroyPayload = {
  __typename?: 'HttpIntegrationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationResetToken */
export type HttpIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID'];
};

/** Autogenerated return type of HttpIntegrationResetToken */
export type HttpIntegrationResetTokenPayload = {
  __typename?: 'HttpIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationUpdate */
export type HttpIntegrationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID'];
  /** Name of the integration. */
  name?: InputMaybe<Scalars['String']>;
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
};

/** Autogenerated return type of HttpIntegrationUpdate */
export type HttpIntegrationUpdatePayload = {
  __typename?: 'HttpIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotation = {
  __typename?: 'IncidentManagementOncallRotation';
  /** Active period for the on-call rotation. */
  activePeriod?: Maybe<OncallRotationActivePeriodType>;
  /** End date and time of the on-call rotation. */
  endsAt?: Maybe<Scalars['Time']>;
  /** ID of the on-call rotation. */
  id: Scalars['IncidentManagementOncallRotationID'];
  /** Length of the on-call schedule, in the units specified by lengthUnit. */
  length?: Maybe<Scalars['Int']>;
  /** Unit of the on-call rotation length. */
  lengthUnit?: Maybe<OncallRotationUnitEnum>;
  /** Name of the on-call rotation. */
  name: Scalars['String'];
  /** Participants of the on-call rotation. */
  participants?: Maybe<OncallParticipantTypeConnection>;
  /** Blocks of time for which a participant is on-call within a given time frame. Time frame cannot exceed one month. */
  shifts?: Maybe<IncidentManagementOncallShiftConnection>;
  /** Start date of the on-call rotation. */
  startsAt?: Maybe<Scalars['Time']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationShiftsArgs = {
  startTime: Scalars['Time'];
  endTime: Scalars['Time'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for IncidentManagementOncallRotation. */
export type IncidentManagementOncallRotationConnection = {
  __typename?: 'IncidentManagementOncallRotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallRotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallRotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallRotationEdge = {
  __typename?: 'IncidentManagementOncallRotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallRotation>;
};

/** Describes an incident management on-call schedule */
export type IncidentManagementOncallSchedule = {
  __typename?: 'IncidentManagementOncallSchedule';
  /** Description of the on-call schedule. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the on-call schedule. */
  iid: Scalars['ID'];
  /** Name of the on-call schedule. */
  name: Scalars['String'];
  oncallUsers?: Maybe<Array<UserCore>>;
  /** On-call rotation for the on-call schedule. */
  rotation?: Maybe<IncidentManagementOncallRotation>;
  /** On-call rotations for the on-call schedule. */
  rotations: IncidentManagementOncallRotationConnection;
  /** Time zone of the on-call schedule. */
  timezone: Scalars['String'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationArgs = {
  id: Scalars['IncidentManagementOncallRotationID'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for IncidentManagementOncallSchedule. */
export type IncidentManagementOncallScheduleConnection = {
  __typename?: 'IncidentManagementOncallScheduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallScheduleEdge = {
  __typename?: 'IncidentManagementOncallScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallSchedule>;
};

/** A block of time for which a participant is on-call. */
export type IncidentManagementOncallShift = {
  __typename?: 'IncidentManagementOncallShift';
  /** End time of the on-call shift. */
  endsAt?: Maybe<Scalars['Time']>;
  /** Participant assigned to the on-call shift. */
  participant?: Maybe<OncallParticipantType>;
  /** Start time of the on-call shift. */
  startsAt?: Maybe<Scalars['Time']>;
};

/** The connection type for IncidentManagementOncallShift. */
export type IncidentManagementOncallShiftConnection = {
  __typename?: 'IncidentManagementOncallShiftConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallShiftEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallShift>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallShiftEdge = {
  __typename?: 'IncidentManagementOncallShiftEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallShift>;
};

export type InstanceSecurityDashboard = {
  __typename?: 'InstanceSecurityDashboard';
  /** Cluster agents associated with projects selected in the Instance Security Dashboard. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Projects selected in Instance Security Dashboard. */
  projects: ProjectConnection;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades: Array<VulnerableProjectsByGrade>;
  /** Vulnerability scanners reported on the vulnerabilities from projects selected in Instance Security Dashboard. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity from projects selected in Instance Security Dashboard. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
};


export type InstanceSecurityDashboardClusterAgentsArgs = {
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type InstanceSecurityDashboardProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type InstanceSecurityDashboardVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type InstanceSecurityDashboardVulnerabilitySeveritiesCountArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
};

/** Represents an issuable. */
export type Issuable = Epic | Issue | MergeRequest | WorkItem;

/** Describes an issuable resource link for incident issues */
export type IssuableResourceLink = {
  __typename?: 'IssuableResourceLink';
  /** ID of the Issuable resource link. */
  id: Scalars['IncidentManagementIssuableResourceLinkID'];
  /** Incident of the resource link. */
  issue: Issue;
  /** Web Link to the resource. */
  link: Scalars['String'];
  /** Optional text for the link. */
  linkText?: Maybe<Scalars['String']>;
  /** Type of the resource link. */
  linkType: IssuableResourceLinkType;
};

/** The connection type for IssuableResourceLink. */
export type IssuableResourceLinkConnection = {
  __typename?: 'IssuableResourceLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssuableResourceLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssuableResourceLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IssuableResourceLinkCreate */
export type IssuableResourceLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Incident id to associate the resource link with. */
  id: Scalars['IssueID'];
  /** Link of the resource. */
  link: Scalars['String'];
  /** Link text of the resource. */
  linkText?: InputMaybe<Scalars['String']>;
  /** Link type of the resource. */
  linkType?: InputMaybe<IssuableResourceLinkType>;
};

/** Autogenerated return type of IssuableResourceLinkCreate */
export type IssuableResourceLinkCreatePayload = {
  __typename?: 'IssuableResourceLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** Autogenerated input type of IssuableResourceLinkDestroy */
export type IssuableResourceLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Issuable resource link ID to remove. */
  id: Scalars['IncidentManagementIssuableResourceLinkID'];
};

/** Autogenerated return type of IssuableResourceLinkDestroy */
export type IssuableResourceLinkDestroyPayload = {
  __typename?: 'IssuableResourceLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** An edge in a connection. */
export type IssuableResourceLinkEdge = {
  __typename?: 'IssuableResourceLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IssuableResourceLink>;
};

/** Issuable resource link type enum */
export enum IssuableResourceLinkType {
  /** General link type */
  General = 'general',
  /** Zoom link type */
  Zoom = 'zoom',
  /** Slack link type */
  Slack = 'slack'
}

/** Fields to perform the search in */
export enum IssuableSearchableField {
  /** Search in title field. */
  Title = 'TITLE',
  /** Search in description field. */
  Description = 'DESCRIPTION'
}

/** Incident severity */
export enum IssuableSeverity {
  /** Unknown severity */
  Unknown = 'UNKNOWN',
  /** Low severity */
  Low = 'LOW',
  /** Medium severity */
  Medium = 'MEDIUM',
  /** High severity */
  High = 'HIGH',
  /** Critical severity */
  Critical = 'CRITICAL'
}

/** State of a GitLab issue or merge request */
export enum IssuableState {
  /** In open state. */
  Opened = 'opened',
  /** In closed state. */
  Closed = 'closed',
  /** Discussion has been locked. */
  Locked = 'locked',
  /** All available. */
  All = 'all'
}

export type Issue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'Issue';
  /**
   * Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean'];
  /** Count of issues blocking this issue. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Issues blocking this issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues this issue is blocking. */
  blockingCount: Scalars['Int'];
  /** Issue this issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Collection of design images associated with this issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Indicates if a project has email notifications disabled: `true` if email notifications are disabled. */
  emailsDisabled: Scalars['Boolean'];
  /** Epic to which this issue belongs. */
  epic?: Maybe<Epic>;
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /**
   * Indicates the issue is hidden because the author has been banned. Will always
   * return `null` if `ban_user_feature_flag` feature flag is disabled.
   */
  hidden?: Maybe<Scalars['Boolean']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** ID of the issue. */
  id: Scalars['ID'];
  /** Internal ID of the issue. */
  iid: Scalars['ID'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId: Scalars['Int'];
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']>;
  /** State of the issue. */
  state: IssueState;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String'];
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the issue. */
  totalTimeSpent: Scalars['Int'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String'];
  /** Web URL of the issue. */
  webUrl: Scalars['String'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']>;
};


export type IssueAlertManagementAlertsArgs = {
  iid?: InputMaybe<Scalars['String']>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  domain?: AlertManagementDomainFilter;
  search?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type IssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueIssuableResourceLinksArgs = {
  incidentId: Scalars['IssueID'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


export type IssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Issue. */
export type IssueConnection = {
  __typename?: 'IssueConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int'];
};

/** Iteration ID wildcard values for issue creation */
export enum IssueCreationIterationWildcardId {
  /** Current iteration. */
  Current = 'CURRENT'
}

/** An edge in a connection. */
export type IssueEdge = {
  __typename?: 'IssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Issue>;
};

/** Issue escalation status values */
export enum IssueEscalationStatus {
  /** Investigation has not started. */
  Triggered = 'TRIGGERED',
  /** Someone is actively investigating the problem. */
  Acknowledged = 'ACKNOWLEDGED',
  /** The problem has been addressed. */
  Resolved = 'RESOLVED',
  /** No action will be taken. */
  Ignored = 'IGNORED'
}

/** Autogenerated input type of IssueMove */
export type IssueMoveInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to move the issue to. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated input type of IssueMoveList */
export type IssueMoveListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board that the issue is in. */
  boardId: Scalars['BoardID'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** ID of the board list that the issue will be moved from. */
  fromListId?: InputMaybe<Scalars['ID']>;
  /** ID of the board list that the issue will be moved to. */
  toListId?: InputMaybe<Scalars['ID']>;
  /** ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['ID']>;
  /** ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['ID']>;
  /** Position of issue within the board list. Positions start at 0. Use -1 to move to the end of the list. */
  positionInList?: InputMaybe<Scalars['Int']>;
  /** ID of the parent epic. NULL when removing the association. */
  epicId?: InputMaybe<Scalars['EpicID']>;
};

/** Autogenerated return type of IssueMoveList */
export type IssueMoveListPayload = {
  __typename?: 'IssueMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated return type of IssueMove */
export type IssueMovePayload = {
  __typename?: 'IssueMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Check permissions for the current user on a issue */
export type IssuePermissions = {
  __typename?: 'IssuePermissions';
  /** Indicates the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean'];
  /** Indicates the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_issue` on this resource */
  readIssue: Scalars['Boolean'];
  /** Indicates the user can perform `reopen_issue` on this resource */
  reopenIssue: Scalars['Boolean'];
  /** Indicates the user can perform `update_issue` on this resource */
  updateIssue: Scalars['Boolean'];
};

/** Autogenerated input type of IssueSetAssignees */
export type IssueSetAssigneesInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of IssueSetAssignees */
export type IssueSetAssigneesPayload = {
  __typename?: 'IssueSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetConfidential */
export type IssueSetConfidentialInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to set the issue as a confidential. */
  confidential: Scalars['Boolean'];
};

/** Autogenerated return type of IssueSetConfidential */
export type IssueSetConfidentialPayload = {
  __typename?: 'IssueSetConfidentialPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetCrmContacts */
export type IssueSetCrmContactsInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Customer relations contact IDs to set. Replaces existing contacts by default. */
  contactIds: Array<Scalars['CustomerRelationsContactID']>;
  /** Changes the operation mode. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of IssueSetCrmContacts */
export type IssueSetCrmContactsPayload = {
  __typename?: 'IssueSetCrmContactsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetDueDate */
export type IssueSetDueDateInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired due date for the issue. Due date is removed if null. */
  dueDate?: InputMaybe<Scalars['Time']>;
};

/** Autogenerated return type of IssueSetDueDate */
export type IssueSetDueDatePayload = {
  __typename?: 'IssueSetDueDatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEpic */
export type IssueSetEpicInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic to be assigned to the issue, epic will be removed if absent or set to null */
  epicId?: InputMaybe<Scalars['EpicID']>;
};

/** Autogenerated return type of IssueSetEpic */
export type IssueSetEpicPayload = {
  __typename?: 'IssueSetEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationPolicy */
export type IssueSetEscalationPolicyInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the escalation policy to assign to the issue. Policy will be removed if absent or set to null. */
  escalationPolicyId?: InputMaybe<Scalars['IncidentManagementEscalationPolicyID']>;
};

/** Autogenerated return type of IssueSetEscalationPolicy */
export type IssueSetEscalationPolicyPayload = {
  __typename?: 'IssueSetEscalationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationStatus */
export type IssueSetEscalationStatusInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Set the escalation status. */
  status: IssueEscalationStatus;
};

/** Autogenerated return type of IssueSetEscalationStatus */
export type IssueSetEscalationStatusPayload = {
  __typename?: 'IssueSetEscalationStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetIteration */
export type IssueSetIterationInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Iteration to assign to the issue. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
};

/** Autogenerated return type of IssueSetIteration */
export type IssueSetIterationPayload = {
  __typename?: 'IssueSetIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetLocked */
export type IssueSetLockedInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to lock discussion on the issue. */
  locked: Scalars['Boolean'];
};

/** Autogenerated return type of IssueSetLocked */
export type IssueSetLockedPayload = {
  __typename?: 'IssueSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSeverity */
export type IssueSetSeverityInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Set the incident severity level. */
  severity: IssuableSeverity;
};

/** Autogenerated return type of IssueSetSeverity */
export type IssueSetSeverityPayload = {
  __typename?: 'IssueSetSeverityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSubscription */
export type IssueSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
};

/** Autogenerated return type of IssueSetSubscription */
export type IssueSetSubscriptionPayload = {
  __typename?: 'IssueSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetWeight */
export type IssueSetWeightInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The desired weight for the issue. If set to null, weight is removed. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of IssueSetWeight */
export type IssueSetWeightPayload = {
  __typename?: 'IssueSetWeightPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Values for sorting issues */
export enum IssueSort {
  /** Due date by ascending order. */
  DueDateAsc = 'DUE_DATE_ASC',
  /** Due date by descending order. */
  DueDateDesc = 'DUE_DATE_DESC',
  /** Relative position by ascending order. */
  RelativePositionAsc = 'RELATIVE_POSITION_ASC',
  /** Severity from less critical to more critical. */
  SeverityAsc = 'SEVERITY_ASC',
  /** Severity from more critical to less critical. */
  SeverityDesc = 'SEVERITY_DESC',
  /** Title by ascending order. */
  TitleAsc = 'TITLE_ASC',
  /** Title by descending order. */
  TitleDesc = 'TITLE_DESC',
  /** Number of upvotes (awarded "thumbs up" emoji) by ascending order. */
  PopularityAsc = 'POPULARITY_ASC',
  /** Number of upvotes (awarded "thumbs up" emoji) by descending order. */
  PopularityDesc = 'POPULARITY_DESC',
  /** Status from triggered to resolved. */
  EscalationStatusAsc = 'ESCALATION_STATUS_ASC',
  /** Status from resolved to triggered. */
  EscalationStatusDesc = 'ESCALATION_STATUS_DESC',
  /** Closed time by ascending order. */
  ClosedAtAsc = 'CLOSED_AT_ASC',
  /** Closed time by descending order. */
  ClosedAtDesc = 'CLOSED_AT_DESC',
  /** Weight by ascending order. */
  WeightAsc = 'WEIGHT_ASC',
  /** Weight by descending order. */
  WeightDesc = 'WEIGHT_DESC',
  /** Published issues shown last. */
  PublishedAsc = 'PUBLISHED_ASC',
  /** Published issues shown first. */
  PublishedDesc = 'PUBLISHED_DESC',
  /** Issues with earliest SLA due time shown first. */
  SlaDueAtAsc = 'SLA_DUE_AT_ASC',
  /** Issues with latest SLA due time shown first. */
  SlaDueAtDesc = 'SLA_DUE_AT_DESC',
  /** Blocking issues count by ascending order. */
  BlockingIssuesAsc = 'BLOCKING_ISSUES_ASC',
  /** Blocking issues count by descending order. */
  BlockingIssuesDesc = 'BLOCKING_ISSUES_DESC',
  /** Issues with healthy issues first. */
  HealthStatusAsc = 'HEALTH_STATUS_ASC',
  /** Issues with unhealthy issues first. */
  HealthStatusDesc = 'HEALTH_STATUS_DESC',
  /** Priority by ascending order. */
  PriorityAsc = 'PRIORITY_ASC',
  /** Priority by descending order. */
  PriorityDesc = 'PRIORITY_DESC',
  /** Label priority by ascending order. */
  LabelPriorityAsc = 'LABEL_PRIORITY_ASC',
  /** Label priority by descending order. */
  LabelPriorityDesc = 'LABEL_PRIORITY_DESC',
  /** Milestone due date by ascending order. */
  MilestoneDueAsc = 'MILESTONE_DUE_ASC',
  /** Milestone due date by descending order. */
  MilestoneDueDesc = 'MILESTONE_DUE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** State of a GitLab issue */
export enum IssueState {
  /** In open state. */
  Opened = 'opened',
  /** In closed state. */
  Closed = 'closed',
  /** Discussion has been locked. */
  Locked = 'locked',
  /** All available. */
  All = 'all'
}

/** Values for issue state events */
export enum IssueStateEvent {
  /** Reopens the issue. */
  Reopen = 'REOPEN',
  /** Closes the issue. */
  Close = 'CLOSE'
}

/** Represents total number of issues for the represented statuses */
export type IssueStatusCountsType = {
  __typename?: 'IssueStatusCountsType';
  /** Number of issues with status ALL for the project */
  all?: Maybe<Scalars['Int']>;
  /** Number of issues with status CLOSED for the project */
  closed?: Maybe<Scalars['Int']>;
  /** Number of issues with status OPENED for the project */
  opened?: Maybe<Scalars['Int']>;
};

/** Issue type */
export enum IssueType {
  /** Issue issue type */
  Issue = 'ISSUE',
  /** Incident issue type */
  Incident = 'INCIDENT',
  /** Test Case issue type */
  TestCase = 'TEST_CASE',
  /** Requirement issue type */
  Requirement = 'REQUIREMENT',
  /**
   * Task issue type. Introduced in 15.2: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.2.
   */
  Task = 'TASK',
  /**
   * Objective issue type. Available only when feature flag `okrs_mvc` is enabled.
   * Introduced in 15.6: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.6.
   */
  Objective = 'OBJECTIVE'
}

/** Represents an iteration object */
export type Iteration = TimeboxReportInterface & {
  __typename?: 'Iteration';
  /** Timestamp of iteration creation. */
  createdAt: Scalars['Time'];
  /** Description of the iteration. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Timestamp of the iteration due date. */
  dueDate?: Maybe<Scalars['Time']>;
  /** ID of the iteration. */
  id: Scalars['ID'];
  /** Internal ID of the iteration. */
  iid: Scalars['ID'];
  /** Cadence of the iteration. */
  iterationCadence: IterationCadence;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Web path of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedPath?: Maybe<Scalars['String']>;
  /** Web URL of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedUrl?: Maybe<Scalars['String']>;
  /**
   * Sequence number for the iteration when you sort the containing cadence's
   * iterations by the start and end date. The earliest starting and ending
   * iteration is assigned 1.
   */
  sequence: Scalars['Int'];
  /** Timestamp of the iteration start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** State of the iteration. */
  state: IterationState;
  /** Title of the iteration. */
  title?: Maybe<Scalars['String']>;
  /** Timestamp of last iteration update. */
  updatedAt: Scalars['Time'];
  /** Web path of the iteration. */
  webPath: Scalars['String'];
  /** Web URL of the iteration. */
  webUrl: Scalars['String'];
};


/** Represents an iteration object */
export type IterationReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** Represents an iteration cadence */
export type IterationCadence = {
  __typename?: 'IterationCadence';
  /** Whether the iteration cadence is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: Maybe<Scalars['Boolean']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: Maybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: Maybe<Scalars['Int']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: Maybe<Scalars['Int']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver: Scalars['Boolean'];
  /** Timestamp of the automation start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** Title of the iteration cadence. */
  title: Scalars['String'];
};

/** The connection type for IterationCadence. */
export type IterationCadenceConnection = {
  __typename?: 'IterationCadenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationCadenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IterationCadence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IterationCadenceCreate */
export type IterationCadenceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group where the iteration cadence is created. */
  groupPath: Scalars['ID'];
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic: Scalars['Boolean'];
  /** Whether the iteration cadence is active. */
  active: Scalars['Boolean'];
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of IterationCadenceCreate */
export type IterationCadenceCreatePayload = {
  __typename?: 'IterationCadenceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceDestroy */
export type IterationCadenceDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
};

/** Autogenerated return type of IterationCadenceDestroy */
export type IterationCadenceDestroyPayload = {
  __typename?: 'IterationCadenceDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group the iteration cadence belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationCadenceEdge = {
  __typename?: 'IterationCadenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceUpdate */
export type IterationCadenceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: InputMaybe<Scalars['Boolean']>;
  /** Whether the iteration cadence is active. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of IterationCadenceUpdate */
export type IterationCadenceUpdatePayload = {
  __typename?: 'IterationCadenceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** The connection type for Iteration. */
export type IterationConnection = {
  __typename?: 'IterationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Iteration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of iterationCreate */
export type IterationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of iterationCreate */
export type IterationCreatePayload = {
  __typename?: 'iterationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of IterationDelete */
export type IterationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the iteration. */
  id: Scalars['IterationID'];
};

/** Autogenerated return type of IterationDelete */
export type IterationDeletePayload = {
  __typename?: 'IterationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group the iteration belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationEdge = {
  __typename?: 'IterationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Iteration>;
};

/** Fields to perform the search in */
export enum IterationSearchableField {
  /** Search in title field. */
  Title = 'TITLE',
  /** Search in cadence_title field. */
  CadenceTitle = 'CADENCE_TITLE'
}

/** Iteration sort values */
export enum IterationSort {
  /** Sort by cadence id in ascending and due date in ascending order. */
  CadenceAndDueDateAsc = 'CADENCE_AND_DUE_DATE_ASC',
  /** Sort by cadence id in ascending and due date in descending order. */
  CadenceAndDueDateDesc = 'CADENCE_AND_DUE_DATE_DESC'
}

/** State of a GitLab iteration */
export enum IterationState {
  /** Upcoming iteration. */
  Upcoming = 'upcoming',
  /**
   * Started iteration. Deprecated in 14.1: Use current instead.
   * @deprecated Use current instead. Deprecated in 14.1.
   */
  Started = 'started',
  /** Current iteration. */
  Current = 'current',
  /** Open iteration. */
  Opened = 'opened',
  /** Closed iteration. */
  Closed = 'closed',
  /** Any iteration. */
  All = 'all'
}

/** Iteration ID wildcard values */
export enum IterationWildcardId {
  /** No iteration is assigned. */
  None = 'NONE',
  /** An iteration is assigned. */
  Any = 'ANY',
  /** Current iteration. */
  Current = 'CURRENT'
}

export type JiraImport = {
  __typename?: 'JiraImport';
  /** Timestamp of when the Jira import was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Count of issues that failed to import. */
  failedToImportCount: Scalars['Int'];
  /** Count of issues that were successfully imported. */
  importedIssuesCount: Scalars['Int'];
  /** Project key for the imported Jira project. */
  jiraProjectKey: Scalars['String'];
  /** Timestamp of when the Jira import was scheduled. */
  scheduledAt?: Maybe<Scalars['Time']>;
  /** User that started the Jira import. */
  scheduledBy?: Maybe<UserCore>;
  /** Total count of issues that were attempted to import. */
  totalIssueCount: Scalars['Int'];
};

/** The connection type for JiraImport. */
export type JiraImportConnection = {
  __typename?: 'JiraImportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraImportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraImport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraImportEdge = {
  __typename?: 'JiraImportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportStart */
export type JiraImportStartInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project key of the importer Jira project. */
  jiraProjectKey: Scalars['String'];
  /** Project name of the importer Jira project. */
  jiraProjectName?: InputMaybe<Scalars['String']>;
  /** Project to import the Jira project into. */
  projectPath: Scalars['ID'];
  /** Mapping of Jira to GitLab users. */
  usersMapping?: InputMaybe<Array<JiraUsersMappingInputType>>;
};

/** Autogenerated return type of JiraImportStart */
export type JiraImportStartPayload = {
  __typename?: 'JiraImportStartPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Jira import data after mutation. */
  jiraImport?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportUsers */
export type JiraImportUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to import the Jira users into. */
  projectPath: Scalars['ID'];
  /** Index of the record the import should started at, default 0 (50 records returned). */
  startAt?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of JiraImportUsers */
export type JiraImportUsersPayload = {
  __typename?: 'JiraImportUsersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Users returned from Jira, matched by email and name if possible. */
  jiraUsers?: Maybe<Array<JiraUser>>;
};

export type JiraProject = {
  __typename?: 'JiraProject';
  /** Key of the Jira project. */
  key: Scalars['String'];
  /** Name of the Jira project. */
  name?: Maybe<Scalars['String']>;
  /** ID of the Jira project. */
  projectId: Scalars['Int'];
};

/** The connection type for JiraProject. */
export type JiraProjectConnection = {
  __typename?: 'JiraProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraProjectEdge = {
  __typename?: 'JiraProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraProject>;
};

export type JiraService = Service & {
  __typename?: 'JiraService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** List of all Jira projects fetched through Jira REST API. */
  projects?: Maybe<JiraProjectConnection>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};


export type JiraServiceProjectsArgs = {
  name?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type JiraUser = {
  __typename?: 'JiraUser';
  /** ID of the matched GitLab user. */
  gitlabId?: Maybe<Scalars['Int']>;
  /** Name of the matched GitLab user. */
  gitlabName?: Maybe<Scalars['String']>;
  /** Username of the matched GitLab user. */
  gitlabUsername?: Maybe<Scalars['String']>;
  /** Account ID of the Jira user. */
  jiraAccountId: Scalars['String'];
  /** Display name of the Jira user. */
  jiraDisplayName: Scalars['String'];
  /** Email of the Jira user, returned only for users with public emails. */
  jiraEmail?: Maybe<Scalars['String']>;
};

export type JiraUsersMappingInputType = {
  /** ID of the GitLab user. */
  gitlabId?: InputMaybe<Scalars['Int']>;
  /** Jira account ID of the user. */
  jiraAccountId: Scalars['String'];
};

export enum JobArtifactFileType {
  /** ARCHIVE job artifact file type. */
  Archive = 'ARCHIVE',
  /** METADATA job artifact file type. */
  Metadata = 'METADATA',
  /** TRACE job artifact file type. */
  Trace = 'TRACE',
  /** JUNIT job artifact file type. */
  Junit = 'JUNIT',
  /** METRICS job artifact file type. */
  Metrics = 'METRICS',
  /** METRICS REFEREE job artifact file type. */
  MetricsReferee = 'METRICS_REFEREE',
  /** NETWORK REFEREE job artifact file type. */
  NetworkReferee = 'NETWORK_REFEREE',
  /** DOTENV job artifact file type. */
  Dotenv = 'DOTENV',
  /** COBERTURA job artifact file type. */
  Cobertura = 'COBERTURA',
  /** CLUSTER APPLICATIONS job artifact file type. */
  ClusterApplications = 'CLUSTER_APPLICATIONS',
  /** LSIF job artifact file type. */
  Lsif = 'LSIF',
  /** CYCLONEDX job artifact file type. */
  Cyclonedx = 'CYCLONEDX',
  /** SAST job artifact file type. */
  Sast = 'SAST',
  /** SECRET DETECTION job artifact file type. */
  SecretDetection = 'SECRET_DETECTION',
  /** DEPENDENCY SCANNING job artifact file type. */
  DependencyScanning = 'DEPENDENCY_SCANNING',
  /** CONTAINER SCANNING job artifact file type. */
  ContainerScanning = 'CONTAINER_SCANNING',
  /** CLUSTER IMAGE SCANNING job artifact file type. */
  ClusterImageScanning = 'CLUSTER_IMAGE_SCANNING',
  /** DAST job artifact file type. */
  Dast = 'DAST',
  /** LICENSE SCANNING job artifact file type. */
  LicenseScanning = 'LICENSE_SCANNING',
  /** ACCESSIBILITY job artifact file type. */
  Accessibility = 'ACCESSIBILITY',
  /** CODE QUALITY job artifact file type. */
  Codequality = 'CODEQUALITY',
  /** PERFORMANCE job artifact file type. */
  Performance = 'PERFORMANCE',
  /** BROWSER PERFORMANCE job artifact file type. */
  BrowserPerformance = 'BROWSER_PERFORMANCE',
  /** LOAD PERFORMANCE job artifact file type. */
  LoadPerformance = 'LOAD_PERFORMANCE',
  /** TERRAFORM job artifact file type. */
  Terraform = 'TERRAFORM',
  /** REQUIREMENTS job artifact file type. */
  Requirements = 'REQUIREMENTS',
  /** COVERAGE FUZZING job artifact file type. */
  CoverageFuzzing = 'COVERAGE_FUZZING',
  /** API FUZZING job artifact file type. */
  ApiFuzzing = 'API_FUZZING'
}

/** Represents the Geo replication and verification state of a job_artifact. */
export type JobArtifactRegistry = {
  __typename?: 'JobArtifactRegistry';
  /** ID of the Job Artifact. */
  artifactId: Scalars['ID'];
  /** Timestamp when the JobArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the JobArtifactRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the JobArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the JobArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the JobArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the JobArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the JobArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the JobArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the JobArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for JobArtifactRegistry. */
export type JobArtifactRegistryConnection = {
  __typename?: 'JobArtifactRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JobArtifactRegistryEdge = {
  __typename?: 'JobArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JobArtifactRegistry>;
};

/** Autogenerated input type of JobArtifactsDestroy */
export type JobArtifactsDestroyInput = {
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of JobArtifactsDestroy */
export type JobArtifactsDestroyPayload = {
  __typename?: 'JobArtifactsDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Number of artifacts deleted. */
  destroyedArtifactsCount: Scalars['Int'];
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job with artifacts to be deleted. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobCancel */
export type JobCancelInput = {
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of JobCancel */
export type JobCancelPayload = {
  __typename?: 'JobCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type JobNeedUnion = CiBuildNeed | CiJob;

/** The connection type for JobNeedUnion. */
export type JobNeedUnionConnection = {
  __typename?: 'JobNeedUnionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobNeedUnionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobNeedUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JobNeedUnionEdge = {
  __typename?: 'JobNeedUnionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JobNeedUnion>;
};

export type JobPermissions = {
  __typename?: 'JobPermissions';
  /** Indicates the user can perform `read_build` on this resource */
  readBuild: Scalars['Boolean'];
  /** Indicates the user can perform `read_job_artifacts` on this resource */
  readJobArtifacts: Scalars['Boolean'];
  /** Indicates the user can perform `update_build` on this resource */
  updateBuild: Scalars['Boolean'];
};

/** Autogenerated input type of JobPlay */
export type JobPlayInput = {
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of JobPlay */
export type JobPlayPayload = {
  __typename?: 'JobPlayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobRetry */
export type JobRetryInput = {
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Variables to use when retrying a manual job. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of JobRetry */
export type JobRetryPayload = {
  __typename?: 'JobRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobUnschedule */
export type JobUnscheduleInput = {
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of JobUnschedule */
export type JobUnschedulePayload = {
  __typename?: 'JobUnschedulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type Kas = {
  __typename?: 'Kas';
  /** Indicates whether the Kubernetes Agent Server is enabled. */
  enabled: Scalars['Boolean'];
  /** URL used by the Agents to communicate with KAS. */
  externalUrl?: Maybe<Scalars['String']>;
  /** KAS version. */
  version?: Maybe<Scalars['String']>;
};

export type Label = {
  __typename?: 'Label';
  /** Background color of the label. */
  color: Scalars['String'];
  /** When this label was created. */
  createdAt: Scalars['Time'];
  /** Description of the label (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Label ID. */
  id: Scalars['ID'];
  /** Text color of the label. */
  textColor: Scalars['String'];
  /** Content of the label. */
  title: Scalars['String'];
  /** When this label was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for Label. */
export type LabelConnection = {
  __typename?: 'LabelConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of LabelCreate */
export type LabelCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Title of the label. */
  title: Scalars['String'];
  /** Description of the label. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * The color of the label given in 6-digit hex notation with leading '#' sign
   * (for example, `#FFAABB`) or one of the CSS color names.
   */
  color?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of LabelCreate */
export type LabelCreatePayload = {
  __typename?: 'LabelCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Label after mutation. */
  label?: Maybe<Label>;
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Represents the Geo sync and verification state of an LFS object */
export type LfsObjectRegistry = {
  __typename?: 'LfsObjectRegistry';
  /** Timestamp when the LfsObjectRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the LfsObjectRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the LfsObjectRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the LfsObjectRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the LFS object. */
  lfsObjectId: Scalars['ID'];
  /** Timestamp after which the LfsObjectRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the LfsObjectRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the LfsObjectRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the LfsObjectRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the LfsObjectRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for LfsObjectRegistry. */
export type LfsObjectRegistryConnection = {
  __typename?: 'LfsObjectRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LfsObjectRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LfsObjectRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LfsObjectRegistryEdge = {
  __typename?: 'LfsObjectRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LfsObjectRegistry>;
};

/** Represents an entry from the Cloud License history */
export type LicenseHistoryEntry = {
  __typename?: 'LicenseHistoryEntry';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']>;
  /** Date, including grace period, when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID'];
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of the license. */
  type: Scalars['String'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
};

/** The connection type for LicenseHistoryEntry. */
export type LicenseHistoryEntryConnection = {
  __typename?: 'LicenseHistoryEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LicenseHistoryEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LicenseHistoryEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LicenseHistoryEntryEdge = {
  __typename?: 'LicenseHistoryEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LicenseHistoryEntry>;
};

/** List limit metric setting */
export enum ListLimitMetric {
  /** Limit list by number and total weight of issues. */
  AllMetrics = 'all_metrics',
  /** Limit list by number of issues. */
  IssueCount = 'issue_count',
  /** Limit list by total weight of issues. */
  IssueWeights = 'issue_weights'
}

/** Autogenerated input type of MarkAsSpamSnippet */
export type MarkAsSpamSnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID'];
};

/** Autogenerated return type of MarkAsSpamSnippet */
export type MarkAsSpamSnippetPayload = {
  __typename?: 'MarkAsSpamSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Maven metadata */
export type MavenMetadata = {
  __typename?: 'MavenMetadata';
  /** App group of the Maven package. */
  appGroup: Scalars['String'];
  /** App name of the Maven package. */
  appName: Scalars['String'];
  /** App version of the Maven package. */
  appVersion?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesMavenMetadatumID'];
  /** Path of the Maven package. */
  path: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Possible identifier types for a measurement */
export enum MeasurementIdentifier {
  /** Project count. */
  Projects = 'PROJECTS',
  /** User count. */
  Users = 'USERS',
  /** Issue count. */
  Issues = 'ISSUES',
  /** Merge request count. */
  MergeRequests = 'MERGE_REQUESTS',
  /** Group count. */
  Groups = 'GROUPS',
  /** Pipeline count. */
  Pipelines = 'PIPELINES',
  /** Pipeline count with success status. */
  PipelinesSucceeded = 'PIPELINES_SUCCEEDED',
  /** Pipeline count with failed status. */
  PipelinesFailed = 'PIPELINES_FAILED',
  /** Pipeline count with canceled status. */
  PipelinesCanceled = 'PIPELINES_CANCELED',
  /** Pipeline count with skipped status. */
  PipelinesSkipped = 'PIPELINES_SKIPPED'
}

export type MemberInterface = {
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
};


export type MemberInterfaceMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** The connection type for MemberInterface. */
export type MemberInterfaceConnection = {
  __typename?: 'MemberInterfaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MemberInterfaceEdge = {
  __typename?: 'MemberInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MemberInterface>;
};

/** Values for sorting members */
export enum MemberSort {
  /** Access level ascending order. */
  AccessLevelAsc = 'ACCESS_LEVEL_ASC',
  /** Access level descending order. */
  AccessLevelDesc = 'ACCESS_LEVEL_DESC',
  /** User's full name ascending order. */
  UserFullNameAsc = 'USER_FULL_NAME_ASC',
  /** User's full name descending order. */
  UserFullNameDesc = 'USER_FULL_NAME_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Defines which user roles, users, or groups can merge into a protected branch. */
export type MergeAccessLevel = {
  __typename?: 'MergeAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for MergeAccessLevel. */
export type MergeAccessLevelConnection = {
  __typename?: 'MergeAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeAccessLevelEdge = {
  __typename?: 'MergeAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeAccessLevel>;
};

export type MergeRequest = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'MergeRequest';
  /** Indicates if members of the target project can push to the fork. */
  allowCollaboration?: Maybe<Scalars['Boolean']>;
  /** Information relating to rules that must be satisfied to merge this merge request. */
  approvalState: MergeRequestApprovalState;
  /** Number of approvals left. */
  approvalsLeft?: Maybe<Scalars['Int']>;
  /** Number of approvals required. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** Indicates if the merge request has all the required approvals. Returns true if no required approvals are configured. */
  approved: Scalars['Boolean'];
  /** Users who approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** Assignees of the merge request. */
  assignees?: Maybe<MergeRequestAssigneeConnection>;
  /** User who created this merge request. */
  author?: Maybe<MergeRequestAuthor>;
  /** Indicates if auto merge is enabled for the merge request. */
  autoMergeEnabled: Scalars['Boolean'];
  /** Selected auto merge strategy. */
  autoMergeStrategy?: Maybe<Scalars['String']>;
  /** Array of available auto merge strategies. */
  availableAutoMergeStrategies?: Maybe<Array<Scalars['String']>>;
  /** Number of commits in the merge request. */
  commitCount?: Maybe<Scalars['Int']>;
  /** Merge request commits. */
  commits?: Maybe<CommitConnection>;
  /** Merge request commits excluding merge commits. */
  commitsWithoutMergeCommits?: Maybe<CommitConnection>;
  /** Users who have added commits to the merge request. */
  committers?: Maybe<UserCoreConnection>;
  /** Indicates if the merge request has conflicts. */
  conflicts: Scalars['Boolean'];
  /** Timestamp of when the merge request was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default merge commit message of the merge request. */
  defaultMergeCommitMessage?: Maybe<Scalars['String']>;
  /** Default squash commit message of the merge request. */
  defaultSquashCommitMessage?: Maybe<Scalars['String']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Detailed merge status of the merge request. */
  detailedMergeStatus?: Maybe<DetailedMergeStatus>;
  /** Diff head SHA of the merge request. */
  diffHeadSha?: Maybe<Scalars['String']>;
  /** References of the base SHA, the head SHA, and the start SHA for this merge request. */
  diffRefs?: Maybe<DiffRefs>;
  /** Details about which files were changed in this merge request. */
  diffStats?: Maybe<Array<DiffStats>>;
  /** Summary of which files were changed in this merge request. */
  diffStatsSummary?: Maybe<DiffStatsSummary>;
  /** Indicates if comments on the merge request are locked to members only. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Indicates if the source branch is behind the target branch. */
  divergedFromTargetBranch: Scalars['Boolean'];
  /** Number of downvotes for the merge request. */
  downvotes: Scalars['Int'];
  /** Indicates if the merge request is a draft. */
  draft: Scalars['Boolean'];
  /** Indicates if the project settings will lead to source branch deletion after merge. */
  forceRemoveSourceBranch?: Maybe<Scalars['Boolean']>;
  /** Indicates if the merge request has CI. */
  hasCi: Scalars['Boolean'];
  /** Indicates if the source branch has any security reports. */
  hasSecurityReports: Scalars['Boolean'];
  /** Pipeline running on the branch HEAD of the merge request. */
  headPipeline?: Maybe<Pipeline>;
  /** Human-readable time estimate of the merge request. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the merge request. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** ID of the merge request. */
  id: Scalars['ID'];
  /** Internal ID of the merge request. */
  iid: Scalars['String'];
  /** Commit SHA of the merge request if merge is in progress. */
  inProgressMergeCommitSha?: Maybe<Scalars['String']>;
  /** Labels of the merge request. */
  labels?: Maybe<LabelConnection>;
  /** SHA of the merge request commit (set once merged). */
  mergeCommitSha?: Maybe<Scalars['String']>;
  /** Error message due to a merge error. */
  mergeError?: Maybe<Scalars['String']>;
  /** Indicates if a merge is currently occurring. */
  mergeOngoing: Scalars['Boolean'];
  /**
   * Status of the merge request. Deprecated in 14.0: This was renamed.
   * @deprecated This was renamed. Please use `MergeRequest.mergeStatusEnum`. Deprecated in 14.0.
   */
  mergeStatus?: Maybe<Scalars['String']>;
  /** Merge status of the merge request. */
  mergeStatusEnum?: Maybe<MergeStatus>;
  /** Number of merge requests in the merge train. */
  mergeTrainsCount?: Maybe<Scalars['Int']>;
  /** User who merged this merge request or set it to merge when pipeline succeeds. */
  mergeUser?: Maybe<UserCore>;
  /** Indicates if the merge has been set to be merged when its pipeline succeeds (MWPS). */
  mergeWhenPipelineSucceeds?: Maybe<Scalars['Boolean']>;
  /** Indicates if the merge request is mergeable. */
  mergeable: Scalars['Boolean'];
  /** Indicates if all discussions in the merge request have been resolved, allowing the merge request to be merged. */
  mergeableDiscussionsState?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the merge request was merged, null if not merged. */
  mergedAt?: Maybe<Scalars['Time']>;
  /** Milestone of the merge request. */
  milestone?: Maybe<Milestone>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Participants in the merge request. This includes the author, assignees, reviewers, and users mentioned in notes. */
  participants?: Maybe<MergeRequestParticipantConnection>;
  /**
   * Pipelines for the merge request. Note: for performance reasons, no more than
   * the most recent 500 pipelines will be returned.
   */
  pipelines?: Maybe<PipelineConnection>;
  /** Alias for target_project. */
  project: Project;
  /** ID of the merge request project. */
  projectId: Scalars['Int'];
  /** Rebase commit SHA of the merge request. */
  rebaseCommitSha?: Maybe<Scalars['String']>;
  /** Indicates if there is a rebase currently in progress for the merge request. */
  rebaseInProgress: Scalars['Boolean'];
  /** Internal reference of the merge request. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** Users from whom a review has been requested. */
  reviewers?: Maybe<MergeRequestReviewerConnection>;
  /** Indicates if the merge request is created by @GitLab-Security-Bot. */
  securityAutoFix?: Maybe<Scalars['Boolean']>;
  /** Indicates if the target branch security reports are out of date. */
  securityReportsUpToDateOnTargetBranch: Scalars['Boolean'];
  /** Indicates if the merge request will be rebased. */
  shouldBeRebased: Scalars['Boolean'];
  /** Indicates if the source branch of the merge request will be deleted after merge. */
  shouldRemoveSourceBranch?: Maybe<Scalars['Boolean']>;
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String'];
  /** Indicates if the source branch of the merge request exists. */
  sourceBranchExists: Scalars['Boolean'];
  /** Indicates if the source branch is protected. */
  sourceBranchProtected: Scalars['Boolean'];
  /** Source project of the merge request. */
  sourceProject?: Maybe<Project>;
  /** ID of the merge request source project. */
  sourceProjectId?: Maybe<Scalars['Int']>;
  /** Indicates if squash on merge is enabled. */
  squash: Scalars['Boolean'];
  /** Indicates if squash on merge is enabled. */
  squashOnMerge: Scalars['Boolean'];
  /** State of the merge request. */
  state: MergeRequestState;
  /** Indicates if the currently logged in user is subscribed to this merge request. */
  subscribed: Scalars['Boolean'];
  /**
   * Suggested reviewers for merge request. Returns `null` if `suggested_reviewers`
   * feature flag is disabled. This flag is disabled by default and only available
   * on GitLab.com because the feature is experimental and is subject to change
   * without notice. Introduced in 15.4: This feature is in Alpha. It can be
   * changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.4.
   */
  suggestedReviewers?: Maybe<SuggestedReviewersType>;
  /** Target branch of the merge request. */
  targetBranch: Scalars['String'];
  /** Indicates if the target branch of the merge request exists. */
  targetBranchExists: Scalars['Boolean'];
  /** Target project of the merge request. */
  targetProject: Project;
  /** ID of the merge request target project. */
  targetProjectId: Scalars['Int'];
  /** Completion status of tasks */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the merge request. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the merge request. */
  timelogs: TimelogConnection;
  /** Title of the merge request. */
  title: Scalars['String'];
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the merge request. */
  totalTimeSpent: Scalars['Int'];
  /** Timestamp of when the merge request was last updated. */
  updatedAt: Scalars['Time'];
  /** Number of upvotes for the merge request. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the merge request. */
  userDiscussionsCount?: Maybe<Scalars['Int']>;
  /** User notes count of the merge request. */
  userNotesCount?: Maybe<Scalars['Int']>;
  /** Permissions for the current user on the resource */
  userPermissions: MergeRequestPermissions;
  /** Web URL of the merge request. */
  webUrl?: Maybe<Scalars['String']>;
};


export type MergeRequestApprovedByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommitsWithoutMergeCommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommittersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type MergeRequestDiffStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


export type MergeRequestDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestPipelinesArgs = {
  status?: InputMaybe<PipelineStatusEnum>;
  scope?: InputMaybe<PipelineScopeEnum>;
  ref?: InputMaybe<Scalars['String']>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


export type MergeRequestReviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of MergeRequestAccept */
export type MergeRequestAcceptInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** How to merge this merge request. */
  strategy?: InputMaybe<MergeStrategyEnum>;
  /** Custom merge commit message. */
  commitMessage?: InputMaybe<Scalars['String']>;
  /** HEAD SHA at the time when this merge was requested. */
  sha: Scalars['String'];
  /** Custom squash commit message (if squash is true). */
  squashCommitMessage?: InputMaybe<Scalars['String']>;
  /** Should the source branch be removed. */
  shouldRemoveSourceBranch?: InputMaybe<Scalars['Boolean']>;
  /** Squash commits on the source branch before merge. */
  squash?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of MergeRequestAccept */
export type MergeRequestAcceptPayload = {
  __typename?: 'MergeRequestAcceptPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Information relating to rules that must be satisfied to merge this merge request. */
export type MergeRequestApprovalState = {
  __typename?: 'MergeRequestApprovalState';
  /** Indicates if the merge request approval rules are overwritten for the merge request. */
  approvalRulesOverwritten?: Maybe<Scalars['Boolean']>;
  /** List of approval rules associated with the merge request. */
  rules?: Maybe<Array<ApprovalRule>>;
};

/** A user assigned to a merge request. */
export type MergeRequestAssignee = User & {
  __typename?: 'MergeRequestAssignee';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for MergeRequestAssignee. */
export type MergeRequestAssigneeConnection = {
  __typename?: 'MergeRequestAssigneeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestAssigneeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestAssignee>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestAssigneeEdge = {
  __typename?: 'MergeRequestAssigneeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestAssignee>;
};

/** The author of the merge request. */
export type MergeRequestAuthor = User & {
  __typename?: 'MergeRequestAuthor';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** The author of the merge request. */
export type MergeRequestAuthorAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for MergeRequest. */
export type MergeRequestConnection = {
  __typename?: 'MergeRequestConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total sum of time to merge, in seconds, for the collection of merge requests. */
  totalTimeToMerge?: Maybe<Scalars['Float']>;
};

/** Autogenerated input type of MergeRequestCreate */
export type MergeRequestCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project full path the merge request is associated with. */
  projectPath: Scalars['ID'];
  /** Title of the merge request. */
  title: Scalars['String'];
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String'];
  /** Target branch of the merge request. */
  targetBranch: Scalars['String'];
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']>;
  /** Labels of the merge request. */
  labels?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of MergeRequestCreate */
export type MergeRequestCreatePayload = {
  __typename?: 'MergeRequestCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Represents the Geo sync and verification state of a Merge Request diff */
export type MergeRequestDiffRegistry = {
  __typename?: 'MergeRequestDiffRegistry';
  /** Timestamp when the MergeRequestDiffRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the MergeRequestDiffRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the MergeRequestDiffRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the MergeRequestDiffRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the Merge Request diff. */
  mergeRequestDiffId: Scalars['ID'];
  /** Timestamp after which the MergeRequestDiffRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the MergeRequestDiffRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the MergeRequestDiffRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the MergeRequestDiffRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the MergeRequestDiffRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for MergeRequestDiffRegistry. */
export type MergeRequestDiffRegistryConnection = {
  __typename?: 'MergeRequestDiffRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestDiffRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestDiffRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestDiffRegistryEdge = {
  __typename?: 'MergeRequestDiffRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestDiffRegistry>;
};

/** An edge in a connection. */
export type MergeRequestEdge = {
  __typename?: 'MergeRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequest>;
};

/** New state to apply to a merge request. */
export enum MergeRequestNewState {
  /** Open the merge request if it is closed. */
  Open = 'OPEN',
  /** Close the merge request if it is open. */
  Closed = 'CLOSED'
}

/** A user participating in a merge request. */
export type MergeRequestParticipant = User & {
  __typename?: 'MergeRequestParticipant';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for MergeRequestParticipant. */
export type MergeRequestParticipantConnection = {
  __typename?: 'MergeRequestParticipantConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestParticipantEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestParticipant>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestParticipantEdge = {
  __typename?: 'MergeRequestParticipantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestParticipant>;
};

/** Check permissions for the current user on a merge request */
export type MergeRequestPermissions = {
  __typename?: 'MergeRequestPermissions';
  /** Indicates the user can perform `admin_merge_request` on this resource */
  adminMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `can_merge` on this resource */
  canMerge: Scalars['Boolean'];
  /** Indicates the user can perform `cherry_pick_on_current_merge_request` on this resource */
  cherryPickOnCurrentMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `push_to_source_branch` on this resource */
  pushToSourceBranch: Scalars['Boolean'];
  /** Indicates the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `remove_source_branch` on this resource */
  removeSourceBranch: Scalars['Boolean'];
  /** Indicates the user can perform `revert_on_current_merge_request` on this resource */
  revertOnCurrentMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `update_merge_request` on this resource */
  updateMergeRequest: Scalars['Boolean'];
};

/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewer = User & {
  __typename?: 'MergeRequestReviewer';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for MergeRequestReviewer. */
export type MergeRequestReviewerConnection = {
  __typename?: 'MergeRequestReviewerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestReviewerEdge = {
  __typename?: 'MergeRequestReviewerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestReviewer>;
};

/** Autogenerated input type of MergeRequestReviewerRereview */
export type MergeRequestReviewerRereviewInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** User ID for the user that has been requested for a new review. */
  userId: Scalars['UserID'];
};

/** Autogenerated return type of MergeRequestReviewerRereview */
export type MergeRequestReviewerRereviewPayload = {
  __typename?: 'MergeRequestReviewerRereviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** State of a review of a GitLab merge request. */
export enum MergeRequestReviewState {
  /** The merge request is unreviewed. */
  Unreviewed = 'UNREVIEWED',
  /** The merge request is reviewed. */
  Reviewed = 'REVIEWED'
}

/** Autogenerated input type of MergeRequestSetAssignees */
export type MergeRequestSetAssigneesInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of MergeRequestSetAssignees */
export type MergeRequestSetAssigneesPayload = {
  __typename?: 'MergeRequestSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetDraft */
export type MergeRequestSetDraftInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to set the merge request as a draft. */
  draft: Scalars['Boolean'];
};

/** Autogenerated return type of MergeRequestSetDraft */
export type MergeRequestSetDraftPayload = {
  __typename?: 'MergeRequestSetDraftPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLabels */
export type MergeRequestSetLabelsInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Label IDs to set. Replaces existing labels by default. */
  labelIds: Array<Scalars['LabelID']>;
  /** Changes the operation mode. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of MergeRequestSetLabels */
export type MergeRequestSetLabelsPayload = {
  __typename?: 'MergeRequestSetLabelsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLocked */
export type MergeRequestSetLockedInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to lock the merge request. */
  locked: Scalars['Boolean'];
};

/** Autogenerated return type of MergeRequestSetLocked */
export type MergeRequestSetLockedPayload = {
  __typename?: 'MergeRequestSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetMilestone */
export type MergeRequestSetMilestoneInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Milestone to assign to the merge request. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
};

/** Autogenerated return type of MergeRequestSetMilestone */
export type MergeRequestSetMilestonePayload = {
  __typename?: 'MergeRequestSetMilestonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetReviewers */
export type MergeRequestSetReviewersInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Usernames of reviewers to assign. Replaces existing reviewers by default. */
  reviewerUsernames: Array<Scalars['String']>;
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
};

/** Autogenerated return type of MergeRequestSetReviewers */
export type MergeRequestSetReviewersPayload = {
  __typename?: 'MergeRequestSetReviewersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetSubscription */
export type MergeRequestSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
};

/** Autogenerated return type of MergeRequestSetSubscription */
export type MergeRequestSetSubscriptionPayload = {
  __typename?: 'MergeRequestSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Values for sorting merge requests */
export enum MergeRequestSort {
  /** Merge time by ascending order. */
  MergedAtAsc = 'MERGED_AT_ASC',
  /** Merge time by descending order. */
  MergedAtDesc = 'MERGED_AT_DESC',
  /** Closed time by ascending order. */
  ClosedAtAsc = 'CLOSED_AT_ASC',
  /** Closed time by descending order. */
  ClosedAtDesc = 'CLOSED_AT_DESC',
  /** Title by ascending order. */
  TitleAsc = 'TITLE_ASC',
  /** Title by descending order. */
  TitleDesc = 'TITLE_DESC',
  /** Priority by ascending order. */
  PriorityAsc = 'PRIORITY_ASC',
  /** Priority by descending order. */
  PriorityDesc = 'PRIORITY_DESC',
  /** Label priority by ascending order. */
  LabelPriorityAsc = 'LABEL_PRIORITY_ASC',
  /** Label priority by descending order. */
  LabelPriorityDesc = 'LABEL_PRIORITY_DESC',
  /** Milestone due date by ascending order. */
  MilestoneDueAsc = 'MILESTONE_DUE_ASC',
  /** Milestone due date by descending order. */
  MilestoneDueDesc = 'MILESTONE_DUE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

export type MergeRequestsResolverNegatedParams = {
  /** Array of label names. All resolved merge requests will not have these labels. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Title of the milestone. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
};

/** State of a GitLab merge request */
export enum MergeRequestState {
  /** Merge request has been merged. */
  Merged = 'merged',
  /** In open state. */
  Opened = 'opened',
  /** In closed state. */
  Closed = 'closed',
  /** Discussion has been locked. */
  Locked = 'locked',
  /** All available. */
  All = 'all'
}

/** Autogenerated input type of MergeRequestUpdate */
export type MergeRequestUpdateInput = {
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Title of the merge request. */
  title?: InputMaybe<Scalars['String']>;
  /** Target branch of the merge request. */
  targetBranch?: InputMaybe<Scalars['String']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']>;
  /** Action to perform to change the state. */
  state?: InputMaybe<MergeRequestNewState>;
};

/** Autogenerated return type of MergeRequestUpdate */
export type MergeRequestUpdatePayload = {
  __typename?: 'MergeRequestUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Representation of whether a GitLab merge request can be merged. */
export enum MergeStatus {
  /** Merge status has not been checked. */
  Unchecked = 'UNCHECKED',
  /** Currently checking for mergeability. */
  Checking = 'CHECKING',
  /** There are no conflicts between the source and target branches. */
  CanBeMerged = 'CAN_BE_MERGED',
  /** There are conflicts between the source and target branches. */
  CannotBeMerged = 'CANNOT_BE_MERGED',
  /** Currently unchecked. The previous state was `CANNOT_BE_MERGED`. */
  CannotBeMergedRecheck = 'CANNOT_BE_MERGED_RECHECK'
}

export enum MergeStrategyEnum {
  /** Use the merge_train merge strategy. */
  MergeTrain = 'MERGE_TRAIN',
  /** Use the add_to_merge_train_when_pipeline_succeeds merge strategy. */
  AddToMergeTrainWhenPipelineSucceeds = 'ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS',
  /** Use the merge_when_pipeline_succeeds merge strategy. */
  MergeWhenPipelineSucceeds = 'MERGE_WHEN_PIPELINE_SUCCEEDS'
}

export type Metadata = {
  __typename?: 'Metadata';
  /** Enterprise edition. */
  enterprise: Scalars['Boolean'];
  /** Metadata about KAS. */
  kas: Kas;
  /** Revision. */
  revision: Scalars['String'];
  /** Version. */
  version: Scalars['String'];
};

/** Represents a metric image upload */
export type MetricImage = {
  __typename?: 'MetricImage';
  /** File name of the metric image. */
  fileName?: Maybe<Scalars['String']>;
  /** File path of the metric image. */
  filePath?: Maybe<Scalars['String']>;
  /** ID of the metric upload. */
  id: Scalars['ID'];
  /** Internal ID of the metric upload. */
  iid: Scalars['ID'];
  /** URL of the metric source. */
  url: Scalars['String'];
};

export type MetricsDashboard = {
  __typename?: 'MetricsDashboard';
  /** Annotations added to the dashboard. */
  annotations?: Maybe<MetricsDashboardAnnotationConnection>;
  /** Path to a file with the dashboard definition. */
  path?: Maybe<Scalars['String']>;
  /** Dashboard schema validation warnings. */
  schemaValidationWarnings?: Maybe<Array<Scalars['String']>>;
};


export type MetricsDashboardAnnotationsArgs = {
  from: Scalars['Time'];
  to?: InputMaybe<Scalars['Time']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type MetricsDashboardAnnotation = {
  __typename?: 'MetricsDashboardAnnotation';
  /** Description of the annotation. */
  description?: Maybe<Scalars['String']>;
  /** Timestamp marking end of annotated time span. */
  endingAt?: Maybe<Scalars['Time']>;
  /** ID of the annotation. */
  id: Scalars['ID'];
  /** ID of a dashboard panel to which the annotation should be scoped. */
  panelId?: Maybe<Scalars['String']>;
  /** Timestamp marking start of annotated time span. */
  startingAt?: Maybe<Scalars['Time']>;
};

/** The connection type for MetricsDashboardAnnotation. */
export type MetricsDashboardAnnotationConnection = {
  __typename?: 'MetricsDashboardAnnotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MetricsDashboardAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MetricsDashboardAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MetricsDashboardAnnotationEdge = {
  __typename?: 'MetricsDashboardAnnotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MetricsDashboardAnnotation>;
};

/** Represents a milestone */
export type Milestone = TimeboxReportInterface & {
  __typename?: 'Milestone';
  /** Timestamp of milestone creation. */
  createdAt: Scalars['Time'];
  /** Description of the milestone. */
  description?: Maybe<Scalars['String']>;
  /** Timestamp of the milestone due date. */
  dueDate?: Maybe<Scalars['Time']>;
  /**
   * Expired state of the milestone (a milestone is expired when the due date is
   * past the current date). Defaults to `false` when due date has not been set.
   */
  expired: Scalars['Boolean'];
  /** Indicates if milestone is at group level. */
  groupMilestone: Scalars['Boolean'];
  /** ID of the milestone. */
  id: Scalars['ID'];
  /** Internal ID of the milestone. */
  iid: Scalars['ID'];
  /** Indicates if milestone is at project level. */
  projectMilestone: Scalars['Boolean'];
  /** Releases associated with this milestone. */
  releases?: Maybe<ReleaseConnection>;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Timestamp of the milestone start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** State of the milestone. */
  state: MilestoneStateEnum;
  /** Milestone statistics. */
  stats?: Maybe<MilestoneStats>;
  /** Indicates if milestone is at subgroup level. */
  subgroupMilestone: Scalars['Boolean'];
  /** Title of the milestone. */
  title: Scalars['String'];
  /** Timestamp of last milestone update. */
  updatedAt: Scalars['Time'];
  /** Web path of the milestone. */
  webPath: Scalars['String'];
};


/** Represents a milestone */
export type MilestoneReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a milestone */
export type MilestoneReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  __typename?: 'MilestoneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MilestoneEdge = {
  __typename?: 'MilestoneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Milestone>;
};

/** Values for sorting milestones */
export enum MilestoneSort {
  /** Milestone due date by ascending order. */
  DueDateAsc = 'DUE_DATE_ASC',
  /** Milestone due date by descending order. */
  DueDateDesc = 'DUE_DATE_DESC',
  /**
   * Group milestones in this order: non-expired milestones with due dates,
   * non-expired milestones without due dates and expired milestones then sort by
   * due date in ascending order.
   */
  ExpiredLastDueDateAsc = 'EXPIRED_LAST_DUE_DATE_ASC',
  /**
   * Group milestones in this order: non-expired milestones with due dates,
   * non-expired milestones without due dates and expired milestones then sort by
   * due date in descending order.
   */
  ExpiredLastDueDateDesc = 'EXPIRED_LAST_DUE_DATE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Current state of milestone */
export enum MilestoneStateEnum {
  /** Milestone is currently active. */
  Active = 'active',
  /** Milestone is closed. */
  Closed = 'closed'
}

/** Contains statistics about a milestone */
export type MilestoneStats = {
  __typename?: 'MilestoneStats';
  /** Number of closed issues associated with the milestone. */
  closedIssuesCount?: Maybe<Scalars['Int']>;
  /** Total number of issues associated with the milestone. */
  totalIssuesCount?: Maybe<Scalars['Int']>;
};

/** Milestone ID wildcard values */
export enum MilestoneWildcardId {
  /** No milestone is assigned. */
  None = 'NONE',
  /** Milestone is assigned. */
  Any = 'ANY',
  /** Milestone assigned is open and started (start date <= today). */
  Started = 'STARTED',
  /** Milestone assigned is due in the future (due date > today). */
  Upcoming = 'UPCOMING'
}

/** The position to which the adjacent object should be moved */
export enum MoveType {
  /** Adjacent object is moved before the object that is being moved. */
  Before = 'before',
  /** Adjacent object is moved after the object that is being moved. */
  After = 'after'
}

export type Mutation = {
  __typename?: 'Mutation';
  addProjectToSecurityDashboard?: Maybe<AddProjectToSecurityDashboardPayload>;
  adminSidekiqQueuesDeleteJobs?: Maybe<AdminSidekiqQueuesDeleteJobsPayload>;
  alertSetAssignees?: Maybe<AlertSetAssigneesPayload>;
  alertTodoCreate?: Maybe<AlertTodoCreatePayload>;
  /** @deprecated The configuration snippet is now generated client-side. Deprecated in 15.1. */
  apiFuzzingCiConfigurationCreate?: Maybe<ApiFuzzingCiConfigurationCreatePayload>;
  artifactDestroy?: Maybe<ArtifactDestroyPayload>;
  auditEventsStreamingDestinationEventsAdd?: Maybe<AuditEventsStreamingDestinationEventsAddPayload>;
  auditEventsStreamingHeadersCreate?: Maybe<AuditEventsStreamingHeadersCreatePayload>;
  auditEventsStreamingHeadersDestroy?: Maybe<AuditEventsStreamingHeadersDestroyPayload>;
  auditEventsStreamingHeadersUpdate?: Maybe<AuditEventsStreamingHeadersUpdatePayload>;
  awardEmojiAdd?: Maybe<AwardEmojiAddPayload>;
  awardEmojiRemove?: Maybe<AwardEmojiRemovePayload>;
  awardEmojiToggle?: Maybe<AwardEmojiTogglePayload>;
  boardEpicCreate?: Maybe<BoardEpicCreatePayload>;
  boardListCreate?: Maybe<BoardListCreatePayload>;
  boardListUpdateLimitMetrics?: Maybe<BoardListUpdateLimitMetricsPayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  bulkEnableDevopsAdoptionNamespaces?: Maybe<BulkEnableDevopsAdoptionNamespacesPayload>;
  /** @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3. */
  bulkRunnerDelete?: Maybe<BulkRunnerDeletePayload>;
  /** @deprecated This was renamed. Please use `ProjectCiCdSettingsUpdate`. Deprecated in 15.0. */
  ciCdSettingsUpdate?: Maybe<CiCdSettingsUpdatePayload>;
  ciJobTokenScopeAddProject?: Maybe<CiJobTokenScopeAddProjectPayload>;
  ciJobTokenScopeRemoveProject?: Maybe<CiJobTokenScopeRemoveProjectPayload>;
  clusterAgentDelete?: Maybe<ClusterAgentDeletePayload>;
  clusterAgentTokenCreate?: Maybe<ClusterAgentTokenCreatePayload>;
  clusterAgentTokenRevoke?: Maybe<ClusterAgentTokenRevokePayload>;
  commitCreate?: Maybe<CommitCreatePayload>;
  /**
   * Configure Container Scanning for a project by enabling Container Scanning in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a merge request are part of the response.
   */
  configureContainerScanning?: Maybe<ConfigureContainerScanningPayload>;
  /**
   * Configure Dependency Scanning for a project by enabling Dependency Scanning in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   */
  configureDependencyScanning?: Maybe<ConfigureDependencyScanningPayload>;
  /**
   * Configure SAST for a project by enabling SAST in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   */
  configureSast?: Maybe<ConfigureSastPayload>;
  /**
   * Enable SAST IaC for a project in a new or
   * modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a merge request are a part of the
   * response.
   */
  configureSastIac?: Maybe<ConfigureSastIacPayload>;
  /**
   * Configure Secret Detection for a project by enabling Secret Detection
   * in a new or modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a Merge Request are a part of the
   * response.
   */
  configureSecretDetection?: Maybe<ConfigureSecretDetectionPayload>;
  corpusCreate?: Maybe<CorpusCreatePayload>;
  createAlertIssue?: Maybe<CreateAlertIssuePayload>;
  createAnnotation?: Maybe<CreateAnnotationPayload>;
  createBoard?: Maybe<CreateBoardPayload>;
  createBranch?: Maybe<CreateBranchPayload>;
  createClusterAgent?: Maybe<CreateClusterAgentPayload>;
  createComplianceFramework?: Maybe<CreateComplianceFrameworkPayload>;
  /** @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 13.6. */
  createCustomEmoji?: Maybe<CreateCustomEmojiPayload>;
  createDiffNote?: Maybe<CreateDiffNotePayload>;
  createEpic?: Maybe<CreateEpicPayload>;
  createImageDiffNote?: Maybe<CreateImageDiffNotePayload>;
  createIssue?: Maybe<CreateIssuePayload>;
  /** @deprecated Use iterationCreate. Deprecated in 14.0. */
  createIteration?: Maybe<CreateIterationPayload>;
  /**
   * Creates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  createNote?: Maybe<CreateNotePayload>;
  createRequirement?: Maybe<CreateRequirementPayload>;
  createSnippet?: Maybe<CreateSnippetPayload>;
  createTestCase?: Maybe<CreateTestCasePayload>;
  customerRelationsContactCreate?: Maybe<CustomerRelationsContactCreatePayload>;
  customerRelationsContactUpdate?: Maybe<CustomerRelationsContactUpdatePayload>;
  customerRelationsOrganizationCreate?: Maybe<CustomerRelationsOrganizationCreatePayload>;
  customerRelationsOrganizationUpdate?: Maybe<CustomerRelationsOrganizationUpdatePayload>;
  dastOnDemandScanCreate?: Maybe<DastOnDemandScanCreatePayload>;
  dastProfileCreate?: Maybe<DastProfileCreatePayload>;
  dastProfileDelete?: Maybe<DastProfileDeletePayload>;
  dastProfileRun?: Maybe<DastProfileRunPayload>;
  dastProfileUpdate?: Maybe<DastProfileUpdatePayload>;
  dastScannerProfileCreate?: Maybe<DastScannerProfileCreatePayload>;
  dastScannerProfileDelete?: Maybe<DastScannerProfileDeletePayload>;
  dastScannerProfileUpdate?: Maybe<DastScannerProfileUpdatePayload>;
  dastSiteProfileCreate?: Maybe<DastSiteProfileCreatePayload>;
  dastSiteProfileDelete?: Maybe<DastSiteProfileDeletePayload>;
  dastSiteProfileUpdate?: Maybe<DastSiteProfileUpdatePayload>;
  dastSiteTokenCreate?: Maybe<DastSiteTokenCreatePayload>;
  dastSiteValidationCreate?: Maybe<DastSiteValidationCreatePayload>;
  dastSiteValidationRevoke?: Maybe<DastSiteValidationRevokePayload>;
  deleteAnnotation?: Maybe<DeleteAnnotationPayload>;
  designManagementDelete?: Maybe<DesignManagementDeletePayload>;
  designManagementMove?: Maybe<DesignManagementMovePayload>;
  designManagementUpload?: Maybe<DesignManagementUploadPayload>;
  destroyBoard?: Maybe<DestroyBoardPayload>;
  destroyBoardList?: Maybe<DestroyBoardListPayload>;
  destroyComplianceFramework?: Maybe<DestroyComplianceFrameworkPayload>;
  destroyContainerRepository?: Maybe<DestroyContainerRepositoryPayload>;
  destroyContainerRepositoryTags?: Maybe<DestroyContainerRepositoryTagsPayload>;
  /** @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 13.6. */
  destroyCustomEmoji?: Maybe<DestroyCustomEmojiPayload>;
  destroyEpicBoard?: Maybe<DestroyEpicBoardPayload>;
  destroyNote?: Maybe<DestroyNotePayload>;
  destroyPackage?: Maybe<DestroyPackagePayload>;
  destroyPackageFile?: Maybe<DestroyPackageFilePayload>;
  destroyPackageFiles?: Maybe<DestroyPackageFilesPayload>;
  destroyPackages?: Maybe<DestroyPackagesPayload>;
  destroySnippet?: Maybe<DestroySnippetPayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  disableDevopsAdoptionNamespace?: Maybe<DisableDevopsAdoptionNamespacePayload>;
  /** Toggles the resolved state of a discussion */
  discussionToggleResolve?: Maybe<DiscussionToggleResolvePayload>;
  /**
   * A mutation that does not perform any changes.
   *
   * This is expected to be used for testing of endpoints, to verify
   * that a user has mutation access.
   */
  echoCreate?: Maybe<EchoCreatePayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  enableDevopsAdoptionNamespace?: Maybe<EnableDevopsAdoptionNamespacePayload>;
  /**
   * **Deprecated** This endpoint is planned to be removed along with
   * certificate-based clusters. [See this
   * epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information.
   */
  environmentsCanaryIngressUpdate?: Maybe<EnvironmentsCanaryIngressUpdatePayload>;
  epicAddIssue?: Maybe<EpicAddIssuePayload>;
  epicBoardCreate?: Maybe<EpicBoardCreatePayload>;
  epicBoardListCreate?: Maybe<EpicBoardListCreatePayload>;
  /** Destroys an epic board list. */
  epicBoardListDestroy?: Maybe<EpicBoardListDestroyPayload>;
  epicBoardUpdate?: Maybe<EpicBoardUpdatePayload>;
  epicMoveList?: Maybe<EpicMoveListPayload>;
  epicSetSubscription?: Maybe<EpicSetSubscriptionPayload>;
  epicTreeReorder?: Maybe<EpicTreeReorderPayload>;
  escalationPolicyCreate?: Maybe<EscalationPolicyCreatePayload>;
  escalationPolicyDestroy?: Maybe<EscalationPolicyDestroyPayload>;
  escalationPolicyUpdate?: Maybe<EscalationPolicyUpdatePayload>;
  exportRequirements?: Maybe<ExportRequirementsPayload>;
  externalAuditEventDestinationCreate?: Maybe<ExternalAuditEventDestinationCreatePayload>;
  externalAuditEventDestinationDestroy?: Maybe<ExternalAuditEventDestinationDestroyPayload>;
  externalAuditEventDestinationUpdate?: Maybe<ExternalAuditEventDestinationUpdatePayload>;
  gitlabSubscriptionActivate?: Maybe<GitlabSubscriptionActivatePayload>;
  groupUpdate?: Maybe<GroupUpdatePayload>;
  httpIntegrationCreate?: Maybe<HttpIntegrationCreatePayload>;
  httpIntegrationDestroy?: Maybe<HttpIntegrationDestroyPayload>;
  httpIntegrationResetToken?: Maybe<HttpIntegrationResetTokenPayload>;
  httpIntegrationUpdate?: Maybe<HttpIntegrationUpdatePayload>;
  issuableResourceLinkCreate?: Maybe<IssuableResourceLinkCreatePayload>;
  issuableResourceLinkDestroy?: Maybe<IssuableResourceLinkDestroyPayload>;
  issueMove?: Maybe<IssueMovePayload>;
  issueMoveList?: Maybe<IssueMoveListPayload>;
  issueSetAssignees?: Maybe<IssueSetAssigneesPayload>;
  issueSetConfidential?: Maybe<IssueSetConfidentialPayload>;
  issueSetCrmContacts?: Maybe<IssueSetCrmContactsPayload>;
  issueSetDueDate?: Maybe<IssueSetDueDatePayload>;
  issueSetEpic?: Maybe<IssueSetEpicPayload>;
  issueSetEscalationPolicy?: Maybe<IssueSetEscalationPolicyPayload>;
  issueSetEscalationStatus?: Maybe<IssueSetEscalationStatusPayload>;
  issueSetIteration?: Maybe<IssueSetIterationPayload>;
  issueSetLocked?: Maybe<IssueSetLockedPayload>;
  issueSetSeverity?: Maybe<IssueSetSeverityPayload>;
  issueSetSubscription?: Maybe<IssueSetSubscriptionPayload>;
  issueSetWeight?: Maybe<IssueSetWeightPayload>;
  iterationCadenceCreate?: Maybe<IterationCadenceCreatePayload>;
  iterationCadenceDestroy?: Maybe<IterationCadenceDestroyPayload>;
  iterationCadenceUpdate?: Maybe<IterationCadenceUpdatePayload>;
  iterationCreate?: Maybe<IterationCreatePayload>;
  iterationDelete?: Maybe<IterationDeletePayload>;
  jiraImportStart?: Maybe<JiraImportStartPayload>;
  jiraImportUsers?: Maybe<JiraImportUsersPayload>;
  jobArtifactsDestroy?: Maybe<JobArtifactsDestroyPayload>;
  jobCancel?: Maybe<JobCancelPayload>;
  jobPlay?: Maybe<JobPlayPayload>;
  jobRetry?: Maybe<JobRetryPayload>;
  jobUnschedule?: Maybe<JobUnschedulePayload>;
  labelCreate?: Maybe<LabelCreatePayload>;
  markAsSpamSnippet?: Maybe<MarkAsSpamSnippetPayload>;
  /**
   * Accepts a merge request.
   * When accepted, the source branch will be merged into the target branch, either
   * immediately if possible, or using one of the automatic merge strategies.
   */
  mergeRequestAccept?: Maybe<MergeRequestAcceptPayload>;
  mergeRequestCreate?: Maybe<MergeRequestCreatePayload>;
  mergeRequestReviewerRereview?: Maybe<MergeRequestReviewerRereviewPayload>;
  mergeRequestSetAssignees?: Maybe<MergeRequestSetAssigneesPayload>;
  mergeRequestSetDraft?: Maybe<MergeRequestSetDraftPayload>;
  mergeRequestSetLabels?: Maybe<MergeRequestSetLabelsPayload>;
  mergeRequestSetLocked?: Maybe<MergeRequestSetLockedPayload>;
  mergeRequestSetMilestone?: Maybe<MergeRequestSetMilestonePayload>;
  mergeRequestSetReviewers?: Maybe<MergeRequestSetReviewersPayload>;
  mergeRequestSetSubscription?: Maybe<MergeRequestSetSubscriptionPayload>;
  /** Update attributes of a merge request */
  mergeRequestUpdate?: Maybe<MergeRequestUpdatePayload>;
  namespaceBanDestroy?: Maybe<NamespaceBanDestroyPayload>;
  namespaceCiCdSettingsUpdate?: Maybe<NamespaceCiCdSettingsUpdatePayload>;
  namespaceIncreaseStorageTemporarily?: Maybe<NamespaceIncreaseStorageTemporarilyPayload>;
  oncallRotationCreate?: Maybe<OncallRotationCreatePayload>;
  oncallRotationDestroy?: Maybe<OncallRotationDestroyPayload>;
  oncallRotationUpdate?: Maybe<OncallRotationUpdatePayload>;
  oncallScheduleCreate?: Maybe<OncallScheduleCreatePayload>;
  oncallScheduleDestroy?: Maybe<OncallScheduleDestroyPayload>;
  oncallScheduleUpdate?: Maybe<OncallScheduleUpdatePayload>;
  pagesMarkOnboardingComplete?: Maybe<PagesMarkOnboardingCompletePayload>;
  pipelineCancel?: Maybe<PipelineCancelPayload>;
  pipelineDestroy?: Maybe<PipelineDestroyPayload>;
  pipelineRetry?: Maybe<PipelineRetryPayload>;
  pipelineScheduleDelete?: Maybe<PipelineScheduleDeletePayload>;
  pipelineScheduleTakeOwnership?: Maybe<PipelineScheduleTakeOwnershipPayload>;
  projectCiCdSettingsUpdate?: Maybe<ProjectCiCdSettingsUpdatePayload>;
  /** Assign (or unset) a compliance framework to a project. */
  projectSetComplianceFramework?: Maybe<ProjectSetComplianceFrameworkPayload>;
  projectSetLocked?: Maybe<ProjectSetLockedPayload>;
  prometheusIntegrationCreate?: Maybe<PrometheusIntegrationCreatePayload>;
  prometheusIntegrationResetToken?: Maybe<PrometheusIntegrationResetTokenPayload>;
  prometheusIntegrationUpdate?: Maybe<PrometheusIntegrationUpdatePayload>;
  promoteToEpic?: Maybe<PromoteToEpicPayload>;
  releaseAssetLinkCreate?: Maybe<ReleaseAssetLinkCreatePayload>;
  releaseAssetLinkDelete?: Maybe<ReleaseAssetLinkDeletePayload>;
  releaseAssetLinkUpdate?: Maybe<ReleaseAssetLinkUpdatePayload>;
  releaseCreate?: Maybe<ReleaseCreatePayload>;
  releaseDelete?: Maybe<ReleaseDeletePayload>;
  releaseUpdate?: Maybe<ReleaseUpdatePayload>;
  removeProjectFromSecurityDashboard?: Maybe<RemoveProjectFromSecurityDashboardPayload>;
  /** Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`) */
  repositionImageDiffNote?: Maybe<RepositionImageDiffNotePayload>;
  runnerDelete?: Maybe<RunnerDeletePayload>;
  runnerUpdate?: Maybe<RunnerUpdatePayload>;
  runnersRegistrationTokenReset?: Maybe<RunnersRegistrationTokenResetPayload>;
  savedReplyCreate?: Maybe<SavedReplyCreatePayload>;
  savedReplyDestroy?: Maybe<SavedReplyDestroyPayload>;
  savedReplyUpdate?: Maybe<SavedReplyUpdatePayload>;
  /** Commits the `policy_yaml` content to the assigned security policy project for the given project (`full_path`) */
  scanExecutionPolicyCommit?: Maybe<ScanExecutionPolicyCommitPayload>;
  securityFindingCreateIssue?: Maybe<SecurityFindingCreateIssuePayload>;
  securityFindingDismiss?: Maybe<SecurityFindingDismissPayload>;
  /**
   * Assigns the specified project(`security_policy_project_id`) as security policy
   * project for the given project(`full_path`). If the project already has a
   * security policy project, this reassigns the project's security policy project
   * with the given `security_policy_project_id`
   */
  securityPolicyProjectAssign?: Maybe<SecurityPolicyProjectAssignPayload>;
  /** Creates and assigns a security policy project for the given project (`full_path`) */
  securityPolicyProjectCreate?: Maybe<SecurityPolicyProjectCreatePayload>;
  /** Unassigns the security policy project for the given project (`full_path`). */
  securityPolicyProjectUnassign?: Maybe<SecurityPolicyProjectUnassignPayload>;
  securityTrainingUpdate?: Maybe<SecurityTrainingUpdatePayload>;
  terraformStateDelete?: Maybe<TerraformStateDeletePayload>;
  terraformStateLock?: Maybe<TerraformStateLockPayload>;
  terraformStateUnlock?: Maybe<TerraformStateUnlockPayload>;
  /** @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.6. */
  timelineEventCreate?: Maybe<TimelineEventCreatePayload>;
  timelineEventDestroy?: Maybe<TimelineEventDestroyPayload>;
  timelineEventPromoteFromNote?: Maybe<TimelineEventPromoteFromNotePayload>;
  timelineEventTagCreate?: Maybe<TimelineEventTagCreatePayload>;
  timelineEventUpdate?: Maybe<TimelineEventUpdatePayload>;
  timelogCreate?: Maybe<TimelogCreatePayload>;
  timelogDelete?: Maybe<TimelogDeletePayload>;
  todoCreate?: Maybe<TodoCreatePayload>;
  todoMarkDone?: Maybe<TodoMarkDonePayload>;
  todoRestore?: Maybe<TodoRestorePayload>;
  todoRestoreMany?: Maybe<TodoRestoreManyPayload>;
  todosMarkAllDone?: Maybe<TodosMarkAllDonePayload>;
  updateAlertStatus?: Maybe<UpdateAlertStatusPayload>;
  updateBoard?: Maybe<UpdateBoardPayload>;
  updateBoardEpicUserPreferences?: Maybe<UpdateBoardEpicUserPreferencesPayload>;
  updateBoardList?: Maybe<UpdateBoardListPayload>;
  updateComplianceFramework?: Maybe<UpdateComplianceFrameworkPayload>;
  updateContainerExpirationPolicy?: Maybe<UpdateContainerExpirationPolicyPayload>;
  updateDependencyProxyImageTtlGroupPolicy?: Maybe<UpdateDependencyProxyImageTtlGroupPolicyPayload>;
  /**
   * These settings can be adjusted by the group Owner or Maintainer. However, in
   * GitLab 16.0, we will be limiting this to the Owner role.
   * [GitLab-#364441](https://gitlab.com/gitlab-org/gitlab/-/issues/364441)
   * proposes making this change to match the permissions level in the user interface.
   */
  updateDependencyProxySettings?: Maybe<UpdateDependencyProxySettingsPayload>;
  updateEpic?: Maybe<UpdateEpicPayload>;
  updateEpicBoardList?: Maybe<UpdateEpicBoardListPayload>;
  /**
   * Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  updateImageDiffNote?: Maybe<UpdateImageDiffNotePayload>;
  updateIssue?: Maybe<UpdateIssuePayload>;
  updateIteration?: Maybe<UpdateIterationPayload>;
  updateNamespacePackageSettings?: Maybe<UpdateNamespacePackageSettingsPayload>;
  /**
   * Updates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  updateNote?: Maybe<UpdateNotePayload>;
  updatePackagesCleanupPolicy?: Maybe<UpdatePackagesCleanupPolicyPayload>;
  updateRequirement?: Maybe<UpdateRequirementPayload>;
  updateSnippet?: Maybe<UpdateSnippetPayload>;
  /** Deletes an upload. */
  uploadDelete?: Maybe<UploadDeletePayload>;
  userCalloutCreate?: Maybe<UserCalloutCreatePayload>;
  userPreferencesUpdate?: Maybe<UserPreferencesUpdatePayload>;
  vulnerabilityConfirm?: Maybe<VulnerabilityConfirmPayload>;
  vulnerabilityCreate?: Maybe<VulnerabilityCreatePayload>;
  vulnerabilityDismiss?: Maybe<VulnerabilityDismissPayload>;
  vulnerabilityExternalIssueLinkCreate?: Maybe<VulnerabilityExternalIssueLinkCreatePayload>;
  vulnerabilityExternalIssueLinkDestroy?: Maybe<VulnerabilityExternalIssueLinkDestroyPayload>;
  /** @deprecated Use VulnerabilityDismiss for vulnerabilities or SecurityFindingDismiss for pipeline findings. Deprecated in 15.5. */
  vulnerabilityFindingDismiss?: Maybe<VulnerabilityFindingDismissPayload>;
  vulnerabilityResolve?: Maybe<VulnerabilityResolvePayload>;
  vulnerabilityRevertToDetected?: Maybe<VulnerabilityRevertToDetectedPayload>;
  /**
   * Creates a work item. Introduced in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemCreate?: Maybe<WorkItemCreatePayload>;
  /**
   * Creates a work item from a task in another work item's description. Introduced
   * in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemCreateFromTask?: Maybe<WorkItemCreateFromTaskPayload>;
  /**
   * Deletes a work item. Introduced in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemDelete?: Maybe<WorkItemDeletePayload>;
  /**
   * Deletes a task in a work item's description. Introduced in 15.1: This feature
   * is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemDeleteTask?: Maybe<WorkItemDeleteTaskPayload>;
  /**
   * Updates a work item by Global ID. Introduced in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemUpdate?: Maybe<WorkItemUpdatePayload>;
  /**
   * Updates a work item's task by Global ID. Introduced in 15.1: This feature is
   * in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemUpdateTask?: Maybe<WorkItemUpdateTaskPayload>;
};


export type MutationAddProjectToSecurityDashboardArgs = {
  input: AddProjectToSecurityDashboardInput;
};


export type MutationAdminSidekiqQueuesDeleteJobsArgs = {
  input: AdminSidekiqQueuesDeleteJobsInput;
};


export type MutationAlertSetAssigneesArgs = {
  input: AlertSetAssigneesInput;
};


export type MutationAlertTodoCreateArgs = {
  input: AlertTodoCreateInput;
};


export type MutationApiFuzzingCiConfigurationCreateArgs = {
  input: ApiFuzzingCiConfigurationCreateInput;
};


export type MutationArtifactDestroyArgs = {
  input: ArtifactDestroyInput;
};


export type MutationAuditEventsStreamingDestinationEventsAddArgs = {
  input: AuditEventsStreamingDestinationEventsAddInput;
};


export type MutationAuditEventsStreamingHeadersCreateArgs = {
  input: AuditEventsStreamingHeadersCreateInput;
};


export type MutationAuditEventsStreamingHeadersDestroyArgs = {
  input: AuditEventsStreamingHeadersDestroyInput;
};


export type MutationAuditEventsStreamingHeadersUpdateArgs = {
  input: AuditEventsStreamingHeadersUpdateInput;
};


export type MutationAwardEmojiAddArgs = {
  input: AwardEmojiAddInput;
};


export type MutationAwardEmojiRemoveArgs = {
  input: AwardEmojiRemoveInput;
};


export type MutationAwardEmojiToggleArgs = {
  input: AwardEmojiToggleInput;
};


export type MutationBoardEpicCreateArgs = {
  input: BoardEpicCreateInput;
};


export type MutationBoardListCreateArgs = {
  input: BoardListCreateInput;
};


export type MutationBoardListUpdateLimitMetricsArgs = {
  input: BoardListUpdateLimitMetricsInput;
};


export type MutationBulkEnableDevopsAdoptionNamespacesArgs = {
  input: BulkEnableDevopsAdoptionNamespacesInput;
};


export type MutationBulkRunnerDeleteArgs = {
  input: BulkRunnerDeleteInput;
};


export type MutationCiCdSettingsUpdateArgs = {
  input: CiCdSettingsUpdateInput;
};


export type MutationCiJobTokenScopeAddProjectArgs = {
  input: CiJobTokenScopeAddProjectInput;
};


export type MutationCiJobTokenScopeRemoveProjectArgs = {
  input: CiJobTokenScopeRemoveProjectInput;
};


export type MutationClusterAgentDeleteArgs = {
  input: ClusterAgentDeleteInput;
};


export type MutationClusterAgentTokenCreateArgs = {
  input: ClusterAgentTokenCreateInput;
};


export type MutationClusterAgentTokenRevokeArgs = {
  input: ClusterAgentTokenRevokeInput;
};


export type MutationCommitCreateArgs = {
  input: CommitCreateInput;
};


export type MutationConfigureContainerScanningArgs = {
  input: ConfigureContainerScanningInput;
};


export type MutationConfigureDependencyScanningArgs = {
  input: ConfigureDependencyScanningInput;
};


export type MutationConfigureSastArgs = {
  input: ConfigureSastInput;
};


export type MutationConfigureSastIacArgs = {
  input: ConfigureSastIacInput;
};


export type MutationConfigureSecretDetectionArgs = {
  input: ConfigureSecretDetectionInput;
};


export type MutationCorpusCreateArgs = {
  input: CorpusCreateInput;
};


export type MutationCreateAlertIssueArgs = {
  input: CreateAlertIssueInput;
};


export type MutationCreateAnnotationArgs = {
  input: CreateAnnotationInput;
};


export type MutationCreateBoardArgs = {
  input: CreateBoardInput;
};


export type MutationCreateBranchArgs = {
  input: CreateBranchInput;
};


export type MutationCreateClusterAgentArgs = {
  input: CreateClusterAgentInput;
};


export type MutationCreateComplianceFrameworkArgs = {
  input: CreateComplianceFrameworkInput;
};


export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};


export type MutationCreateDiffNoteArgs = {
  input: CreateDiffNoteInput;
};


export type MutationCreateEpicArgs = {
  input: CreateEpicInput;
};


export type MutationCreateImageDiffNoteArgs = {
  input: CreateImageDiffNoteInput;
};


export type MutationCreateIssueArgs = {
  input: CreateIssueInput;
};


export type MutationCreateIterationArgs = {
  input: CreateIterationInput;
};


export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


export type MutationCreateRequirementArgs = {
  input: CreateRequirementInput;
};


export type MutationCreateSnippetArgs = {
  input: CreateSnippetInput;
};


export type MutationCreateTestCaseArgs = {
  input: CreateTestCaseInput;
};


export type MutationCustomerRelationsContactCreateArgs = {
  input: CustomerRelationsContactCreateInput;
};


export type MutationCustomerRelationsContactUpdateArgs = {
  input: CustomerRelationsContactUpdateInput;
};


export type MutationCustomerRelationsOrganizationCreateArgs = {
  input: CustomerRelationsOrganizationCreateInput;
};


export type MutationCustomerRelationsOrganizationUpdateArgs = {
  input: CustomerRelationsOrganizationUpdateInput;
};


export type MutationDastOnDemandScanCreateArgs = {
  input: DastOnDemandScanCreateInput;
};


export type MutationDastProfileCreateArgs = {
  input: DastProfileCreateInput;
};


export type MutationDastProfileDeleteArgs = {
  input: DastProfileDeleteInput;
};


export type MutationDastProfileRunArgs = {
  input: DastProfileRunInput;
};


export type MutationDastProfileUpdateArgs = {
  input: DastProfileUpdateInput;
};


export type MutationDastScannerProfileCreateArgs = {
  input: DastScannerProfileCreateInput;
};


export type MutationDastScannerProfileDeleteArgs = {
  input: DastScannerProfileDeleteInput;
};


export type MutationDastScannerProfileUpdateArgs = {
  input: DastScannerProfileUpdateInput;
};


export type MutationDastSiteProfileCreateArgs = {
  input: DastSiteProfileCreateInput;
};


export type MutationDastSiteProfileDeleteArgs = {
  input: DastSiteProfileDeleteInput;
};


export type MutationDastSiteProfileUpdateArgs = {
  input: DastSiteProfileUpdateInput;
};


export type MutationDastSiteTokenCreateArgs = {
  input: DastSiteTokenCreateInput;
};


export type MutationDastSiteValidationCreateArgs = {
  input: DastSiteValidationCreateInput;
};


export type MutationDastSiteValidationRevokeArgs = {
  input: DastSiteValidationRevokeInput;
};


export type MutationDeleteAnnotationArgs = {
  input: DeleteAnnotationInput;
};


export type MutationDesignManagementDeleteArgs = {
  input: DesignManagementDeleteInput;
};


export type MutationDesignManagementMoveArgs = {
  input: DesignManagementMoveInput;
};


export type MutationDesignManagementUploadArgs = {
  input: DesignManagementUploadInput;
};


export type MutationDestroyBoardArgs = {
  input: DestroyBoardInput;
};


export type MutationDestroyBoardListArgs = {
  input: DestroyBoardListInput;
};


export type MutationDestroyComplianceFrameworkArgs = {
  input: DestroyComplianceFrameworkInput;
};


export type MutationDestroyContainerRepositoryArgs = {
  input: DestroyContainerRepositoryInput;
};


export type MutationDestroyContainerRepositoryTagsArgs = {
  input: DestroyContainerRepositoryTagsInput;
};


export type MutationDestroyCustomEmojiArgs = {
  input: DestroyCustomEmojiInput;
};


export type MutationDestroyEpicBoardArgs = {
  input: DestroyEpicBoardInput;
};


export type MutationDestroyNoteArgs = {
  input: DestroyNoteInput;
};


export type MutationDestroyPackageArgs = {
  input: DestroyPackageInput;
};


export type MutationDestroyPackageFileArgs = {
  input: DestroyPackageFileInput;
};


export type MutationDestroyPackageFilesArgs = {
  input: DestroyPackageFilesInput;
};


export type MutationDestroyPackagesArgs = {
  input: DestroyPackagesInput;
};


export type MutationDestroySnippetArgs = {
  input: DestroySnippetInput;
};


export type MutationDisableDevopsAdoptionNamespaceArgs = {
  input: DisableDevopsAdoptionNamespaceInput;
};


export type MutationDiscussionToggleResolveArgs = {
  input: DiscussionToggleResolveInput;
};


export type MutationEchoCreateArgs = {
  input: EchoCreateInput;
};


export type MutationEnableDevopsAdoptionNamespaceArgs = {
  input: EnableDevopsAdoptionNamespaceInput;
};


export type MutationEnvironmentsCanaryIngressUpdateArgs = {
  input: EnvironmentsCanaryIngressUpdateInput;
};


export type MutationEpicAddIssueArgs = {
  input: EpicAddIssueInput;
};


export type MutationEpicBoardCreateArgs = {
  input: EpicBoardCreateInput;
};


export type MutationEpicBoardListCreateArgs = {
  input: EpicBoardListCreateInput;
};


export type MutationEpicBoardListDestroyArgs = {
  input: EpicBoardListDestroyInput;
};


export type MutationEpicBoardUpdateArgs = {
  input: EpicBoardUpdateInput;
};


export type MutationEpicMoveListArgs = {
  input: EpicMoveListInput;
};


export type MutationEpicSetSubscriptionArgs = {
  input: EpicSetSubscriptionInput;
};


export type MutationEpicTreeReorderArgs = {
  input: EpicTreeReorderInput;
};


export type MutationEscalationPolicyCreateArgs = {
  input: EscalationPolicyCreateInput;
};


export type MutationEscalationPolicyDestroyArgs = {
  input: EscalationPolicyDestroyInput;
};


export type MutationEscalationPolicyUpdateArgs = {
  input: EscalationPolicyUpdateInput;
};


export type MutationExportRequirementsArgs = {
  input: ExportRequirementsInput;
};


export type MutationExternalAuditEventDestinationCreateArgs = {
  input: ExternalAuditEventDestinationCreateInput;
};


export type MutationExternalAuditEventDestinationDestroyArgs = {
  input: ExternalAuditEventDestinationDestroyInput;
};


export type MutationExternalAuditEventDestinationUpdateArgs = {
  input: ExternalAuditEventDestinationUpdateInput;
};


export type MutationGitlabSubscriptionActivateArgs = {
  input: GitlabSubscriptionActivateInput;
};


export type MutationGroupUpdateArgs = {
  input: GroupUpdateInput;
};


export type MutationHttpIntegrationCreateArgs = {
  input: HttpIntegrationCreateInput;
};


export type MutationHttpIntegrationDestroyArgs = {
  input: HttpIntegrationDestroyInput;
};


export type MutationHttpIntegrationResetTokenArgs = {
  input: HttpIntegrationResetTokenInput;
};


export type MutationHttpIntegrationUpdateArgs = {
  input: HttpIntegrationUpdateInput;
};


export type MutationIssuableResourceLinkCreateArgs = {
  input: IssuableResourceLinkCreateInput;
};


export type MutationIssuableResourceLinkDestroyArgs = {
  input: IssuableResourceLinkDestroyInput;
};


export type MutationIssueMoveArgs = {
  input: IssueMoveInput;
};


export type MutationIssueMoveListArgs = {
  input: IssueMoveListInput;
};


export type MutationIssueSetAssigneesArgs = {
  input: IssueSetAssigneesInput;
};


export type MutationIssueSetConfidentialArgs = {
  input: IssueSetConfidentialInput;
};


export type MutationIssueSetCrmContactsArgs = {
  input: IssueSetCrmContactsInput;
};


export type MutationIssueSetDueDateArgs = {
  input: IssueSetDueDateInput;
};


export type MutationIssueSetEpicArgs = {
  input: IssueSetEpicInput;
};


export type MutationIssueSetEscalationPolicyArgs = {
  input: IssueSetEscalationPolicyInput;
};


export type MutationIssueSetEscalationStatusArgs = {
  input: IssueSetEscalationStatusInput;
};


export type MutationIssueSetIterationArgs = {
  input: IssueSetIterationInput;
};


export type MutationIssueSetLockedArgs = {
  input: IssueSetLockedInput;
};


export type MutationIssueSetSeverityArgs = {
  input: IssueSetSeverityInput;
};


export type MutationIssueSetSubscriptionArgs = {
  input: IssueSetSubscriptionInput;
};


export type MutationIssueSetWeightArgs = {
  input: IssueSetWeightInput;
};


export type MutationIterationCadenceCreateArgs = {
  input: IterationCadenceCreateInput;
};


export type MutationIterationCadenceDestroyArgs = {
  input: IterationCadenceDestroyInput;
};


export type MutationIterationCadenceUpdateArgs = {
  input: IterationCadenceUpdateInput;
};


export type MutationIterationCreateArgs = {
  input: IterationCreateInput;
};


export type MutationIterationDeleteArgs = {
  input: IterationDeleteInput;
};


export type MutationJiraImportStartArgs = {
  input: JiraImportStartInput;
};


export type MutationJiraImportUsersArgs = {
  input: JiraImportUsersInput;
};


export type MutationJobArtifactsDestroyArgs = {
  input: JobArtifactsDestroyInput;
};


export type MutationJobCancelArgs = {
  input: JobCancelInput;
};


export type MutationJobPlayArgs = {
  input: JobPlayInput;
};


export type MutationJobRetryArgs = {
  input: JobRetryInput;
};


export type MutationJobUnscheduleArgs = {
  input: JobUnscheduleInput;
};


export type MutationLabelCreateArgs = {
  input: LabelCreateInput;
};


export type MutationMarkAsSpamSnippetArgs = {
  input: MarkAsSpamSnippetInput;
};


export type MutationMergeRequestAcceptArgs = {
  input: MergeRequestAcceptInput;
};


export type MutationMergeRequestCreateArgs = {
  input: MergeRequestCreateInput;
};


export type MutationMergeRequestReviewerRereviewArgs = {
  input: MergeRequestReviewerRereviewInput;
};


export type MutationMergeRequestSetAssigneesArgs = {
  input: MergeRequestSetAssigneesInput;
};


export type MutationMergeRequestSetDraftArgs = {
  input: MergeRequestSetDraftInput;
};


export type MutationMergeRequestSetLabelsArgs = {
  input: MergeRequestSetLabelsInput;
};


export type MutationMergeRequestSetLockedArgs = {
  input: MergeRequestSetLockedInput;
};


export type MutationMergeRequestSetMilestoneArgs = {
  input: MergeRequestSetMilestoneInput;
};


export type MutationMergeRequestSetReviewersArgs = {
  input: MergeRequestSetReviewersInput;
};


export type MutationMergeRequestSetSubscriptionArgs = {
  input: MergeRequestSetSubscriptionInput;
};


export type MutationMergeRequestUpdateArgs = {
  input: MergeRequestUpdateInput;
};


export type MutationNamespaceBanDestroyArgs = {
  input: NamespaceBanDestroyInput;
};


export type MutationNamespaceCiCdSettingsUpdateArgs = {
  input: NamespaceCiCdSettingsUpdateInput;
};


export type MutationNamespaceIncreaseStorageTemporarilyArgs = {
  input: NamespaceIncreaseStorageTemporarilyInput;
};


export type MutationOncallRotationCreateArgs = {
  input: OncallRotationCreateInput;
};


export type MutationOncallRotationDestroyArgs = {
  input: OncallRotationDestroyInput;
};


export type MutationOncallRotationUpdateArgs = {
  input: OncallRotationUpdateInput;
};


export type MutationOncallScheduleCreateArgs = {
  input: OncallScheduleCreateInput;
};


export type MutationOncallScheduleDestroyArgs = {
  input: OncallScheduleDestroyInput;
};


export type MutationOncallScheduleUpdateArgs = {
  input: OncallScheduleUpdateInput;
};


export type MutationPagesMarkOnboardingCompleteArgs = {
  input: PagesMarkOnboardingCompleteInput;
};


export type MutationPipelineCancelArgs = {
  input: PipelineCancelInput;
};


export type MutationPipelineDestroyArgs = {
  input: PipelineDestroyInput;
};


export type MutationPipelineRetryArgs = {
  input: PipelineRetryInput;
};


export type MutationPipelineScheduleDeleteArgs = {
  input: PipelineScheduleDeleteInput;
};


export type MutationPipelineScheduleTakeOwnershipArgs = {
  input: PipelineScheduleTakeOwnershipInput;
};


export type MutationProjectCiCdSettingsUpdateArgs = {
  input: ProjectCiCdSettingsUpdateInput;
};


export type MutationProjectSetComplianceFrameworkArgs = {
  input: ProjectSetComplianceFrameworkInput;
};


export type MutationProjectSetLockedArgs = {
  input: ProjectSetLockedInput;
};


export type MutationPrometheusIntegrationCreateArgs = {
  input: PrometheusIntegrationCreateInput;
};


export type MutationPrometheusIntegrationResetTokenArgs = {
  input: PrometheusIntegrationResetTokenInput;
};


export type MutationPrometheusIntegrationUpdateArgs = {
  input: PrometheusIntegrationUpdateInput;
};


export type MutationPromoteToEpicArgs = {
  input: PromoteToEpicInput;
};


export type MutationReleaseAssetLinkCreateArgs = {
  input: ReleaseAssetLinkCreateInput;
};


export type MutationReleaseAssetLinkDeleteArgs = {
  input: ReleaseAssetLinkDeleteInput;
};


export type MutationReleaseAssetLinkUpdateArgs = {
  input: ReleaseAssetLinkUpdateInput;
};


export type MutationReleaseCreateArgs = {
  input: ReleaseCreateInput;
};


export type MutationReleaseDeleteArgs = {
  input: ReleaseDeleteInput;
};


export type MutationReleaseUpdateArgs = {
  input: ReleaseUpdateInput;
};


export type MutationRemoveProjectFromSecurityDashboardArgs = {
  input: RemoveProjectFromSecurityDashboardInput;
};


export type MutationRepositionImageDiffNoteArgs = {
  input: RepositionImageDiffNoteInput;
};


export type MutationRunnerDeleteArgs = {
  input: RunnerDeleteInput;
};


export type MutationRunnerUpdateArgs = {
  input: RunnerUpdateInput;
};


export type MutationRunnersRegistrationTokenResetArgs = {
  input: RunnersRegistrationTokenResetInput;
};


export type MutationSavedReplyCreateArgs = {
  input: SavedReplyCreateInput;
};


export type MutationSavedReplyDestroyArgs = {
  input: SavedReplyDestroyInput;
};


export type MutationSavedReplyUpdateArgs = {
  input: SavedReplyUpdateInput;
};


export type MutationScanExecutionPolicyCommitArgs = {
  input: ScanExecutionPolicyCommitInput;
};


export type MutationSecurityFindingCreateIssueArgs = {
  input: SecurityFindingCreateIssueInput;
};


export type MutationSecurityFindingDismissArgs = {
  input: SecurityFindingDismissInput;
};


export type MutationSecurityPolicyProjectAssignArgs = {
  input: SecurityPolicyProjectAssignInput;
};


export type MutationSecurityPolicyProjectCreateArgs = {
  input: SecurityPolicyProjectCreateInput;
};


export type MutationSecurityPolicyProjectUnassignArgs = {
  input: SecurityPolicyProjectUnassignInput;
};


export type MutationSecurityTrainingUpdateArgs = {
  input: SecurityTrainingUpdateInput;
};


export type MutationTerraformStateDeleteArgs = {
  input: TerraformStateDeleteInput;
};


export type MutationTerraformStateLockArgs = {
  input: TerraformStateLockInput;
};


export type MutationTerraformStateUnlockArgs = {
  input: TerraformStateUnlockInput;
};


export type MutationTimelineEventCreateArgs = {
  input: TimelineEventCreateInput;
};


export type MutationTimelineEventDestroyArgs = {
  input: TimelineEventDestroyInput;
};


export type MutationTimelineEventPromoteFromNoteArgs = {
  input: TimelineEventPromoteFromNoteInput;
};


export type MutationTimelineEventTagCreateArgs = {
  input: TimelineEventTagCreateInput;
};


export type MutationTimelineEventUpdateArgs = {
  input: TimelineEventUpdateInput;
};


export type MutationTimelogCreateArgs = {
  input: TimelogCreateInput;
};


export type MutationTimelogDeleteArgs = {
  input: TimelogDeleteInput;
};


export type MutationTodoCreateArgs = {
  input: TodoCreateInput;
};


export type MutationTodoMarkDoneArgs = {
  input: TodoMarkDoneInput;
};


export type MutationTodoRestoreArgs = {
  input: TodoRestoreInput;
};


export type MutationTodoRestoreManyArgs = {
  input: TodoRestoreManyInput;
};


export type MutationTodosMarkAllDoneArgs = {
  input: TodosMarkAllDoneInput;
};


export type MutationUpdateAlertStatusArgs = {
  input: UpdateAlertStatusInput;
};


export type MutationUpdateBoardArgs = {
  input: UpdateBoardInput;
};


export type MutationUpdateBoardEpicUserPreferencesArgs = {
  input: UpdateBoardEpicUserPreferencesInput;
};


export type MutationUpdateBoardListArgs = {
  input: UpdateBoardListInput;
};


export type MutationUpdateComplianceFrameworkArgs = {
  input: UpdateComplianceFrameworkInput;
};


export type MutationUpdateContainerExpirationPolicyArgs = {
  input: UpdateContainerExpirationPolicyInput;
};


export type MutationUpdateDependencyProxyImageTtlGroupPolicyArgs = {
  input: UpdateDependencyProxyImageTtlGroupPolicyInput;
};


export type MutationUpdateDependencyProxySettingsArgs = {
  input: UpdateDependencyProxySettingsInput;
};


export type MutationUpdateEpicArgs = {
  input: UpdateEpicInput;
};


export type MutationUpdateEpicBoardListArgs = {
  input: UpdateEpicBoardListInput;
};


export type MutationUpdateImageDiffNoteArgs = {
  input: UpdateImageDiffNoteInput;
};


export type MutationUpdateIssueArgs = {
  input: UpdateIssueInput;
};


export type MutationUpdateIterationArgs = {
  input: UpdateIterationInput;
};


export type MutationUpdateNamespacePackageSettingsArgs = {
  input: UpdateNamespacePackageSettingsInput;
};


export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


export type MutationUpdatePackagesCleanupPolicyArgs = {
  input: UpdatePackagesCleanupPolicyInput;
};


export type MutationUpdateRequirementArgs = {
  input: UpdateRequirementInput;
};


export type MutationUpdateSnippetArgs = {
  input: UpdateSnippetInput;
};


export type MutationUploadDeleteArgs = {
  input: UploadDeleteInput;
};


export type MutationUserCalloutCreateArgs = {
  input: UserCalloutCreateInput;
};


export type MutationUserPreferencesUpdateArgs = {
  input: UserPreferencesUpdateInput;
};


export type MutationVulnerabilityConfirmArgs = {
  input: VulnerabilityConfirmInput;
};


export type MutationVulnerabilityCreateArgs = {
  input: VulnerabilityCreateInput;
};


export type MutationVulnerabilityDismissArgs = {
  input: VulnerabilityDismissInput;
};


export type MutationVulnerabilityExternalIssueLinkCreateArgs = {
  input: VulnerabilityExternalIssueLinkCreateInput;
};


export type MutationVulnerabilityExternalIssueLinkDestroyArgs = {
  input: VulnerabilityExternalIssueLinkDestroyInput;
};


export type MutationVulnerabilityFindingDismissArgs = {
  input: VulnerabilityFindingDismissInput;
};


export type MutationVulnerabilityResolveArgs = {
  input: VulnerabilityResolveInput;
};


export type MutationVulnerabilityRevertToDetectedArgs = {
  input: VulnerabilityRevertToDetectedInput;
};


export type MutationWorkItemCreateArgs = {
  input: WorkItemCreateInput;
};


export type MutationWorkItemCreateFromTaskArgs = {
  input: WorkItemCreateFromTaskInput;
};


export type MutationWorkItemDeleteArgs = {
  input: WorkItemDeleteInput;
};


export type MutationWorkItemDeleteTaskArgs = {
  input: WorkItemDeleteTaskInput;
};


export type MutationWorkItemUpdateArgs = {
  input: WorkItemUpdateInput;
};


export type MutationWorkItemUpdateTaskArgs = {
  input: WorkItemUpdateTaskInput;
};

/** Different toggles for changing mutator behavior */
export enum MutationOperationMode {
  /** Performs a replace operation. */
  Replace = 'REPLACE',
  /** Performs an append operation. */
  Append = 'APPEND',
  /** Performs a removal operation. */
  Remove = 'REMOVE'
}

export type Namespace = {
  __typename?: 'Namespace';
  /** Size limit for repositories in the namespace in bytes. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Includes at least one project where the repository size exceeds the limit. */
  containsLockedProjects: Scalars['Boolean'];
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean'];
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Full name of the namespace. */
  fullName: Scalars['String'];
  /** Full path of the namespace. */
  fullPath: Scalars['ID'];
  /** ID of the namespace. */
  id: Scalars['ID'];
  /** Status of the temporary storage increase. */
  isTemporaryStorageIncreaseEnabled: Scalars['Boolean'];
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Name of the namespace. */
  name: Scalars['String'];
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** Path of the namespace. */
  path: Scalars['String'];
  /** Projects within this namespace. */
  projects: ProjectConnection;
  /** Number of projects in the root namespace where the repository size exceeds the limit. */
  repositorySizeExcessProjectCount: Scalars['Int'];
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /** Total storage limit of the root namespace in bytes. */
  storageSizeLimit?: Maybe<Scalars['Float']>;
  /** Date until the temporary storage increase is active. */
  temporaryStorageIncreaseEndsOn?: Maybe<Scalars['Time']>;
  /**
   * Timelog categories for the namespace. Introduced in 15.3: This feature is in
   * Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']>;
  /** Total excess repository size of all projects in the root namespace in bytes. */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']>;
};


export type NamespaceComplianceFrameworksArgs = {
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceProjectsArgs = {
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceScanResultPoliciesArgs = {
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type NamespaceBan = {
  __typename?: 'NamespaceBan';
  /** Global ID of the namespace ban. */
  id: Scalars['GlobalID'];
  /** Root namespace to which the ban applies. */
  namespace: Namespace;
  /** User to which the namespace ban applies. */
  user: UserCore;
};

/** Autogenerated input type of NamespaceBanDestroy */
export type NamespaceBanDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the namespace ban to remove. */
  id: Scalars['NamespacesNamespaceBanID'];
};

/** Autogenerated return type of NamespaceBanDestroy */
export type NamespaceBanDestroyPayload = {
  __typename?: 'NamespaceBanDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace Ban. */
  namespaceBan?: Maybe<NamespaceBan>;
};

export type NamespaceCiCdSetting = {
  __typename?: 'NamespaceCiCdSetting';
  /** Indicates if stale runners directly belonging to this namespace should be periodically pruned. */
  allowStaleRunnerPruning?: Maybe<Scalars['Boolean']>;
  /** Namespace the CI/CD settings belong to. */
  namespace?: Maybe<Namespace>;
};

/** Autogenerated input type of NamespaceCiCdSettingsUpdate */
export type NamespaceCiCdSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates if stale runners directly belonging to this namespace should be periodically pruned. */
  allowStaleRunnerPruning?: InputMaybe<Scalars['Boolean']>;
  /** Full path of the namespace the settings belong to. */
  fullPath: Scalars['ID'];
};

/** Autogenerated return type of NamespaceCiCdSettingsUpdate */
export type NamespaceCiCdSettingsUpdatePayload = {
  __typename?: 'NamespaceCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: NamespaceCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for Namespace. */
export type NamespaceConnection = {
  __typename?: 'NamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Namespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NamespaceEdge = {
  __typename?: 'NamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Namespace>;
};

/** Autogenerated input type of NamespaceIncreaseStorageTemporarily */
export type NamespaceIncreaseStorageTemporarilyInput = {
  /** Global ID of the namespace to mutate. */
  id: Scalars['NamespaceID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of NamespaceIncreaseStorageTemporarily */
export type NamespaceIncreaseStorageTemporarilyPayload = {
  __typename?: 'NamespaceIncreaseStorageTemporarilyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace after mutation. */
  namespace?: Maybe<Namespace>;
};

/** Values for sorting projects */
export enum NamespaceProjectSort {
  /** Most similar to the search query. */
  Similarity = 'SIMILARITY',
  /** Sort by storage size. */
  Storage = 'STORAGE'
}

export type NegatedBoardIssueInput = {
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by epic ID. Incompatible with epicWildcardId. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']>>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<NegatedIterationWildcardId>;
};

export type NegatedEpicBoardIssueInput = {
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
};

export type NegatedEpicFilterInput = {
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
};

export type NegatedIssueFilterInput = {
  /** ID of a user not assigned to the issues. */
  assigneeId?: InputMaybe<Scalars['String']>;
  /** Usernames of users not assigned to the issue. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  /** Username of a user who didn't author the issue. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** List of IIDs of issues to exclude. For example, `[1, 2]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** Labels not applied to this issue. */
  labelName?: InputMaybe<Array<Scalars['String']>>;
  /** Milestone not applied to this issue. */
  milestoneTitle?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by negated milestone wildcard values. */
  milestoneWildcardId?: InputMaybe<NegatedMilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** Release tag not associated with the issue's milestone. Ignored when parent is a group. */
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  /** Filters out issues by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** ID of an epic not associated with the issues. */
  epicId?: InputMaybe<Scalars['String']>;
  /** Weight not applied to the issue. */
  weight?: InputMaybe<Scalars['String']>;
  /** List of iteration Global IDs not applied to the issue. */
  iterationId?: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by negated iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
};

/** Negated Iteration ID wildcard values */
export enum NegatedIterationWildcardId {
  /** Current iteration. */
  Current = 'CURRENT'
}

/** Negated Milestone ID wildcard values */
export enum NegatedMilestoneWildcardId {
  /** Milestone assigned is open and yet to be started (start date > today). */
  Started = 'STARTED',
  /** Milestone assigned is open but due in the past (due date <= today). */
  Upcoming = 'UPCOMING'
}

/** Represents the network policy */
export type NetworkPolicy = {
  __typename?: 'NetworkPolicy';
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Environments where this policy is applied. */
  environments?: Maybe<EnvironmentConnection>;
  /** Indicates whether this policy is created from AutoDevops. */
  fromAutoDevops: Scalars['Boolean'];
  /** Kind of the policy. */
  kind: NetworkPolicyKind;
  /** Name of the policy. */
  name: Scalars['String'];
  /** Namespace of the policy. */
  namespace: Scalars['String'];
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};


/** Represents the network policy */
export type NetworkPolicyEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for NetworkPolicy. */
export type NetworkPolicyConnection = {
  __typename?: 'NetworkPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NetworkPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NetworkPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NetworkPolicyEdge = {
  __typename?: 'NetworkPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NetworkPolicy>;
};

/** Kind of the network policy */
export enum NetworkPolicyKind {
  /** Policy kind of Cilium Network Policy. */
  CiliumNetworkPolicy = 'CiliumNetworkPolicy',
  /** Policy kind of Network Policy. */
  NetworkPolicy = 'NetworkPolicy'
}

export type Note = ResolvableInterface & {
  __typename?: 'Note';
  /** User who wrote this note. */
  author: UserCore;
  /** Content of the note. */
  body: Scalars['String'];
  /** The GitLab Flavored Markdown rendering of `note` */
  bodyHtml?: Maybe<Scalars['String']>;
  /**
   * Indicates if this note is confidential. Deprecated in 15.5: This was renamed.
   * @deprecated This was renamed. Please use `internal`. Deprecated in 15.5.
   */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of the note creation. */
  createdAt: Scalars['Time'];
  /** Discussion this note is a part of. */
  discussion?: Maybe<Discussion>;
  /** ID of the note. */
  id: Scalars['NoteID'];
  /** Indicates if this note is internal. */
  internal?: Maybe<Scalars['Boolean']>;
  /** Position of this note on a diff. */
  position?: Maybe<DiffPosition>;
  /** Project associated with the note. */
  project?: Maybe<Project>;
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether this note was created by the system or by a user. */
  system: Scalars['Boolean'];
  /** Name of the icon corresponding to a system note. */
  systemNoteIconName?: Maybe<Scalars['String']>;
  /** Timestamp of the note's last activity. */
  updatedAt: Scalars['Time'];
  /** URL to view this Note in the Web UI. */
  url?: Maybe<Scalars['String']>;
  /** Permissions for the current user on the resource */
  userPermissions: NotePermissions;
};

export type NoteableInterface = {
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** All notes on this noteable. */
  notes: NoteConnection;
};


export type NoteableInterfaceDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NoteableInterfaceNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an object that supports notes. */
export type NoteableType = Design | Issue | MergeRequest;

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Note>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

export type NotePermissions = {
  __typename?: 'NotePermissions';
  /** Indicates the user can perform `admin_note` on this resource */
  adminNote: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `read_note` on this resource */
  readNote: Scalars['Boolean'];
  /** Indicates the user can perform `reposition_note` on this resource */
  repositionNote: Scalars['Boolean'];
  /** Indicates the user can perform `resolve_note` on this resource */
  resolveNote: Scalars['Boolean'];
};

/** Nuget dependency link metadata */
export type NugetDependencyLinkMetadata = {
  __typename?: 'NugetDependencyLinkMetadata';
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetDependencyLinkMetadatumID'];
  /** Target framework of the dependency link package. */
  targetFramework: Scalars['String'];
};

/** Nuget metadata */
export type NugetMetadata = {
  __typename?: 'NugetMetadata';
  /** Icon URL of the Nuget package. */
  iconUrl?: Maybe<Scalars['String']>;
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetMetadatumID'];
  /** License URL of the Nuget package. */
  licenseUrl?: Maybe<Scalars['String']>;
  /** Project URL of the Nuget package. */
  projectUrl?: Maybe<Scalars['String']>;
};

/** The rotation participant and color palette */
export type OncallParticipantType = {
  __typename?: 'OncallParticipantType';
  /** Color palette to assign to the on-call user. For example "blue". */
  colorPalette?: Maybe<Scalars['String']>;
  /** Color weight to assign to for the on-call user, for example "500". Max 4 chars. For easy identification of the user. */
  colorWeight?: Maybe<Scalars['String']>;
  /** ID of the on-call participant. */
  id: Scalars['IncidentManagementOncallParticipantID'];
  /** User who is participating. */
  user: UserCore;
};

/** The connection type for OncallParticipantType. */
export type OncallParticipantTypeConnection = {
  __typename?: 'OncallParticipantTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OncallParticipantTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OncallParticipantType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OncallParticipantTypeEdge = {
  __typename?: 'OncallParticipantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<OncallParticipantType>;
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodInputType = {
  /** Start of the rotation active period in 24 hour format. For example, "18:30". */
  startTime: Scalars['String'];
  /** End of the rotation active period in 24 hour format. For example, "18:30". */
  endTime: Scalars['String'];
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodType = {
  __typename?: 'OncallRotationActivePeriodType';
  /** End of the rotation active period. */
  endTime?: Maybe<Scalars['String']>;
  /** Start of the rotation active period. */
  startTime?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of OncallRotationCreate */
export type OncallRotationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** IID of the on-call schedule to create the on-call rotation in. */
  scheduleIid: Scalars['String'];
  /** Name of the on-call rotation. */
  name: Scalars['String'];
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt: OncallRotationDateInputType;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** Rotation length of the on-call rotation. */
  rotationLength: OncallRotationLengthInputType;
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants: Array<OncallUserInputType>;
};

/** Autogenerated return type of OncallRotationCreate */
export type OncallRotationCreatePayload = {
  __typename?: 'OncallRotationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Date input type for on-call rotation */
export type OncallRotationDateInputType = {
  /** Date component of the date in YYYY-MM-DD format. */
  date: Scalars['String'];
  /** Time component of the date in 24hr HH:MM format. */
  time: Scalars['String'];
};

/** Autogenerated input type of OncallRotationDestroy */
export type OncallRotationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID'];
  /** IID of the on-call schedule to the on-call rotation belongs to. */
  scheduleIid: Scalars['String'];
  /** ID of the on-call rotation to remove. */
  id: Scalars['IncidentManagementOncallRotationID'];
};

/** Autogenerated return type of OncallRotationDestroy */
export type OncallRotationDestroyPayload = {
  __typename?: 'OncallRotationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** The rotation length of the on-call rotation */
export type OncallRotationLengthInputType = {
  /** Rotation length of the on-call rotation. */
  length: Scalars['Int'];
  /** Unit of the rotation length of the on-call rotation. */
  unit: OncallRotationUnitEnum;
};

/** Rotation length unit of an on-call rotation */
export enum OncallRotationUnitEnum {
  /** Hours */
  Hours = 'HOURS',
  /** Days */
  Days = 'DAYS',
  /** Weeks */
  Weeks = 'WEEKS'
}

/** Autogenerated input type of OncallRotationUpdate */
export type OncallRotationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementOncallRotationID'];
  /** Name of the on-call rotation. */
  name?: InputMaybe<Scalars['String']>;
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt?: InputMaybe<OncallRotationDateInputType>;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** Rotation length of the on-call rotation. */
  rotationLength?: InputMaybe<OncallRotationLengthInputType>;
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants?: InputMaybe<Array<OncallUserInputType>>;
};

/** Autogenerated return type of OncallRotationUpdate */
export type OncallRotationUpdatePayload = {
  __typename?: 'OncallRotationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Autogenerated input type of OncallScheduleCreate */
export type OncallScheduleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** Name of the on-call schedule. */
  name: Scalars['String'];
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']>;
  /** Timezone of the on-call schedule. */
  timezone: Scalars['String'];
};

/** Autogenerated return type of OncallScheduleCreate */
export type OncallScheduleCreatePayload = {
  __typename?: 'OncallScheduleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleDestroy */
export type OncallScheduleDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID'];
  /** On-call schedule internal ID to remove. */
  iid: Scalars['String'];
};

/** Autogenerated return type of OncallScheduleDestroy */
export type OncallScheduleDestroyPayload = {
  __typename?: 'OncallScheduleDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleUpdate */
export type OncallScheduleUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to update the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** On-call schedule internal ID to update. */
  iid: Scalars['String'];
  /** Name of the on-call schedule. */
  name?: InputMaybe<Scalars['String']>;
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']>;
  /** Timezone of the on-call schedule. */
  timezone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of OncallScheduleUpdate */
export type OncallScheduleUpdatePayload = {
  __typename?: 'OncallScheduleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** The rotation user and color palette */
export type OncallUserInputType = {
  /** Username of the user to participate in the on-call rotation. For example, `"user_one"`. */
  username: Scalars['String'];
  /** Value of DataVisualizationColorEnum. The color from the palette to assign to the on-call user. */
  colorPalette?: InputMaybe<DataVisualizationColorEnum>;
  /**
   * Color weight to assign to for the on-call user. To view on-call schedules in
   * GitLab, do not provide a value below 500. A value between 500 and 950 ensures
   * sufficient contrast.
   */
  colorWeight?: InputMaybe<DataVisualizationWeightEnum>;
};

export type OrchestrationPolicy = {
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Name of the policy. */
  name: Scalars['String'];
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** Values for sorting organizations */
export enum OrganizationSort {
  /** Name in ascending order. */
  NameAsc = 'NAME_ASC',
  /** Name in descending order. */
  NameDesc = 'NAME_DESC',
  /** Description in ascending order. */
  DescriptionAsc = 'DESCRIPTION_ASC',
  /** Description in descending order. */
  DescriptionDesc = 'DESCRIPTION_DESC',
  /** Default Rate in ascending order. */
  DefaultRateAsc = 'DEFAULT_RATE_ASC',
  /** Default Rate in descending order. */
  DefaultRateDesc = 'DEFAULT_RATE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Represents the total number of organizations for the represented states. */
export type OrganizationStateCounts = {
  __typename?: 'OrganizationStateCounts';
  /** Number of organizations with state `ACTIVE` */
  active?: Maybe<Scalars['Int']>;
  /** Number of organizations with state `ALL` */
  all?: Maybe<Scalars['Int']>;
  /** Number of organizations with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']>;
};

/** Represents a package with pipelines in the Package Registry */
export type Package = {
  __typename?: 'Package';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Pipelines that built the package. Max page size 20. */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
};


/** Represents a package with pipelines in the Package Registry */
export type PackagePipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package with pipelines in the Package Registry */
export type PackageTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents a package in the Package Registry */
export type PackageBase = {
  __typename?: 'PackageBase';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Project where the package is stored. */
  project: Project;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
};


/** Represents a package in the Package Registry */
export type PackageBaseTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PackageBase. */
export type PackageBaseConnection = {
  __typename?: 'PackageBaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageBaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageBase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageBaseEdge = {
  __typename?: 'PackageBaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageBase>;
};

/** Represents a composer JSON file */
export type PackageComposerJsonType = {
  __typename?: 'PackageComposerJsonType';
  /** License set in the Composer JSON file. */
  license?: Maybe<Scalars['String']>;
  /** Name set in the Composer JSON file. */
  name?: Maybe<Scalars['String']>;
  /** Type set in the Composer JSON file. */
  type?: Maybe<Scalars['String']>;
  /** Version set in the Composer JSON file. */
  version?: Maybe<Scalars['String']>;
};

/** The connection type for Package. */
export type PackageConnection = {
  __typename?: 'PackageConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a package dependency. */
export type PackageDependency = {
  __typename?: 'PackageDependency';
  /** ID of the dependency. */
  id: Scalars['PackagesDependencyID'];
  /** Name of the dependency. */
  name: Scalars['String'];
  /** Version pattern of the dependency. */
  versionPattern: Scalars['String'];
};

/** Represents a package dependency link */
export type PackageDependencyLink = {
  __typename?: 'PackageDependencyLink';
  /** Dependency. */
  dependency?: Maybe<PackageDependency>;
  /** Dependency type. */
  dependencyType: PackageDependencyType;
  /** ID of the dependency link. */
  id: Scalars['PackagesDependencyLinkID'];
  /** Dependency link metadata. */
  metadata?: Maybe<DependencyLinkMetadata>;
};

/** The connection type for PackageDependencyLink. */
export type PackageDependencyLinkConnection = {
  __typename?: 'PackageDependencyLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageDependencyLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageDependencyLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageDependencyLinkEdge = {
  __typename?: 'PackageDependencyLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageDependencyLink>;
};

export enum PackageDependencyType {
  /** dependencies dependency type */
  Dependencies = 'DEPENDENCIES',
  /** devDependencies dependency type */
  DevDependencies = 'DEV_DEPENDENCIES',
  /** bundleDependencies dependency type */
  BundleDependencies = 'BUNDLE_DEPENDENCIES',
  /** peerDependencies dependency type */
  PeerDependencies = 'PEER_DEPENDENCIES'
}

/** Represents a package details in the Package Registry */
export type PackageDetailsType = {
  __typename?: 'PackageDetailsType';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Url of the Composer setup endpoint. */
  composerConfigRepositoryUrl?: Maybe<Scalars['String']>;
  /** Url of the Composer endpoint. */
  composerUrl?: Maybe<Scalars['String']>;
  /** Url of the Conan project endpoint. */
  conanUrl?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Dependency link. */
  dependencyLinks?: Maybe<PackageDependencyLinkConnection>;
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Last time that a file of this package was downloaded. */
  lastDownloadedAt?: Maybe<Scalars['Time']>;
  /** Url of the Maven project endpoint. */
  mavenUrl?: Maybe<Scalars['String']>;
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Url of the NPM project endpoint. */
  npmUrl?: Maybe<Scalars['String']>;
  /** Url of the Nuget project endpoint. */
  nugetUrl?: Maybe<Scalars['String']>;
  /** Package files. */
  packageFiles?: Maybe<PackageFileConnection>;
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Pipelines that built the package. Max page size 20. */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Url of the PyPi project setup endpoint. */
  pypiSetupUrl?: Maybe<Scalars['String']>;
  /** Url of the PyPi project endpoint. */
  pypiUrl?: Maybe<Scalars['String']>;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
  /** Other versions of the package. */
  versions?: Maybe<PackageBaseConnection>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeDependencyLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePackageFilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type PackageEdge = {
  __typename?: 'PackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Package>;
};

/** Represents a package file */
export type PackageFile = {
  __typename?: 'PackageFile';
  /** Created date. */
  createdAt: Scalars['Time'];
  /** Download path of the package file. */
  downloadPath: Scalars['String'];
  /** Md5 of the package file. */
  fileMd5?: Maybe<Scalars['String']>;
  /** File metadata. */
  fileMetadata?: Maybe<PackageFileMetadata>;
  /** Name of the package file. */
  fileName: Scalars['String'];
  /** Sha1 of the package file. */
  fileSha1?: Maybe<Scalars['String']>;
  /** Sha256 of the package file. */
  fileSha256?: Maybe<Scalars['String']>;
  /** ID of the file. */
  id: Scalars['PackagesPackageFileID'];
  /** Size of the package file. */
  size: Scalars['String'];
  /** Updated date. */
  updatedAt: Scalars['Time'];
};

/** The connection type for PackageFile. */
export type PackageFileConnection = {
  __typename?: 'PackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageFileEdge = {
  __typename?: 'PackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFile>;
};

/** Represents metadata associated with a Package file */
export type PackageFileMetadata = {
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Represents the Geo sync and verification state of a package file */
export type PackageFileRegistry = {
  __typename?: 'PackageFileRegistry';
  /** Timestamp when the PackageFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PackageFileRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PackageFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PackageFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the PackageFile. */
  packageFileId: Scalars['ID'];
  /** Timestamp after which the PackageFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PackageFileRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PackageFileRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PackageFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PackageFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PackageFileRegistry. */
export type PackageFileRegistryConnection = {
  __typename?: 'PackageFileRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageFileRegistryEdge = {
  __typename?: 'PackageFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFileRegistry>;
};

/** Values for sorting group packages */
export enum PackageGroupSort {
  /** Ordered by project path in descending order. */
  ProjectPathDesc = 'PROJECT_PATH_DESC',
  /** Ordered by project path in ascending order. */
  ProjectPathAsc = 'PROJECT_PATH_ASC',
  /** Ordered by created_at in descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Ordered by created_at in ascending order. */
  CreatedAsc = 'CREATED_ASC',
  /** Ordered by name in descending order. */
  NameDesc = 'NAME_DESC',
  /** Ordered by name in ascending order. */
  NameAsc = 'NAME_ASC',
  /** Ordered by version in descending order. */
  VersionDesc = 'VERSION_DESC',
  /** Ordered by version in ascending order. */
  VersionAsc = 'VERSION_ASC',
  /** Ordered by type in descending order. */
  TypeDesc = 'TYPE_DESC',
  /** Ordered by type in ascending order. */
  TypeAsc = 'TYPE_ASC'
}

/** Represents a Helm dependency */
export type PackageHelmDependencyType = {
  __typename?: 'PackageHelmDependencyType';
  /** Alias of the dependency. */
  alias?: Maybe<Scalars['String']>;
  /** Condition of the dependency. */
  condition?: Maybe<Scalars['String']>;
  /** Indicates the dependency is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Import-values of the dependency. */
  importValues?: Maybe<Array<Scalars['JSON']>>;
  /** Name of the dependency. */
  name?: Maybe<Scalars['String']>;
  /** Repository of the dependency. */
  repository?: Maybe<Scalars['String']>;
  /** Tags of the dependency. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** Version of the dependency. */
  version?: Maybe<Scalars['String']>;
};

/** Represents a Helm maintainer */
export type PackageHelmMaintainerType = {
  __typename?: 'PackageHelmMaintainerType';
  /** Email of the maintainer. */
  email?: Maybe<Scalars['String']>;
  /** Name of the maintainer. */
  name?: Maybe<Scalars['String']>;
  /** URL of the maintainer. */
  url?: Maybe<Scalars['String']>;
};

/** Represents the contents of a Helm Chart.yml file */
export type PackageHelmMetadataType = {
  __typename?: 'PackageHelmMetadataType';
  /** Annotations for the chart. */
  annotations?: Maybe<Scalars['JSON']>;
  /** API version of the chart. */
  apiVersion: Scalars['String'];
  /** App version of the chart. */
  appVersion?: Maybe<Scalars['String']>;
  /** Condition for the chart. */
  condition?: Maybe<Scalars['String']>;
  /** Dependencies of the chart. */
  dependencies?: Maybe<Array<PackageHelmDependencyType>>;
  /** Indicates if the chart is deprecated. */
  deprecated?: Maybe<Scalars['Boolean']>;
  /** Description of the chart. */
  description?: Maybe<Scalars['String']>;
  /** URL of the home page. */
  home?: Maybe<Scalars['String']>;
  /** URL to an SVG or PNG image for the chart. */
  icon?: Maybe<Scalars['String']>;
  /** Keywords for the chart. */
  keywords?: Maybe<Array<Scalars['String']>>;
  /** Kubernetes versions for the chart. */
  kubeVersion?: Maybe<Scalars['String']>;
  /** Maintainers of the chart. */
  maintainers?: Maybe<Array<PackageHelmMaintainerType>>;
  /** Name of the chart. */
  name: Scalars['String'];
  /** URLs of the source code for the chart. */
  sources?: Maybe<Array<Scalars['String']>>;
  /** Tags for the chart. */
  tags?: Maybe<Scalars['String']>;
  /** Type of the chart. */
  type?: Maybe<Scalars['String']>;
  /** Version of the chart. */
  version: Scalars['String'];
};

/** Represents links to perform actions on the package */
export type PackageLinks = {
  __typename?: 'PackageLinks';
  /** Path to the package details page. */
  webPath?: Maybe<Scalars['String']>;
};

/** Represents metadata associated with a Package */
export type PackageMetadata = ComposerMetadata | ConanMetadata | MavenMetadata | NugetMetadata | PypiMetadata;

export enum PackagesCleanupKeepDuplicatedPackageFilesEnum {
  /** Value to keep all package files */
  AllPackageFiles = 'ALL_PACKAGE_FILES',
  /** Value to keep 1 package files */
  OnePackageFile = 'ONE_PACKAGE_FILE',
  /** Value to keep 10 package files */
  TenPackageFiles = 'TEN_PACKAGE_FILES',
  /** Value to keep 20 package files */
  TwentyPackageFiles = 'TWENTY_PACKAGE_FILES',
  /** Value to keep 30 package files */
  ThirtyPackageFiles = 'THIRTY_PACKAGE_FILES',
  /** Value to keep 40 package files */
  FortyPackageFiles = 'FORTY_PACKAGE_FILES',
  /** Value to keep 50 package files */
  FiftyPackageFiles = 'FIFTY_PACKAGE_FILES'
}

/** A packages cleanup policy designed to keep only packages and packages assets that matter most */
export type PackagesCleanupPolicy = {
  __typename?: 'PackagesCleanupPolicy';
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum;
  /** Next time that this packages cleanup policy will be executed. */
  nextRunAt?: Maybe<Scalars['Time']>;
};

/** Namespace-level Package Registry settings */
export type PackageSettings = {
  __typename?: 'PackageSettings';
  /**
   * When generic_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  genericDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate generic packages are allowed for this namespace. */
  genericDuplicatesAllowed: Scalars['Boolean'];
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding: Scalars['Boolean'];
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding: Scalars['Boolean'];
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding: Scalars['Boolean'];
  /**
   * When maven_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  mavenDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate Maven packages are allowed for this namespace. */
  mavenDuplicatesAllowed: Scalars['Boolean'];
  /** Indicates whether Maven package forwarding is allowed for this namespace. */
  mavenPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether Maven package forwarding settings are locked by a parent namespace. */
  mavenPackageRequestsForwardingLocked: Scalars['Boolean'];
  /** Indicates whether npm package forwarding is allowed for this namespace. */
  npmPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether npm package forwarding settings are locked by a parent namespace. */
  npmPackageRequestsForwardingLocked: Scalars['Boolean'];
  /** Indicates whether PyPI package forwarding is allowed for this namespace. */
  pypiPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding settings are locked by a parent namespace. */
  pypiPackageRequestsForwardingLocked: Scalars['Boolean'];
};

/** Values for sorting package */
export enum PackageSort {
  /** Ordered by created_at in descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Ordered by created_at in ascending order. */
  CreatedAsc = 'CREATED_ASC',
  /** Ordered by name in descending order. */
  NameDesc = 'NAME_DESC',
  /** Ordered by name in ascending order. */
  NameAsc = 'NAME_ASC',
  /** Ordered by version in descending order. */
  VersionDesc = 'VERSION_DESC',
  /** Ordered by version in ascending order. */
  VersionAsc = 'VERSION_ASC',
  /** Ordered by type in descending order. */
  TypeDesc = 'TYPE_DESC',
  /** Ordered by type in ascending order. */
  TypeAsc = 'TYPE_ASC'
}

export enum PackageStatus {
  /** Packages with a default status */
  Default = 'DEFAULT',
  /** Packages with a hidden status */
  Hidden = 'HIDDEN',
  /** Packages with a processing status */
  Processing = 'PROCESSING',
  /** Packages with a error status */
  Error = 'ERROR',
  /** Packages with a pending_destruction status */
  PendingDestruction = 'PENDING_DESTRUCTION'
}

/** Represents a package tag */
export type PackageTag = {
  __typename?: 'PackageTag';
  /** Created date. */
  createdAt: Scalars['Time'];
  /** ID of the tag. */
  id: Scalars['ID'];
  /** Name of the tag. */
  name: Scalars['String'];
  /** Updated date. */
  updatedAt: Scalars['Time'];
};

/** The connection type for PackageTag. */
export type PackageTagConnection = {
  __typename?: 'PackageTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageTagEdge = {
  __typename?: 'PackageTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageTag>;
};

export enum PackageTypeEnum {
  /** Packages from the Maven package manager */
  Maven = 'MAVEN',
  /** Packages from the npm package manager */
  Npm = 'NPM',
  /** Packages from the Conan package manager */
  Conan = 'CONAN',
  /** Packages from the Nuget package manager */
  Nuget = 'NUGET',
  /** Packages from the PyPI package manager */
  Pypi = 'PYPI',
  /** Packages from the Composer package manager */
  Composer = 'COMPOSER',
  /** Packages from the Generic package manager */
  Generic = 'GENERIC',
  /** Packages from the Golang package manager */
  Golang = 'GOLANG',
  /** Packages from the Debian package manager */
  Debian = 'DEBIAN',
  /** Packages from the Rubygems package manager */
  Rubygems = 'RUBYGEMS',
  /** Packages from the Helm package manager */
  Helm = 'HELM',
  /** Packages from the Terraform Module package manager */
  TerraformModule = 'TERRAFORM_MODULE',
  /** Packages from the Rpm package manager */
  Rpm = 'RPM'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Represents the Geo replication and verification state of a pages_deployment */
export type PagesDeploymentRegistry = {
  __typename?: 'PagesDeploymentRegistry';
  /** Timestamp when the PagesDeploymentRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PagesDeploymentRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PagesDeploymentRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PagesDeploymentRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the Pages Deployment. */
  pagesDeploymentId: Scalars['ID'];
  /** Timestamp after which the PagesDeploymentRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PagesDeploymentRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PagesDeploymentRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PagesDeploymentRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PagesDeploymentRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PagesDeploymentRegistry. */
export type PagesDeploymentRegistryConnection = {
  __typename?: 'PagesDeploymentRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PagesDeploymentRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PagesDeploymentRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PagesDeploymentRegistryEdge = {
  __typename?: 'PagesDeploymentRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PagesDeploymentRegistry>;
};

/** Autogenerated input type of PagesMarkOnboardingComplete */
export type PagesMarkOnboardingCompleteInput = {
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PagesMarkOnboardingComplete */
export type PagesMarkOnboardingCompletePayload = {
  __typename?: 'PagesMarkOnboardingCompletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Indicates the new onboarding_complete state of the project's Pages metadata. */
  onboardingComplete: Scalars['Boolean'];
};

/** Represents a file or directory in the project repository that has been locked. */
export type PathLock = {
  __typename?: 'PathLock';
  /** ID of the path lock. */
  id: Scalars['PathLockID'];
  /** Locked path. */
  path?: Maybe<Scalars['String']>;
  /** User that has locked this path. */
  user?: Maybe<UserCore>;
};

/** The connection type for PathLock. */
export type PathLockConnection = {
  __typename?: 'PathLockConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PathLockEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PathLock>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PathLockEdge = {
  __typename?: 'PathLockEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PathLock>;
};

export type Pipeline = {
  __typename?: 'Pipeline';
  /** Indicates if the pipeline is active. */
  active: Scalars['Boolean'];
  /** Base SHA of the source branch. */
  beforeSha?: Maybe<Scalars['String']>;
  /** Specifies if a pipeline can be canceled. */
  cancelable: Scalars['Boolean'];
  /** Code Quality degradations reported on the pipeline. */
  codeQualityReports?: Maybe<CodeQualityDegradationConnection>;
  /** Git commit of the pipeline. */
  commit?: Maybe<Commit>;
  /** Path to the commit that triggered the pipeline. */
  commitPath?: Maybe<Scalars['String']>;
  /** Timestamp of the pipeline's commit. */
  committedAt?: Maybe<Scalars['Time']>;
  /** Indicates if a pipeline is complete. */
  complete: Scalars['Boolean'];
  /**
   * Configuration source of the pipeline (UNKNOWN_SOURCE, REPOSITORY_SOURCE,
   * AUTO_DEVOPS_SOURCE, WEBIDE_SOURCE, REMOTE_SOURCE, EXTERNAL_PROJECT_SOURCE,
   * BRIDGE_SOURCE, PARAMETER_SOURCE, COMPLIANCE_SOURCE)
   */
  configSource?: Maybe<PipelineConfigSourceEnum>;
  /** Coverage percentage. */
  coverage?: Maybe<Scalars['Float']>;
  /** Timestamp of the pipeline's creation. */
  createdAt: Scalars['Time'];
  /** DAST profile associated with the pipeline. */
  dastProfile?: Maybe<DastProfile>;
  /** Detailed status of the pipeline. */
  detailedStatus: DetailedStatus;
  /** Pipelines this pipeline will trigger. */
  downstream?: Maybe<PipelineConnection>;
  /** Duration of the pipeline in seconds. */
  duration?: Maybe<Scalars['Int']>;
  /** Timestamp of the pipeline's completion. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** ID of the pipeline. */
  id: Scalars['ID'];
  /** Internal ID of the pipeline. */
  iid: Scalars['String'];
  /** Specific job in this pipeline, either by name or ID. */
  job?: Maybe<CiJob>;
  /** Job artifacts of the pipeline. */
  jobArtifacts?: Maybe<Array<CiJobArtifact>>;
  /** Jobs belonging to the pipeline. */
  jobs?: Maybe<CiJobConnection>;
  /** Event type of the pipeline associated with a merge request. */
  mergeRequestEventType?: Maybe<PipelineMergeRequestEventType>;
  /** Relative path to the pipeline's page. */
  path?: Maybe<Scalars['String']>;
  /** Project the pipeline belongs to. */
  project?: Maybe<Project>;
  /** How long the pipeline was queued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']>;
  /** Reference to the branch from which the pipeline was triggered. */
  ref?: Maybe<Scalars['String']>;
  /** Reference path to the branch from which the pipeline was triggered. */
  refPath?: Maybe<Scalars['String']>;
  /** Specifies if a pipeline can be retried. */
  retryable: Scalars['Boolean'];
  /** Vulnerability finding reported on the pipeline. */
  securityReportFinding?: Maybe<PipelineSecurityReportFinding>;
  /** Vulnerability findings reported on the pipeline. */
  securityReportFindings?: Maybe<PipelineSecurityReportFindingConnection>;
  /** Vulnerability and scanned resource counts for each security scanner of the pipeline. */
  securityReportSummary?: Maybe<SecurityReportSummary>;
  /** SHA of the pipeline's commit. */
  sha?: Maybe<Scalars['String']>;
  /** Job where pipeline was triggered from. */
  sourceJob?: Maybe<CiJob>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiStageConnection>;
  /** Timestamp when the pipeline was started. */
  startedAt?: Maybe<Scalars['Time']>;
  /**
   * Status of the pipeline (CREATED, WAITING_FOR_RESOURCE, PREPARING, PENDING,
   * RUNNING, FAILED, SUCCESS, CANCELED, SKIPPED, MANUAL, SCHEDULED)
   */
  status: PipelineStatusEnum;
  /** Summary of the test report generated by the pipeline. */
  testReportSummary: TestReportSummary;
  /** A specific test suite in a pipeline test report. */
  testSuite?: Maybe<TestSuite>;
  /** Timestamp of the pipeline's last activity. */
  updatedAt: Scalars['Time'];
  /** Pipeline that triggered the pipeline. */
  upstream?: Maybe<Pipeline>;
  /** Pipeline user. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: PipelinePermissions;
  /** Indicates if the pipeline has jobs with `needs` dependencies. */
  usesNeeds?: Maybe<Scalars['Boolean']>;
  /** Pipeline warning messages. */
  warningMessages?: Maybe<Array<PipelineMessage>>;
  /** Indicates if a pipeline has warnings. */
  warnings: Scalars['Boolean'];
};


export type PipelineCodeQualityReportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineDownstreamArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineJobArgs = {
  id?: InputMaybe<Scalars['JobID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type PipelineJobsArgs = {
  securityReportTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
  retried?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineSecurityReportFindingArgs = {
  uuid: Scalars['String'];
};


export type PipelineSecurityReportFindingsArgs = {
  reportType?: InputMaybe<Array<Scalars['String']>>;
  severity?: InputMaybe<Array<Scalars['String']>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineShaArgs = {
  format?: InputMaybe<ShaFormat>;
};


export type PipelineStagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineTestSuiteArgs = {
  buildIds: Array<Scalars['ID']>;
};

export type PipelineAnalytics = {
  __typename?: 'PipelineAnalytics';
  /** Labels for the monthly pipeline count. */
  monthPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total monthly successful pipeline count. */
  monthPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total monthly pipeline count. */
  monthPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
  /** Pipeline times labels. */
  pipelineTimesLabels?: Maybe<Array<Scalars['String']>>;
  /** Pipeline times. */
  pipelineTimesValues?: Maybe<Array<Scalars['Int']>>;
  /** Labels for the weekly pipeline count. */
  weekPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total weekly successful pipeline count. */
  weekPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total weekly pipeline count. */
  weekPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
  /** Labels for the yearly pipeline count. */
  yearPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total yearly successful pipeline count. */
  yearPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total yearly pipeline count. */
  yearPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
};

/** Represents the Geo sync and verification state of a pipeline artifact */
export type PipelineArtifactRegistry = {
  __typename?: 'PipelineArtifactRegistry';
  /** Timestamp when the PipelineArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PipelineArtifactRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PipelineArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PipelineArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the pipeline artifact. */
  pipelineArtifactId: Scalars['ID'];
  /** Timestamp after which the PipelineArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PipelineArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PipelineArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PipelineArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PipelineArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PipelineArtifactRegistry. */
export type PipelineArtifactRegistryConnection = {
  __typename?: 'PipelineArtifactRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineArtifactRegistryEdge = {
  __typename?: 'PipelineArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineArtifactRegistry>;
};

/** Autogenerated input type of PipelineCancel */
export type PipelineCancelInput = {
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PipelineCancel */
export type PipelineCancelPayload = {
  __typename?: 'PipelineCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export enum PipelineConfigSourceEnum {
  /** Unknown source. */
  UnknownSource = 'UNKNOWN_SOURCE',
  /** Repository source. */
  RepositorySource = 'REPOSITORY_SOURCE',
  /** Auto DevOps source. */
  AutoDevopsSource = 'AUTO_DEVOPS_SOURCE',
  /** Webide source. */
  WebideSource = 'WEBIDE_SOURCE',
  /** Remote source. */
  RemoteSource = 'REMOTE_SOURCE',
  /** External project source. */
  ExternalProjectSource = 'EXTERNAL_PROJECT_SOURCE',
  /** Bridge source. */
  BridgeSource = 'BRIDGE_SOURCE',
  /** Parameter source. */
  ParameterSource = 'PARAMETER_SOURCE',
  /** Compliance source. */
  ComplianceSource = 'COMPLIANCE_SOURCE'
}

/** The connection type for Pipeline. */
export type PipelineConnection = {
  __typename?: 'PipelineConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Pipeline>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents pipeline counts for the project */
export type PipelineCounts = {
  __typename?: 'PipelineCounts';
  /** Total number of pipelines for the project. */
  all?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope FINISHED for the project */
  finished?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope PENDING for the project */
  pending?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope RUNNING for the project */
  running?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of PipelineDestroy */
export type PipelineDestroyInput = {
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PipelineDestroy */
export type PipelineDestroyPayload = {
  __typename?: 'PipelineDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type PipelineEdge = {
  __typename?: 'PipelineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Pipeline>;
};

/** Event type of the pipeline associated with a merge request */
export enum PipelineMergeRequestEventType {
  /** Pipeline run on the changes from the source branch combined with the target branch. */
  MergedResult = 'MERGED_RESULT',
  /** Pipeline run on the changes in the merge request source branch. */
  Detached = 'DETACHED',
  /** Pipeline ran as part of a merge train. */
  MergeTrain = 'MERGE_TRAIN'
}

export type PipelineMessage = {
  __typename?: 'PipelineMessage';
  /** Content of the pipeline message. */
  content: Scalars['String'];
  /** ID of the pipeline message. */
  id: Scalars['ID'];
};

export type PipelinePermissions = {
  __typename?: 'PipelinePermissions';
  /** Indicates the user can perform `admin_pipeline` on this resource */
  adminPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_pipeline` on this resource */
  destroyPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `update_pipeline` on this resource */
  updatePipeline: Scalars['Boolean'];
};

/** Autogenerated input type of PipelineRetry */
export type PipelineRetryInput = {
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PipelineRetry */
export type PipelineRetryPayload = {
  __typename?: 'PipelineRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Pipeline after mutation. */
  pipeline?: Maybe<Pipeline>;
};

export type PipelineSchedule = {
  __typename?: 'PipelineSchedule';
  /** Indicates if a pipeline schedule is active. */
  active: Scalars['Boolean'];
  /** Cron notation for the schedule. */
  cron: Scalars['String'];
  /** Timezone for the pipeline schedule. */
  cronTimezone: Scalars['String'];
  /** Description of the pipeline schedule. */
  description?: Maybe<Scalars['String']>;
  /** Indicates if a pipelines schedule belongs to a tag. */
  forTag: Scalars['Boolean'];
  /** ID of the pipeline schedule. */
  id: Scalars['ID'];
  /** Last pipeline object. */
  lastPipeline?: Maybe<Pipeline>;
  /** Time when the next pipeline will run. */
  nextRunAt: Scalars['Time'];
  /** Owner of the pipeline schedule. */
  owner: UserCore;
  /** Time when the next pipeline will run. */
  realNextRun: Scalars['Time'];
  /** Git ref for the pipeline schedule. */
  refForDisplay?: Maybe<Scalars['String']>;
  /** Path to the ref that triggered the pipeline. */
  refPath?: Maybe<Scalars['String']>;
  /** Permissions for the current user on the resource */
  userPermissions: PipelineSchedulePermissions;
};

/** The connection type for PipelineSchedule. */
export type PipelineScheduleConnection = {
  __typename?: 'PipelineScheduleConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of PipelineScheduleDelete */
export type PipelineScheduleDeleteInput = {
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PipelineScheduleDelete */
export type PipelineScheduleDeletePayload = {
  __typename?: 'PipelineScheduleDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type PipelineScheduleEdge = {
  __typename?: 'PipelineScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSchedule>;
};

export type PipelineSchedulePermissions = {
  __typename?: 'PipelineSchedulePermissions';
  /** Indicates the user can perform `admin_pipeline_schedule` on this resource */
  adminPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `play_pipeline_schedule` on this resource */
  playPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `take_ownership_pipeline_schedule` on this resource */
  takeOwnershipPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `update_pipeline_schedule` on this resource */
  updatePipelineSchedule: Scalars['Boolean'];
};

export enum PipelineScheduleStatus {
  /** Active pipeline schedules. */
  Active = 'ACTIVE',
  /** Inactive pipeline schedules. */
  Inactive = 'INACTIVE'
}

/** Autogenerated input type of PipelineScheduleTakeOwnership */
export type PipelineScheduleTakeOwnershipInput = {
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PipelineScheduleTakeOwnership */
export type PipelineScheduleTakeOwnershipPayload = {
  __typename?: 'PipelineScheduleTakeOwnershipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated pipeline schedule ownership. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

export enum PipelineScopeEnum {
  /** Pipeline is running. */
  Running = 'RUNNING',
  /** Pipeline has not started running yet. */
  Pending = 'PENDING',
  /** Pipeline has completed. */
  Finished = 'FINISHED',
  /** Branches. */
  Branches = 'BRANCHES',
  /** Tags. */
  Tags = 'TAGS'
}

/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFinding = {
  __typename?: 'PipelineSecurityReportFinding';
  /** List of assets associated with the vulnerability. */
  assets?: Maybe<Array<AssetType>>;
  /**
   * Type of the security report that found the vulnerability. Deprecated in 15.4:
   * This field will be removed from the Finding domain model.
   * @deprecated This field will be removed from the Finding domain model. Deprecated in 15.4.
   */
  confidence?: Maybe<Scalars['String']>;
  /** Description of the vulnerability finding. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Details of the security finding. */
  details: Array<VulnerabilityDetail>;
  /** Evidence for the vulnerability. */
  evidence?: Maybe<VulnerabilityEvidence>;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']>;
  /** Identifiers of the vulnerability finding. */
  identifiers: Array<VulnerabilityIdentifier>;
  /** List of links associated with the vulnerability. */
  links?: Maybe<Array<VulnerabilityLink>>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /**
   * Name of the vulnerability finding. Deprecated in 15.1: Use `title`.
   * @deprecated Use `title`. Deprecated in 15.1.
   */
  name?: Maybe<Scalars['String']>;
  /** Project on which the vulnerability finding was found. */
  project?: Maybe<Project>;
  /**
   * Name of the vulnerability finding. Deprecated in 15.1: The
   * `project_fingerprint` attribute is being deprecated. Use `uuid` to identify findings.
   * @deprecated The `project_fingerprint` attribute is being deprecated. Use `uuid` to identify findings. Deprecated in 15.1.
   */
  projectFingerprint?: Maybe<Scalars['String']>;
  /** Type of the security report that found the vulnerability finding. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability finding. */
  severity?: Maybe<VulnerabilitySeverity>;
  /** URL to the vulnerability's details page. */
  solution?: Maybe<Scalars['String']>;
  /** Finding status. */
  state?: Maybe<VulnerabilityState>;
  /** Title of the vulnerability finding. */
  title?: Maybe<Scalars['String']>;
  /** Name of the vulnerability finding. */
  uuid?: Maybe<Scalars['String']>;
};

/** The connection type for PipelineSecurityReportFinding. */
export type PipelineSecurityReportFindingConnection = {
  __typename?: 'PipelineSecurityReportFindingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineSecurityReportFindingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSecurityReportFinding>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineSecurityReportFindingEdge = {
  __typename?: 'PipelineSecurityReportFindingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSecurityReportFinding>;
};

export enum PipelineStatusEnum {
  /** Pipeline has been created. */
  Created = 'CREATED',
  /** A resource (for example, a runner) that the pipeline requires to run is unavailable. */
  WaitingForResource = 'WAITING_FOR_RESOURCE',
  /** Pipeline is preparing to run. */
  Preparing = 'PREPARING',
  /** Pipeline has not started running yet. */
  Pending = 'PENDING',
  /** Pipeline is running. */
  Running = 'RUNNING',
  /** At least one stage of the pipeline failed. */
  Failed = 'FAILED',
  /** Pipeline completed successfully. */
  Success = 'SUCCESS',
  /** Pipeline was canceled before completion. */
  Canceled = 'CANCELED',
  /** Pipeline was skipped. */
  Skipped = 'SKIPPED',
  /** Pipeline needs to be manually started. */
  Manual = 'MANUAL',
  /** Pipeline is scheduled to run. */
  Scheduled = 'SCHEDULED'
}

export type PreviewBillableUserChange = {
  __typename?: 'PreviewBillableUserChange';
  /** If the group has an overage after change. */
  hasOverage?: Maybe<Scalars['Boolean']>;
  /** Total number of billable users after change. */
  newBillableUserCount?: Maybe<Scalars['Int']>;
  /** Number of seats in subscription. */
  seatsInSubscription?: Maybe<Scalars['Int']>;
};

/** Represents a product analytics dashboard. */
export type ProductAnalyticsDashboard = {
  __typename?: 'ProductAnalyticsDashboard';
  /** Description of the dashboard. */
  description?: Maybe<Scalars['String']>;
  /** Title of the dashboard. */
  title: Scalars['String'];
  /** Widgets shown on the dashboard. */
  widgets: ProductAnalyticsDashboardWidgetConnection;
};


/** Represents a product analytics dashboard. */
export type ProductAnalyticsDashboardWidgetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProductAnalyticsDashboard. */
export type ProductAnalyticsDashboardConnection = {
  __typename?: 'ProductAnalyticsDashboardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductAnalyticsDashboardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductAnalyticsDashboard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductAnalyticsDashboardEdge = {
  __typename?: 'ProductAnalyticsDashboardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductAnalyticsDashboard>;
};

/** Represents a product analytics dashboard widget. */
export type ProductAnalyticsDashboardWidget = {
  __typename?: 'ProductAnalyticsDashboardWidget';
  /** Description of the position and size of the widget. */
  gridAttributes?: Maybe<Scalars['JSON']>;
  /** Title of the widget. */
  title: Scalars['String'];
};

/** The connection type for ProductAnalyticsDashboardWidget. */
export type ProductAnalyticsDashboardWidgetConnection = {
  __typename?: 'ProductAnalyticsDashboardWidgetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductAnalyticsDashboardWidgetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductAnalyticsDashboardWidget>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductAnalyticsDashboardWidgetEdge = {
  __typename?: 'ProductAnalyticsDashboardWidgetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductAnalyticsDashboardWidget>;
};

export type Project = {
  __typename?: 'Project';
  /** Size limit for the repository in bytes. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Agent configurations defined by the project */
  agentConfigurations?: Maybe<AgentConfigurationConnection>;
  /** A single Alert Management alert of the project. */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Counts of alerts by status for the project. */
  alertManagementAlertStatusCounts?: Maybe<AlertManagementAlertStatusCountsType>;
  /** Alert Management alerts of the project. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** HTTP Integrations which can receive alerts for the project. */
  alertManagementHttpIntegrations?: Maybe<AlertManagementHttpIntegrationConnection>;
  /** Integrations which can receive alerts for the project. */
  alertManagementIntegrations?: Maybe<AlertManagementIntegrationConnection>;
  /** Extract alert fields from payload for custom mapping. */
  alertManagementPayloadFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /**
   * If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge
   * requests of the project can also be merged with skipped jobs.
   */
  allowMergeOnSkippedPipeline?: Maybe<Scalars['Boolean']>;
  /** API fuzzing configuration for the project.  */
  apiFuzzingCiConfiguration?: Maybe<ApiFuzzingCiConfiguration>;
  /** Indicates the archived status of the project. */
  archived?: Maybe<Scalars['Boolean']>;
  /** Indicates if issues referenced by merge requests and commits within the default branch are closed automatically. */
  autocloseReferencedIssues?: Maybe<Scalars['Boolean']>;
  /** URL to avatar image file of the project. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** A single board of the project. */
  board?: Maybe<Board>;
  /** Boards of the project. */
  boards?: Maybe<BoardConnection>;
  /** Branch rules configured for the project. */
  branchRules?: Maybe<BranchRuleConnection>;
  /** CI/CD settings for the project. */
  ciCdSettings?: Maybe<ProjectCiCdSetting>;
  /** Path of the CI configuration file. */
  ciConfigPathOrDefault: Scalars['String'];
  /**
   * CI/CD config variable. Introduced in 15.3: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3.
   */
  ciConfigVariables?: Maybe<Array<CiConfigVariable>>;
  /** The CI Job Tokens scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** Find a single CI/CD template by name. */
  ciTemplate?: Maybe<CiTemplate>;
  /** List of the project's CI/CD variables. */
  ciVariables?: Maybe<CiProjectVariableConnection>;
  /** Find a single cluster agent by name. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Cluster agents associated with the project. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Code coverage summary associated with the project. */
  codeCoverageSummary?: Maybe<CodeCoverageSummary>;
  /** Compliance frameworks associated with the project. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Container expiration policy of the project. */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /** Indicates if Container Registry is enabled for the current user */
  containerRegistryEnabled?: Maybe<Scalars['Boolean']>;
  /** Container repositories of the project. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the project. */
  containerRepositoriesCount: Scalars['Int'];
  /** Find corpuses of the project. */
  corpuses?: Maybe<CoverageFuzzingCorpusConnection>;
  /** Timestamp of the project creation. */
  createdAt?: Maybe<Scalars['Time']>;
  /** DAST Profile associated with the project. */
  dastProfile?: Maybe<DastProfile>;
  /** DAST Profiles associated with the project. */
  dastProfiles?: Maybe<DastProfileConnection>;
  /** DAST scanner profiles associated with the project. */
  dastScannerProfiles?: Maybe<DastScannerProfileConnection>;
  /** DAST Site Profile associated with the project. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** DAST Site Profiles associated with the project. */
  dastSiteProfiles?: Maybe<DastSiteProfileConnection>;
  /** DAST Site Validations associated with the project. */
  dastSiteValidations?: Maybe<DastSiteValidationConnection>;
  /** Details of the deployment of the project. */
  deployment?: Maybe<DeploymentDetails>;
  /** Short description of the project. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Project's DORA metrics. */
  dora?: Maybe<Dora>;
  /** A single environment of the project. */
  environment?: Maybe<Environment>;
  /** Environments of the project. */
  environments?: Maybe<EnvironmentConnection>;
  /** Namespaces in which the current user can fork the project into. */
  forkTargets?: Maybe<NamespaceConnection>;
  /** Number of times the project has been forked. */
  forksCount: Scalars['Int'];
  /** Full path of the project. */
  fullPath: Scalars['ID'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /** Grafana integration details for the project. */
  grafanaIntegration?: Maybe<GrafanaIntegration>;
  /** Group of the project. */
  group?: Maybe<Group>;
  /** URL to connect to the project via HTTPS. */
  httpUrlToRepo?: Maybe<Scalars['String']>;
  /** ID of the project. */
  id: Scalars['ID'];
  /** Status of import background job of the project. */
  importStatus?: Maybe<Scalars['String']>;
  /** Incident Management escalation policies of the project. */
  incidentManagementEscalationPolicies?: Maybe<EscalationPolicyTypeConnection>;
  /** Incident Management escalation policy of the project. */
  incidentManagementEscalationPolicy?: Maybe<EscalationPolicyType>;
  /** Incident Management On-call schedules of the project. */
  incidentManagementOncallSchedules?: Maybe<IncidentManagementOncallScheduleConnection>;
  /** Incident Management Timeline event associated with the incident. */
  incidentManagementTimelineEvent?: Maybe<TimelineEventType>;
  /** Timeline event tags for the project. */
  incidentManagementTimelineEventTags?: Maybe<Array<TimelineEventTagType>>;
  /** Incident Management Timeline events associated with the incident. */
  incidentManagementTimelineEvents?: Maybe<TimelineEventTypeConnection>;
  /** A single issue of the project. */
  issue?: Maybe<Issue>;
  /** Counts of issues by status for the project. */
  issueStatusCounts?: Maybe<IssueStatusCountsType>;
  /** Issues of the project. */
  issues?: Maybe<IssueConnection>;
  /** Indicates if Issues are enabled for the current user */
  issuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Status of Jira import background job of the project. */
  jiraImportStatus?: Maybe<Scalars['String']>;
  /** Jira imports into the project. */
  jiraImports?: Maybe<JiraImportConnection>;
  /** One job belonging to the project, selected by ID. */
  job?: Maybe<CiJob>;
  /** Jobs of a project. This field can only be resolved for one project in any single request. */
  jobs?: Maybe<CiJobConnection>;
  /** Indicates if CI/CD pipeline jobs are enabled for the current user. */
  jobsEnabled?: Maybe<Scalars['Boolean']>;
  /** Label available on this project. */
  label?: Maybe<Label>;
  /** Labels available on this project. */
  labels?: Maybe<LabelConnection>;
  /** Programming languages used in the project. */
  languages?: Maybe<Array<RepositoryLanguage>>;
  /** Timestamp of the project last activity. */
  lastActivityAt?: Maybe<Scalars['Time']>;
  /** Indicates if the project has Large File Storage (LFS) enabled. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Template used to create merge commit message in merge requests. */
  mergeCommitTemplate?: Maybe<Scalars['String']>;
  /** A single merge request of the project. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Merge requests of the project. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Indicates if Merge Requests are enabled for the current user */
  mergeRequestsEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Indicates if no merge commits should be created and all merges should instead
   * be fast-forwarded, which means that merging is only allowed if the branch
   * could be fast-forwarded.
   */
  mergeRequestsFfOnlyEnabled?: Maybe<Scalars['Boolean']>;
  /** Milestones of the project. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the project (without namespace). */
  name: Scalars['String'];
  /** Full name of the project with its namespace. */
  nameWithNamespace: Scalars['String'];
  /** Namespace of the project. */
  namespace?: Maybe<Namespace>;
  /**
   * Network Policies of the project Deprecated in 14.8: Network policies are
   * deprecated and will be removed in GitLab 16.0. Since GitLab 15.0 this field
   * returns no data.
   * @deprecated Network policies are deprecated and will be removed in GitLab 16.0. Since GitLab 15.0 this field returns no data. Deprecated in 14.8.
   */
  networkPolicies?: Maybe<NetworkPolicyConnection>;
  /** Indicates if merge requests of the project can only be merged when all the discussions are resolved. */
  onlyAllowMergeIfAllDiscussionsAreResolved?: Maybe<Scalars['Boolean']>;
  /** Indicates that merges of merge requests should be blocked unless all status checks have passed. */
  onlyAllowMergeIfAllStatusChecksPassed?: Maybe<Scalars['Boolean']>;
  /** Indicates if merge requests of the project can only be merged with successful jobs. */
  onlyAllowMergeIfPipelineSucceeds?: Maybe<Scalars['Boolean']>;
  /** Number of open issues for the project. */
  openIssuesCount?: Maybe<Scalars['Int']>;
  /** Packages of the project. */
  packages?: Maybe<PackageConnection>;
  /** Packages cleanup policy for the project. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
  /** Path of the project. */
  path: Scalars['String'];
  /** The project's path locks. */
  pathLocks?: Maybe<PathLockConnection>;
  /** Build pipeline of the project. */
  pipeline?: Maybe<Pipeline>;
  /** Pipeline analytics. */
  pipelineAnalytics?: Maybe<PipelineAnalytics>;
  /** Build pipeline counts of the project. */
  pipelineCounts?: Maybe<PipelineCounts>;
  /** Pipeline schedules of the project. This field can only be resolved for one project per request. */
  pipelineSchedules?: Maybe<PipelineScheduleConnection>;
  /** Build pipelines of the project. */
  pipelines?: Maybe<PipelineConnection>;
  /**
   * Indicates if a link to create or view a merge request should display after a
   * push to Git repositories of the project from the command line.
   */
  printingMergeRequestLinkEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Product Analytics dashboards of the project. Introduced in 15.6: This feature
   * is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.6.
   */
  productAnalyticsDashboards?: Maybe<ProductAnalyticsDashboardConnection>;
  /** Members of the project. */
  projectMembers?: Maybe<MemberInterfaceConnection>;
  /** Indicates if there is public access to pipelines and job details of the project, including output logs and artifacts. */
  publicJobs?: Maybe<Scalars['Boolean']>;
  /** Project's push rules settings. */
  pushRules?: Maybe<PushRules>;
  /** List of recently visited boards of the project. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** A single release of the project. */
  release?: Maybe<Release>;
  /** Releases of the project. */
  releases?: Maybe<ReleaseConnection>;
  /** Indicates if `Delete source branch` option should be enabled by default for all new merge requests of the project. */
  removeSourceBranchAfterMerge?: Maybe<Scalars['Boolean']>;
  /** Git repository of the project. */
  repository?: Maybe<Repository>;
  /** Size of repository that exceeds the limit in bytes. */
  repositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Indicates if users can request member access to the project. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Find a single requirement. */
  requirement?: Maybe<Requirement>;
  /** Number of requirements for the project by their state. */
  requirementStatesCount?: Maybe<RequirementStatesCount>;
  /** Find requirements. */
  requirements?: Maybe<RequirementConnection>;
  /** SAST CI configuration for the project. */
  sastCiConfiguration?: Maybe<SastCiConfiguration>;
  /** Scan Execution Policies of the project */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Path to project's security dashboard. */
  securityDashboardPath?: Maybe<Scalars['String']>;
  /** Information about security analyzers used in the project. */
  securityScanners?: Maybe<SecurityScanners>;
  /** List of security training providers for the project */
  securityTrainingProviders?: Maybe<Array<ProjectSecurityTraining>>;
  /** Security training URLs for the enabled training providers of the project. */
  securityTrainingUrls?: Maybe<Array<SecurityTrainingUrl>>;
  /** Detailed version of a Sentry error on the project. */
  sentryDetailedError?: Maybe<SentryDetailedError>;
  /** Paginated collection of Sentry errors on the project. */
  sentryErrors?: Maybe<SentryErrorCollection>;
  /** E-mail address of the Service Desk. */
  serviceDeskAddress?: Maybe<Scalars['String']>;
  /** Indicates if the project has Service Desk enabled. */
  serviceDeskEnabled?: Maybe<Scalars['Boolean']>;
  /** Project services. */
  services?: Maybe<ServiceConnection>;
  /** Indicates if shared runners are enabled for the project. */
  sharedRunnersEnabled?: Maybe<Scalars['Boolean']>;
  /** Snippets of the project. */
  snippets?: Maybe<SnippetConnection>;
  /** Indicates if Snippets are enabled for the current user */
  snippetsEnabled?: Maybe<Scalars['Boolean']>;
  /** Template used to create squash commit message in merge requests. */
  squashCommitTemplate?: Maybe<Scalars['String']>;
  /** Indicates if `squashReadOnly` is enabled. */
  squashReadOnly: Scalars['Boolean'];
  /** URL to connect to the project via SSH. */
  sshUrlToRepo?: Maybe<Scalars['String']>;
  /** Number of times the project has been starred. */
  starCount: Scalars['Int'];
  /** Statistics of the project. */
  statistics?: Maybe<ProjectStatistics>;
  /** Commit message used to apply merge request suggestions. */
  suggestionCommitMessage?: Maybe<Scalars['String']>;
  /**
   * List of project topics (not Git tags). Deprecated in 13.12: Use `topics`.
   * @deprecated Use `topics`. Deprecated in 13.12.
   */
  tagList?: Maybe<Scalars['String']>;
  /** Find a single Terraform state by name. */
  terraformState?: Maybe<TerraformState>;
  /** Terraform states associated with the project. */
  terraformStates?: Maybe<TerraformStateConnection>;
  /**
   * Timelog categories for the project. Introduced in 15.3: This feature is in
   * Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the project. */
  timelogs?: Maybe<TimelogConnection>;
  /** List of project topics. */
  topics?: Maybe<Array<Scalars['String']>>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
  /** Visibility of the project. */
  visibility?: Maybe<Scalars['String']>;
  /** Vulnerabilities reported on the project. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the project. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Container images reported on the project vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /** Vulnerability scanners reported on the project vulnerabilities. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the project. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']>;
  /** Indicates if Wikis are enabled for the current user */
  wikiEnabled?: Maybe<Scalars['Boolean']>;
  /** Work item types available to the project. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
  /**
   * Work items of the project. Introduced in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItems?: Maybe<WorkItemConnection>;
};


export type ProjectAgentConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementAlertArgs = {
  iid?: InputMaybe<Scalars['String']>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  domain?: AlertManagementDomainFilter;
  search?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
};


export type ProjectAlertManagementAlertStatusCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
};


export type ProjectAlertManagementAlertsArgs = {
  iid?: InputMaybe<Scalars['String']>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  domain?: AlertManagementDomainFilter;
  search?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementHttpIntegrationsArgs = {
  id?: InputMaybe<Scalars['AlertManagementHttpIntegrationID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementIntegrationsArgs = {
  id?: InputMaybe<Scalars['GlobalID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementPayloadFieldsArgs = {
  payloadExample: Scalars['String'];
};


export type ProjectBoardArgs = {
  id: Scalars['BoardID'];
};


export type ProjectBoardsArgs = {
  id?: InputMaybe<Scalars['BoardID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectBranchRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectCiConfigVariablesArgs = {
  sha: Scalars['String'];
};


export type ProjectCiTemplateArgs = {
  name: Scalars['String'];
};


export type ProjectCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectClusterAgentArgs = {
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


export type ProjectClusterAgentsArgs = {
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectContainerRepositoriesArgs = {
  name?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContainerRepositorySort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectCorpusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastProfileArgs = {
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['DastProfileID'];
};


export type ProjectDastProfilesArgs = {
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastScannerProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastSiteProfileArgs = {
  id: Scalars['DastSiteProfileID'];
};


export type ProjectDastSiteProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastSiteValidationsArgs = {
  normalizedTargetUrls?: InputMaybe<Array<Scalars['String']>>;
  status?: InputMaybe<DastSiteValidationStatusEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDeploymentArgs = {
  iid: Scalars['ID'];
};


export type ProjectEnvironmentArgs = {
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Scalars['String']>>;
};


export type ProjectEnvironmentsArgs = {
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Scalars['String']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectForkTargetsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']>>;
  role: GitlabSubscriptionsUserRole;
};


export type ProjectIncidentManagementEscalationPoliciesArgs = {
  name?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIncidentManagementEscalationPolicyArgs = {
  name?: InputMaybe<Scalars['String']>;
  id: Scalars['IncidentManagementEscalationPolicyID'];
};


export type ProjectIncidentManagementOncallSchedulesArgs = {
  iids?: InputMaybe<Array<Scalars['ID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIncidentManagementTimelineEventArgs = {
  incidentId: Scalars['IssueID'];
  id: Scalars['IncidentManagementTimelineEventID'];
};


export type ProjectIncidentManagementTimelineEventsArgs = {
  incidentId: Scalars['IssueID'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIssueArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  epicId?: InputMaybe<Scalars['String']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  weight?: InputMaybe<Scalars['String']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
};


export type ProjectIssueStatusCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  epicId?: InputMaybe<Scalars['String']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  weight?: InputMaybe<Scalars['String']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
};


export type ProjectIssuesArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  epicId?: InputMaybe<Scalars['String']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  weight?: InputMaybe<Scalars['String']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIterationCadencesArgs = {
  id?: InputMaybe<Scalars['IterationsCadenceID']>;
  title?: InputMaybe<Scalars['String']>;
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  automatic?: InputMaybe<Scalars['Boolean']>;
  active?: InputMaybe<Scalars['Boolean']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIterationsArgs = {
  timeframe?: InputMaybe<Timeframe>;
  state?: InputMaybe<IterationState>;
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  id?: InputMaybe<Scalars['ID']>;
  iid?: InputMaybe<Scalars['ID']>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  sort?: InputMaybe<IterationSort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectJiraImportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectJobArgs = {
  id: Scalars['JobID'];
};


export type ProjectJobsArgs = {
  statuses?: InputMaybe<Array<CiJobStatus>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectLabelArgs = {
  title: Scalars['String'];
};


export type ProjectLabelsArgs = {
  searchTerm?: InputMaybe<Scalars['String']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectMergeRequestArgs = {
  iid: Scalars['String'];
};


export type ProjectMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectMilestonesArgs = {
  timeframe?: InputMaybe<Timeframe>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<MilestoneStateEnum>;
  title?: InputMaybe<Scalars['String']>;
  searchTitle?: InputMaybe<Scalars['String']>;
  containingDate?: InputMaybe<Scalars['Time']>;
  sort?: InputMaybe<MilestoneSort>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectNetworkPoliciesArgs = {
  environmentId?: InputMaybe<Scalars['EnvironmentID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPackagesArgs = {
  sort?: InputMaybe<PackageSort>;
  packageName?: InputMaybe<Scalars['String']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  status?: InputMaybe<PackageStatus>;
  includeVersionless?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPathLocksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPipelineArgs = {
  iid?: InputMaybe<Scalars['ID']>;
  sha?: InputMaybe<Scalars['String']>;
};


export type ProjectPipelineCountsArgs = {
  ref?: InputMaybe<Scalars['String']>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};


export type ProjectPipelineSchedulesArgs = {
  status?: InputMaybe<PipelineScheduleStatus>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPipelinesArgs = {
  status?: InputMaybe<PipelineStatusEnum>;
  scope?: InputMaybe<PipelineScopeEnum>;
  ref?: InputMaybe<Scalars['String']>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectProductAnalyticsDashboardsArgs = {
  slug?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectProjectMembersArgs = {
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MemberSort>;
  relations?: InputMaybe<Array<ProjectMemberRelation>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectReleaseArgs = {
  tagName: Scalars['String'];
};


export type ProjectReleasesArgs = {
  sort?: InputMaybe<ReleaseSort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectRequirementArgs = {
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  search?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
};


export type ProjectRequirementsArgs = {
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  search?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectScanResultPoliciesArgs = {
  relationship?: InputMaybe<SecurityPolicyRelationType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectSecurityTrainingProvidersArgs = {
  onlyEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type ProjectSecurityTrainingUrlsArgs = {
  identifierExternalIds: Array<Scalars['String']>;
  filename?: InputMaybe<Scalars['String']>;
};


export type ProjectSentryDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


export type ProjectServicesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<ServiceType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectTerraformStateArgs = {
  name: Scalars['String'];
};


export type ProjectTerraformStatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilitiesArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  sort?: InputMaybe<VulnerabilitySort>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilitiesCountByDayArgs = {
  startDate: Scalars['ISO8601Date'];
  endDate: Scalars['ISO8601Date'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilitySeveritiesCountArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
};


export type ProjectWorkItemTypesArgs = {
  taskable?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectWorkItemsArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  types?: InputMaybe<Array<IssueType>>;
  statusWidget?: InputMaybe<StatusFilterInput>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ProjectCiCdSetting = {
  __typename?: 'ProjectCiCdSetting';
  /** Indicates CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in this project have restricted access to other projects. */
  jobTokenScopeEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether to keep the latest builds artifacts. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']>;
  /** Whether merge pipelines are enabled. */
  mergePipelinesEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether merge trains are enabled. */
  mergeTrainsEnabled?: Maybe<Scalars['Boolean']>;
  /** Project the CI/CD settings belong to. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectCiCdSettingsUpdate */
export type ProjectCiCdSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full Path of the project the settings belong to. */
  fullPath: Scalars['ID'];
  /** Indicates if the latest artifact should be kept for this project. */
  keepLatestArtifact?: InputMaybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in this project have restricted access to other projects. */
  jobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge pipelines are enabled for the project. */
  mergePipelinesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge trains are enabled for the project. */
  mergeTrainsEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ProjectCiCdSettingsUpdate */
export type ProjectCiCdSettingsUpdatePayload = {
  __typename?: 'ProjectCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: ProjectCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Represents a Project Membership */
export type ProjectMember = MemberInterface & {
  __typename?: 'ProjectMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Project that User is a member of. */
  project?: Maybe<Project>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
};


/** Represents a Project Membership */
export type ProjectMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** The connection type for ProjectMember. */
export type ProjectMemberConnection = {
  __typename?: 'ProjectMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectMemberEdge = {
  __typename?: 'ProjectMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectMember>;
};

/** Project member relation */
export enum ProjectMemberRelation {
  /** Direct members */
  Direct = 'DIRECT',
  /** Inherited members */
  Inherited = 'INHERITED',
  /** Descendants members */
  Descendants = 'DESCENDANTS',
  /** Invited Groups members */
  InvitedGroups = 'INVITED_GROUPS'
}

export type ProjectPermissions = {
  __typename?: 'ProjectPermissions';
  /** Indicates the user can perform `admin_operations` on this resource */
  adminOperations: Scalars['Boolean'];
  /** Indicates the user can perform `admin_path_locks` on this resource */
  adminPathLocks: Scalars['Boolean'];
  /** Indicates the user can perform `admin_project` on this resource */
  adminProject: Scalars['Boolean'];
  /** Indicates the user can perform `admin_remote_mirror` on this resource */
  adminRemoteMirror: Scalars['Boolean'];
  /** Indicates the user can perform `admin_wiki` on this resource */
  adminWiki: Scalars['Boolean'];
  /** Indicates the user can perform `archive_project` on this resource */
  archiveProject: Scalars['Boolean'];
  /** Indicates the user can perform `change_namespace` on this resource */
  changeNamespace: Scalars['Boolean'];
  /** Indicates the user can perform `change_visibility_level` on this resource */
  changeVisibilityLevel: Scalars['Boolean'];
  /** Indicates the user can perform `create_deployment` on this resource */
  createDeployment: Scalars['Boolean'];
  /** Indicates the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean'];
  /** Indicates the user can perform `create_issue` on this resource */
  createIssue: Scalars['Boolean'];
  /** Indicates the user can perform `create_label` on this resource */
  createLabel: Scalars['Boolean'];
  /** Indicates the user can perform `create_merge_request_from` on this resource */
  createMergeRequestFrom: Scalars['Boolean'];
  /** Indicates the user can perform `create_merge_request_in` on this resource */
  createMergeRequestIn: Scalars['Boolean'];
  /** Indicates the user can perform `create_pages` on this resource */
  createPages: Scalars['Boolean'];
  /** Indicates the user can perform `create_pipeline` on this resource */
  createPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `create_pipeline_schedule` on this resource */
  createPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `create_wiki` on this resource */
  createWiki: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_pages` on this resource */
  destroyPages: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_wiki` on this resource */
  destroyWiki: Scalars['Boolean'];
  /** Indicates the user can perform `download_code` on this resource */
  downloadCode: Scalars['Boolean'];
  /** Indicates the user can perform `download_wiki_code` on this resource */
  downloadWikiCode: Scalars['Boolean'];
  /** Indicates the user can perform `fork_project` on this resource */
  forkProject: Scalars['Boolean'];
  /** Indicates the user can perform `push_code` on this resource */
  pushCode: Scalars['Boolean'];
  /** Indicates the user can perform `push_to_delete_protected_branch` on this resource */
  pushToDeleteProtectedBranch: Scalars['Boolean'];
  /** Indicates the user can perform `read_commit_status` on this resource */
  readCommitStatus: Scalars['Boolean'];
  /** Indicates the user can perform `read_cycle_analytics` on this resource */
  readCycleAnalytics: Scalars['Boolean'];
  /** Indicates the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `read_pages_content` on this resource */
  readPagesContent: Scalars['Boolean'];
  /** Indicates the user can perform `read_project` on this resource */
  readProject: Scalars['Boolean'];
  /** Indicates the user can perform `read_project_member` on this resource */
  readProjectMember: Scalars['Boolean'];
  /** Indicates the user can perform `read_wiki` on this resource */
  readWiki: Scalars['Boolean'];
  /** Indicates the user can perform `remove_fork_project` on this resource */
  removeForkProject: Scalars['Boolean'];
  /** Indicates the user can perform `remove_pages` on this resource */
  removePages: Scalars['Boolean'];
  /** Indicates the user can perform `remove_project` on this resource */
  removeProject: Scalars['Boolean'];
  /** Indicates the user can perform `rename_project` on this resource */
  renameProject: Scalars['Boolean'];
  /** Indicates the user can perform `request_access` on this resource */
  requestAccess: Scalars['Boolean'];
  /** Indicates the user can perform `update_pages` on this resource */
  updatePages: Scalars['Boolean'];
  /** Indicates the user can perform `update_wiki` on this resource */
  updateWiki: Scalars['Boolean'];
  /** Indicates the user can perform `upload_file` on this resource */
  uploadFile: Scalars['Boolean'];
};

/** Represents the source of a security policy belonging to a project */
export type ProjectSecurityPolicySource = {
  __typename?: 'ProjectSecurityPolicySource';
  /** Project the policy is associated with. */
  project?: Maybe<Project>;
};

export type ProjectSecurityTraining = {
  __typename?: 'ProjectSecurityTraining';
  /** Description of the training provider. */
  description?: Maybe<Scalars['String']>;
  /** ID of the training provider. */
  id: Scalars['GlobalID'];
  /** Represents whether the provider is enabled or not. */
  isEnabled: Scalars['Boolean'];
  /** Represents whether the provider is set as primary or not. */
  isPrimary: Scalars['Boolean'];
  /** Logo URL of the provider. */
  logoUrl?: Maybe<Scalars['String']>;
  /** Name of the training provider. */
  name: Scalars['String'];
  /** URL of the provider. */
  url: Scalars['String'];
};

/** Autogenerated input type of ProjectSetComplianceFramework */
export type ProjectSetComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to change the compliance framework of. */
  projectId: Scalars['ProjectID'];
  /** ID of the compliance framework to assign to the project. Set to `null` to unset. */
  complianceFrameworkId?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
};

/** Autogenerated return type of ProjectSetComplianceFramework */
export type ProjectSetComplianceFrameworkPayload = {
  __typename?: 'ProjectSetComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectSetLocked */
export type ProjectSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project to mutate. */
  projectPath: Scalars['ID'];
  /** Full path to the file. */
  filePath: Scalars['String'];
  /** Whether or not to lock the file path. */
  lock: Scalars['Boolean'];
};

/** Autogenerated return type of ProjectSetLocked */
export type ProjectSetLockedPayload = {
  __typename?: 'ProjectSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

export type ProjectStatistics = {
  __typename?: 'ProjectStatistics';
  /** Build artifacts size of the project in bytes. */
  buildArtifactsSize: Scalars['Float'];
  /** Commit count of the project. */
  commitCount: Scalars['Float'];
  /** Container Registry size of the project in bytes. */
  containerRegistrySize?: Maybe<Scalars['Float']>;
  /** Large File Storage (LFS) object size of the project in bytes. */
  lfsObjectsSize: Scalars['Float'];
  /** Packages size of the project in bytes. */
  packagesSize: Scalars['Float'];
  /** CI Pipeline artifacts size in bytes. */
  pipelineArtifactsSize?: Maybe<Scalars['Float']>;
  /** Repository size of the project in bytes. */
  repositorySize: Scalars['Float'];
  /** Snippets size of the project in bytes. */
  snippetsSize?: Maybe<Scalars['Float']>;
  /** Storage size of the project in bytes. */
  storageSize: Scalars['Float'];
  /** Uploads size of the project in bytes. */
  uploadsSize?: Maybe<Scalars['Float']>;
  /** Wiki size of the project in bytes. */
  wikiSize?: Maybe<Scalars['Float']>;
};

/** The alert condition for Prometheus */
export type PrometheusAlert = {
  __typename?: 'PrometheusAlert';
  /** Human-readable text of the alert condition. */
  humanizedText: Scalars['String'];
  /** ID of the alert condition. */
  id: Scalars['ID'];
};

/** Autogenerated input type of PrometheusIntegrationCreate */
export type PrometheusIntegrationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID'];
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean'];
  /** Endpoint at which Prometheus can be queried. */
  apiUrl: Scalars['String'];
};

/** Autogenerated return type of PrometheusIntegrationCreate */
export type PrometheusIntegrationCreatePayload = {
  __typename?: 'PrometheusIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationResetToken */
export type PrometheusIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID'];
};

/** Autogenerated return type of PrometheusIntegrationResetToken */
export type PrometheusIntegrationResetTokenPayload = {
  __typename?: 'PrometheusIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationUpdate */
export type PrometheusIntegrationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID'];
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Endpoint at which Prometheus can be queried. */
  apiUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of PrometheusIntegrationUpdate */
export type PrometheusIntegrationUpdatePayload = {
  __typename?: 'PrometheusIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PromoteToEpic */
export type PromoteToEpicInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the promoted epic will belong to. */
  groupPath?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of PromoteToEpic */
export type PromoteToEpicPayload = {
  __typename?: 'PromoteToEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after issue promotion. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Protected Environments of the environment. */
export type ProtectedEnvironment = {
  __typename?: 'ProtectedEnvironment';
  /** Which group, user or role is allowed to approve deployments to the environment. */
  approvalRules?: Maybe<ProtectedEnvironmentApprovalRuleConnection>;
  /** Which group, user or role is allowed to execute deployments to the environment. */
  deployAccessLevels?: Maybe<ProtectedEnvironmentDeployAccessLevelConnection>;
  /** Group details. Present if it's group-level protected environment. */
  group?: Maybe<Group>;
  /**
   * Name of the environment if it's a project-level protected environment. Tier of
   * the environment if it's a group-level protected environment.
   */
  name?: Maybe<Scalars['String']>;
  /** Project details. Present if it's project-level protected environment. */
  project?: Maybe<Project>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentDeployAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRule = {
  __typename?: 'ProtectedEnvironmentApprovalRule';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentApprovalRule. */
export type ProtectedEnvironmentApprovalRuleConnection = {
  __typename?: 'ProtectedEnvironmentApprovalRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentApprovalRuleEdge = {
  __typename?: 'ProtectedEnvironmentApprovalRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentApprovalRule>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRuleForSummary = {
  __typename?: 'ProtectedEnvironmentApprovalRuleForSummary';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Current approvals of the deployment. */
  approvals?: Maybe<Array<DeploymentApproval>>;
  /** Approved count. */
  approvedCount?: Maybe<Scalars['Int']>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Pending approval count. */
  pendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']>;
  /** Status of the approval summary. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironment. */
export type ProtectedEnvironmentConnection = {
  __typename?: 'ProtectedEnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Which group, user or role is allowed to execute deployments to the environment. */
export type ProtectedEnvironmentDeployAccessLevel = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevel';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentDeployAccessLevel. */
export type ProtectedEnvironmentDeployAccessLevelConnection = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentDeployAccessLevelEdge = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentDeployAccessLevel>;
};

/** An edge in a connection. */
export type ProtectedEnvironmentEdge = {
  __typename?: 'ProtectedEnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironment>;
};

/** Defines which user roles, users, or groups can push to a protected branch. */
export type PushAccessLevel = {
  __typename?: 'PushAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for PushAccessLevel. */
export type PushAccessLevelConnection = {
  __typename?: 'PushAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PushAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PushAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PushAccessLevelEdge = {
  __typename?: 'PushAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PushAccessLevel>;
};

/** Represents rules that commit pushes must follow. */
export type PushRules = {
  __typename?: 'PushRules';
  /** Indicates whether commits not signed through GPG will be rejected. */
  rejectUnsignedCommits: Scalars['Boolean'];
};

/** Pypi metadata */
export type PypiMetadata = {
  __typename?: 'PypiMetadata';
  /** ID of the metadatum. */
  id: Scalars['PackagesPypiMetadatumID'];
  /** Required Python version of the Pypi package. */
  requiredPython?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  /** Find an issue board list. */
  boardList?: Maybe<BoardList>;
  /** CI related settings that apply to the entire instance. */
  ciApplicationSettings?: Maybe<CiApplicationSettings>;
  /**
   * Linted and processed contents of a CI config.
   * Should not be requested more than once per request.
   */
  ciConfig?: Maybe<CiConfig>;
  /** CI/CD minutes usage data for a namespace. */
  ciMinutesUsage?: Maybe<CiMinutesNamespaceMonthlyUsageConnection>;
  /** List of the instance's CI/CD variables. */
  ciVariables?: Maybe<CiInstanceVariableConnection>;
  /** Find a container repository. */
  containerRepository?: Maybe<ContainerRepositoryDetails>;
  /** Fields related to the current license. */
  currentLicense?: Maybe<CurrentLicense>;
  /** Get information about current user. */
  currentUser?: Maybe<UserCore>;
  /** Fields related to design management. */
  designManagement: DesignManagement;
  /** Get configured DevOps adoption namespaces. **BETA** This endpoint is subject to change without notice. */
  devopsAdoptionEnabledNamespaces?: Maybe<DevopsAdoptionEnabledNamespaceConnection>;
  /** Testing endpoint to validate the API with */
  echo: Scalars['String'];
  epicBoardList?: Maybe<EpicList>;
  /** Find a Geo node. */
  geoNode?: Maybe<GeoNode>;
  /** Whether Gitpod is enabled in application settings. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Find a group. */
  group?: Maybe<Group>;
  /** Fields related to Instance Security Dashboard. */
  instanceSecurityDashboard?: Maybe<InstanceSecurityDashboard>;
  /** Find an issue. */
  issue?: Maybe<Issue>;
  /**
   * Issues visible by the current user. Returns null if the
   * `root_level_issues_query` feature flag is disabled. Introduced in 15.6: This
   * feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.6.
   */
  issues?: Maybe<IssueConnection>;
  /** Find an iteration. */
  iteration?: Maybe<Iteration>;
  /** All jobs on this GitLab instance. */
  jobs?: Maybe<CiJobConnection>;
  /** Fields related to entries in the license history. */
  licenseHistoryEntries?: Maybe<LicenseHistoryEntryConnection>;
  /** Find a merge request. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Metadata about GitLab. */
  metadata?: Maybe<Metadata>;
  /** Find a milestone. */
  milestone?: Maybe<Milestone>;
  /** Find a namespace. */
  namespace?: Maybe<Namespace>;
  /** Find a package. This field can only be resolved for one query in any single request. */
  package?: Maybe<PackageDetailsType>;
  /** Find a project. */
  project?: Maybe<Project>;
  /** Find projects visible to the current user. */
  projects?: Maybe<ProjectConnection>;
  /** Information about the complexity of the GraphQL query. */
  queryComplexity?: Maybe<QueryComplexity>;
  /** Find a runner. */
  runner?: Maybe<CiRunner>;
  /** Supported runner platforms. */
  runnerPlatforms?: Maybe<RunnerPlatformConnection>;
  /** Runner setup instructions. */
  runnerSetup?: Maybe<RunnerSetup>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** Find Snippets visible to the current user. */
  snippets?: Maybe<SnippetConnection>;
  /** Fields related to entries in future subscriptions. */
  subscriptionFutureEntries?: Maybe<SubscriptionFutureEntryConnection>;
  /** Find timelogs visible to the current user. */
  timelogs?: Maybe<TimelogConnection>;
  /** Retrieve a single to-do item */
  todo?: Maybe<Todo>;
  /** Find project topics. */
  topics?: Maybe<TopicConnection>;
  /** Get statistics on the instance. */
  usageTrendsMeasurements?: Maybe<UsageTrendsMeasurementConnection>;
  /** Find a user. */
  user?: Maybe<UserCore>;
  /** Find users. */
  users?: Maybe<UserCoreConnection>;
  /** Vulnerabilities reported on projects on the current user's instance security dashboard. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects on the current user's instance security dashboard. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Find a vulnerability. */
  vulnerability?: Maybe<Vulnerability>;
  /**
   * Find a work item. Introduced in 15.1: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItem?: Maybe<WorkItem>;
};


export type QueryBoardListArgs = {
  id: Scalars['ListID'];
  issueFilters?: InputMaybe<BoardIssueInput>;
};


export type QueryCiConfigArgs = {
  projectPath: Scalars['ID'];
  sha?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  dryRun?: InputMaybe<Scalars['Boolean']>;
};


export type QueryCiMinutesUsageArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  namespaceId?: InputMaybe<Scalars['NamespaceID']>;
};


export type QueryCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryContainerRepositoryArgs = {
  id: Scalars['ContainerRepositoryID'];
};


export type QueryDevopsAdoptionEnabledNamespacesArgs = {
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryEchoArgs = {
  text: Scalars['String'];
};


export type QueryEpicBoardListArgs = {
  id: Scalars['BoardsEpicListID'];
  epicFilters?: InputMaybe<EpicFilters>;
};


export type QueryGeoNodeArgs = {
  name?: InputMaybe<Scalars['String']>;
};


export type QueryGroupArgs = {
  fullPath: Scalars['ID'];
};


export type QueryIssueArgs = {
  id: Scalars['IssueID'];
};


export type QueryIssuesArgs = {
  search?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  epicId?: InputMaybe<Scalars['String']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  weight?: InputMaybe<Scalars['String']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryIterationArgs = {
  id: Scalars['IterationID'];
};


export type QueryJobsArgs = {
  statuses?: InputMaybe<Array<CiJobStatus>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryLicenseHistoryEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMergeRequestArgs = {
  id: Scalars['MergeRequestID'];
};


export type QueryMilestoneArgs = {
  id: Scalars['MilestoneID'];
};


export type QueryNamespaceArgs = {
  fullPath: Scalars['ID'];
};


export type QueryPackageArgs = {
  id: Scalars['PackagesPackageID'];
};


export type QueryProjectArgs = {
  fullPath: Scalars['ID'];
};


export type QueryProjectsArgs = {
  membership?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']>;
  topics?: InputMaybe<Array<Scalars['String']>>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  sort?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryRunnerArgs = {
  id: Scalars['CiRunnerID'];
};


export type QueryRunnerPlatformsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryRunnerSetupArgs = {
  platform: Scalars['String'];
  architecture: Scalars['String'];
};


export type QueryRunnersArgs = {
  paused?: InputMaybe<Scalars['Boolean']>;
  status?: InputMaybe<CiRunnerStatus>;
  type?: InputMaybe<CiRunnerType>;
  tagList?: InputMaybe<Array<Scalars['String']>>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<CiRunnerSort>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QuerySnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  authorId?: InputMaybe<Scalars['UserID']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  type?: InputMaybe<TypeEnum>;
  explore?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QuerySubscriptionFutureEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryTodoArgs = {
  id: Scalars['TodoID'];
};


export type QueryTopicsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryUsageTrendsMeasurementsArgs = {
  identifier: MeasurementIdentifier;
  recordedAfter?: InputMaybe<Scalars['Time']>;
  recordedBefore?: InputMaybe<Scalars['Time']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['UserID']>;
  username?: InputMaybe<Scalars['String']>;
};


export type QueryUsersArgs = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  usernames?: InputMaybe<Array<Scalars['String']>>;
  sort?: InputMaybe<Sort>;
  search?: InputMaybe<Scalars['String']>;
  admins?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryVulnerabilitiesArgs = {
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  sort?: InputMaybe<VulnerabilitySort>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryVulnerabilitiesCountByDayArgs = {
  startDate: Scalars['ISO8601Date'];
  endDate: Scalars['ISO8601Date'];
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryVulnerabilityArgs = {
  id: Scalars['VulnerabilityID'];
};


export type QueryWorkItemArgs = {
  id: Scalars['WorkItemID'];
};

export type QueryComplexity = {
  __typename?: 'QueryComplexity';
  /** GraphQL query complexity limit. */
  limit?: Maybe<Scalars['Int']>;
  /** GraphQL query complexity score. */
  score?: Maybe<Scalars['Int']>;
};

/** Recent failure history of a test case. */
export type RecentFailures = {
  __typename?: 'RecentFailures';
  /** Name of the base branch of the project. */
  baseBranch?: Maybe<Scalars['String']>;
  /** Number of times the test case has failed in the past 14 days. */
  count?: Maybe<Scalars['Int']>;
};

/** State of a Geo registry */
export enum RegistryState {
  /** Registry waiting to be synced. */
  Pending = 'PENDING',
  /** Registry currently syncing. */
  Started = 'STARTED',
  /** Registry that is synced. */
  Synced = 'SYNCED',
  /** Registry that failed to sync. */
  Failed = 'FAILED'
}

/** Represents a release */
export type Release = {
  __typename?: 'Release';
  /** Assets of the release. */
  assets?: Maybe<ReleaseAssets>;
  /** User that created the release. */
  author?: Maybe<UserCore>;
  /** Commit associated with the release. */
  commit?: Maybe<Commit>;
  /** Timestamp of when the release was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Description (also known as "release notes") of the release. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Evidence for the release. */
  evidences?: Maybe<ReleaseEvidenceConnection>;
  /** Indicates the release is an historical release. */
  historicalRelease?: Maybe<Scalars['Boolean']>;
  /** Global ID of the release. */
  id: Scalars['ReleaseID'];
  /** Links of the release. */
  links?: Maybe<ReleaseLinks>;
  /** Milestones associated to the release. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the release. */
  name?: Maybe<Scalars['String']>;
  /** Timestamp of when the release was released. */
  releasedAt?: Maybe<Scalars['Time']>;
  /** Name of the tag associated with the release. */
  tagName?: Maybe<Scalars['String']>;
  /** Relative web path to the tag associated with the release. */
  tagPath?: Maybe<Scalars['String']>;
  /** Indicates the release is an upcoming release. */
  upcomingRelease?: Maybe<Scalars['Boolean']>;
};


/** Represents a release */
export type ReleaseEvidencesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a release */
export type ReleaseMilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an asset link associated with a release */
export type ReleaseAssetLink = {
  __typename?: 'ReleaseAssetLink';
  /** Relative path for the direct asset link. */
  directAssetPath?: Maybe<Scalars['String']>;
  /** Direct asset URL of the link. */
  directAssetUrl?: Maybe<Scalars['String']>;
  /** Indicates the link points to an external resource. */
  external?: Maybe<Scalars['Boolean']>;
  /** ID of the link. */
  id: Scalars['ID'];
  /** Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`. */
  linkType?: Maybe<ReleaseAssetLinkType>;
  /** Name of the link. */
  name?: Maybe<Scalars['String']>;
  /** URL of the link. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseAssetLink. */
export type ReleaseAssetLinkConnection = {
  __typename?: 'ReleaseAssetLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseAssetLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseAssetLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ReleaseAssetLinkCreate */
export type ReleaseAssetLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the asset link. */
  name: Scalars['String'];
  /** URL of the asset link. */
  url: Scalars['String'];
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Full path of the project the asset link is associated with. */
  projectPath: Scalars['ID'];
  /** Name of the associated release's tag. */
  tagName: Scalars['String'];
};

/** Autogenerated return type of ReleaseAssetLinkCreate */
export type ReleaseAssetLinkCreatePayload = {
  __typename?: 'ReleaseAssetLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** Autogenerated input type of ReleaseAssetLinkDelete */
export type ReleaseAssetLinkDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the release asset link to delete. */
  id: Scalars['ReleasesLinkID'];
};

/** Autogenerated return type of ReleaseAssetLinkDelete */
export type ReleaseAssetLinkDeletePayload = {
  __typename?: 'ReleaseAssetLinkDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted release asset link. */
  link?: Maybe<ReleaseAssetLink>;
};

/** An edge in a connection. */
export type ReleaseAssetLinkEdge = {
  __typename?: 'ReleaseAssetLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseAssetLink>;
};

/** Fields that are available when modifying a release asset link */
export type ReleaseAssetLinkInput = {
  /** Name of the asset link. */
  name: Scalars['String'];
  /** URL of the asset link. */
  url: Scalars['String'];
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
};

/** Type of the link: `other`, `runbook`, `image`, `package` */
export enum ReleaseAssetLinkType {
  /** Other link type */
  Other = 'OTHER',
  /** Runbook link type */
  Runbook = 'RUNBOOK',
  /** Package link type */
  Package = 'PACKAGE',
  /** Image link type */
  Image = 'IMAGE'
}

/** Autogenerated input type of ReleaseAssetLinkUpdate */
export type ReleaseAssetLinkUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the release asset link to update. */
  id: Scalars['ReleasesLinkID'];
  /** Name of the asset link. */
  name?: InputMaybe<Scalars['String']>;
  /** URL of the asset link. */
  url?: InputMaybe<Scalars['String']>;
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
};

/** Autogenerated return type of ReleaseAssetLinkUpdate */
export type ReleaseAssetLinkUpdatePayload = {
  __typename?: 'ReleaseAssetLinkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** A container for all assets associated with a release */
export type ReleaseAssets = {
  __typename?: 'ReleaseAssets';
  /** Number of assets of the release. */
  count?: Maybe<Scalars['Int']>;
  /** Asset links of the release. */
  links?: Maybe<ReleaseAssetLinkConnection>;
  /** Sources of the release. */
  sources?: Maybe<ReleaseSourceConnection>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsSourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Fields that are available when modifying release assets */
export type ReleaseAssetsInput = {
  /** List of asset links to associate to the release. */
  links?: InputMaybe<Array<ReleaseAssetLinkInput>>;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: 'ReleaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ReleaseCreate */
export type ReleaseCreateInput = {
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the tag to associate with the release. */
  tagName: Scalars['String'];
  /** Message to use if creating a new annotated tag. */
  tagMessage?: InputMaybe<Scalars['String']>;
  /** Commit SHA or branch name to use if creating a new tag. */
  ref?: InputMaybe<Scalars['String']>;
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']>;
  /** Description (also known as "release notes") of the release. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Date and time for the release. Defaults to the current time. Expected in ISO
   * 8601 format (`2019-03-15T08:00:00Z`). Only provide this field if creating an
   * upcoming or historical release.
   */
  releasedAt?: InputMaybe<Scalars['Time']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']>>;
  /** Assets associated to the release. */
  assets?: InputMaybe<ReleaseAssetsInput>;
};

/** Autogenerated return type of ReleaseCreate */
export type ReleaseCreatePayload = {
  __typename?: 'ReleaseCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of ReleaseDelete */
export type ReleaseDeleteInput = {
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the tag associated with the release to delete. */
  tagName: Scalars['String'];
};

/** Autogenerated return type of ReleaseDelete */
export type ReleaseDeletePayload = {
  __typename?: 'ReleaseDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted release. */
  release?: Maybe<Release>;
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: 'ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Evidence for a release */
export type ReleaseEvidence = {
  __typename?: 'ReleaseEvidence';
  /** Timestamp when the evidence was collected. */
  collectedAt?: Maybe<Scalars['Time']>;
  /** URL from where the evidence can be downloaded. */
  filepath?: Maybe<Scalars['String']>;
  /** ID of the evidence. */
  id: Scalars['ID'];
  /** SHA1 ID of the evidence hash. */
  sha?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseEvidence. */
export type ReleaseEvidenceConnection = {
  __typename?: 'ReleaseEvidenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEvidenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseEvidence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseEvidenceEdge = {
  __typename?: 'ReleaseEvidenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseEvidence>;
};

export type ReleaseLinks = {
  __typename?: 'ReleaseLinks';
  /** HTTP URL of the issues page, filtered by this release and `state=closed`. */
  closedIssuesUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page , filtered by this release and `state=closed`. */
  closedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the release's edit page. */
  editUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page , filtered by this release and `state=merged`. */
  mergedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the issues page, filtered by this release and `state=open`. */
  openedIssuesUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page, filtered by this release and `state=open`. */
  openedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the release. */
  selfUrl?: Maybe<Scalars['String']>;
};

/** Values for sorting releases */
export enum ReleaseSort {
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC',
  /** Released at by descending order. */
  ReleasedAtDesc = 'RELEASED_AT_DESC',
  /** Released at by ascending order. */
  ReleasedAtAsc = 'RELEASED_AT_ASC'
}

/** Represents the source code attached to a release in a particular format */
export type ReleaseSource = {
  __typename?: 'ReleaseSource';
  /** Format of the source. */
  format?: Maybe<Scalars['String']>;
  /** Download URL of the source. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseSource. */
export type ReleaseSourceConnection = {
  __typename?: 'ReleaseSourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseSourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseSource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseSourceEdge = {
  __typename?: 'ReleaseSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseSource>;
};

/** Release tag ID wildcard values */
export enum ReleaseTagWildcardId {
  /** No release tag is assigned. */
  None = 'NONE',
  /** Release tag is assigned. */
  Any = 'ANY'
}

/** Autogenerated input type of ReleaseUpdate */
export type ReleaseUpdateInput = {
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the tag associated with the release. */
  tagName: Scalars['String'];
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']>;
  /** Description (release notes) of the release. */
  description?: InputMaybe<Scalars['String']>;
  /** Release date. */
  releasedAt?: InputMaybe<Scalars['Time']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of ReleaseUpdate */
export type ReleaseUpdatePayload = {
  __typename?: 'ReleaseUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of RemoveProjectFromSecurityDashboard */
export type RemoveProjectFromSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to remove from the Instance Security Dashboard. */
  id: Scalars['ProjectID'];
};

/** Autogenerated return type of RemoveProjectFromSecurityDashboard */
export type RemoveProjectFromSecurityDashboardPayload = {
  __typename?: 'RemoveProjectFromSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export enum ReplicationStateEnum {
  /** Replication process has not started. */
  Pending = 'PENDING',
  /** Replication process is in progress. */
  Started = 'STARTED',
  /** Replication process finished successfully. */
  Synced = 'SYNCED',
  /** Replication process finished but failed. */
  Failed = 'FAILED'
}

/** Autogenerated input type of RepositionImageDiffNote */
export type RepositionImageDiffNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the DiffNote to update. */
  id: Scalars['DiffNoteID'];
  /** Position of this note on a diff. */
  position: UpdateDiffImagePositionInput;
};

/** Autogenerated return type of RepositionImageDiffNote */
export type RepositionImageDiffNotePayload = {
  __typename?: 'RepositionImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

export type Repository = {
  __typename?: 'Repository';
  /** Blobs contained within the repository */
  blobs?: Maybe<RepositoryBlobConnection>;
  /** Names of branches available in this repository that match the search pattern. */
  branchNames?: Maybe<Array<Scalars['String']>>;
  /** Shows a disk path of the repository. */
  diskPath?: Maybe<Scalars['String']>;
  /** Indicates repository has no visible content. */
  empty: Scalars['Boolean'];
  /** Indicates a corresponding Git repository exists on disk. */
  exists: Scalars['Boolean'];
  /** Paginated tree of the repository. */
  paginatedTree?: Maybe<TreeConnection>;
  /** Default branch of the repository. */
  rootRef?: Maybe<Scalars['String']>;
  /** Tree of the repository. */
  tree?: Maybe<Tree>;
};


export type RepositoryBlobsArgs = {
  paths: Array<Scalars['String']>;
  ref?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RepositoryBranchNamesArgs = {
  searchPattern: Scalars['String'];
  offset: Scalars['Int'];
  limit: Scalars['Int'];
};


export type RepositoryPaginatedTreeArgs = {
  path?: InputMaybe<Scalars['String']>;
  recursive?: InputMaybe<Scalars['Boolean']>;
  ref?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RepositoryTreeArgs = {
  path?: InputMaybe<Scalars['String']>;
  recursive?: InputMaybe<Scalars['Boolean']>;
  ref?: InputMaybe<Scalars['String']>;
};

export type RepositoryBlob = {
  __typename?: 'RepositoryBlob';
  /** Whether the current project is archived. */
  archived?: Maybe<Scalars['Boolean']>;
  /** Web path to blob blame page. */
  blamePath?: Maybe<Scalars['String']>;
  /** Whether the current user can push to the branch. */
  canCurrentUserPushToBranch?: Maybe<Scalars['Boolean']>;
  /** Whether the current user can modify the blob. */
  canModifyBlob?: Maybe<Scalars['Boolean']>;
  /** Web path for code navigation. */
  codeNavigationPath?: Maybe<Scalars['String']>;
  /** List of code owners for the blob. */
  codeOwners?: Maybe<Array<UserCore>>;
  /** Web path to edit the blob in the old-style editor. */
  editBlobPath?: Maybe<Scalars['String']>;
  /** Web path to blob on an environment. */
  environmentExternalUrlForRouteMap?: Maybe<Scalars['String']>;
  /** Environment on which the blob is available. */
  environmentFormattedExternalUrl?: Maybe<Scalars['String']>;
  /** External storage being used, if enabled (for instance, 'LFS'). */
  externalStorage?: Maybe<Scalars['String']>;
  /** Web path to download the raw blob via external storage, if enabled. */
  externalStorageUrl?: Maybe<Scalars['String']>;
  /** Expected format of the blob based on the extension. */
  fileType?: Maybe<Scalars['String']>;
  /** Web path to find file. */
  findFilePath?: Maybe<Scalars['String']>;
  /** Web path to edit this blob using a forked project. */
  forkAndEditPath?: Maybe<Scalars['String']>;
  /** Web path to view this blob using a forked project. */
  forkAndViewPath?: Maybe<Scalars['String']>;
  /** URL to the blob within Gitpod. */
  gitpodBlobUrl?: Maybe<Scalars['String']>;
  /** Web path to blob history page. */
  historyPath?: Maybe<Scalars['String']>;
  /** ID of the blob. */
  id: Scalars['ID'];
  /** Web path to edit this blob in the Web IDE. */
  ideEditPath?: Maybe<Scalars['String']>;
  /** Web path to edit this blob in the Web IDE using a forked project. */
  ideForkAndEditPath?: Maybe<Scalars['String']>;
  /** Blob language. */
  language?: Maybe<Scalars['String']>;
  /** LFS OID of the blob. */
  lfsOid?: Maybe<Scalars['String']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']>;
  /** OID of the blob. */
  oid: Scalars['String'];
  /** Path of the blob. */
  path: Scalars['String'];
  /** Web path to blob permalink. */
  permalinkPath?: Maybe<Scalars['String']>;
  /** Web path to edit .gitlab-ci.yml file. */
  pipelineEditorPath?: Maybe<Scalars['String']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']>;
  /** Web path for the root of the blob. */
  projectBlobPathRoot?: Maybe<Scalars['String']>;
  /** Raw content of the blob. */
  rawBlob?: Maybe<Scalars['String']>;
  /** Web path to download the raw blob. */
  rawPath?: Maybe<Scalars['String']>;
  /** Size (in bytes) of the blob, or the blob target if stored externally. */
  rawSize?: Maybe<Scalars['Int']>;
  /** Raw content of the blob, if the blob is text data. */
  rawTextBlob?: Maybe<Scalars['String']>;
  /** Web path to replace the blob content. */
  replacePath?: Maybe<Scalars['String']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<BlobViewer>;
  /** Blob content simple viewer. */
  simpleViewer: BlobViewer;
  /** Size (in bytes) of the blob. */
  size?: Maybe<Scalars['Int']>;
  /** Whether the blob's content is stored externally (for instance, in LFS). */
  storedExternally?: Maybe<Scalars['Boolean']>;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']>;
};

/** The connection type for RepositoryBlob. */
export type RepositoryBlobConnection = {
  __typename?: 'RepositoryBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RepositoryBlobEdge = {
  __typename?: 'RepositoryBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryBlob>;
};

export type RepositoryLanguage = {
  __typename?: 'RepositoryLanguage';
  /** Color to visualize the repository language. */
  color?: Maybe<Scalars['Color']>;
  /** Name of the repository language. */
  name: Scalars['String'];
  /** Percentage of the repository's languages. */
  share?: Maybe<Scalars['Float']>;
};

/** Represents a requirement */
export type Requirement = {
  __typename?: 'Requirement';
  /** Author of the requirement. */
  author: UserCore;
  /** Timestamp of when the requirement was created. */
  createdAt: Scalars['Time'];
  /** Description of the requirement. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description`. */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** ID of the requirement. */
  id: Scalars['ID'];
  /** Internal ID of the requirement. */
  iid: Scalars['ID'];
  /** Indicates if latest test report was created by user. */
  lastTestReportManuallyCreated?: Maybe<Scalars['Boolean']>;
  /** Latest requirement test report state. */
  lastTestReportState?: Maybe<TestReportState>;
  /** Project to which the requirement belongs. */
  project: Project;
  /** State of the requirement. */
  state: RequirementState;
  /** Test reports of the requirement. */
  testReports?: Maybe<TestReportConnection>;
  /** Title of the requirement. */
  title?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `title`. */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the requirement was last updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: RequirementPermissions;
};


/** Represents a requirement */
export type RequirementTestReportsArgs = {
  sort?: InputMaybe<Sort>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Requirement. */
export type RequirementConnection = {
  __typename?: 'RequirementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RequirementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Requirement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RequirementEdge = {
  __typename?: 'RequirementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Requirement>;
};

/** Check permissions for the current user on a requirement */
export type RequirementPermissions = {
  __typename?: 'RequirementPermissions';
  /** Indicates the user can perform `admin_requirement` on this resource */
  adminRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `create_requirement` on this resource */
  createRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_requirement` on this resource */
  destroyRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `read_requirement` on this resource */
  readRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `update_requirement` on this resource */
  updateRequirement: Scalars['Boolean'];
};

/** State of a requirement */
export enum RequirementState {
  /** Open requirement. */
  Opened = 'OPENED',
  /** Archived requirement. */
  Archived = 'ARCHIVED'
}

/** Counts of requirements by their state */
export type RequirementStatesCount = {
  __typename?: 'RequirementStatesCount';
  /** Number of archived requirements. */
  archived?: Maybe<Scalars['Int']>;
  /** Number of opened requirements. */
  opened?: Maybe<Scalars['Int']>;
};

/** Status of a requirement based on last test report */
export enum RequirementStatusFilter {
  /** Requirements without any test report. */
  Missing = 'MISSING',
  /** Passed test report. */
  Passed = 'PASSED',
  /** Failed test report. */
  Failed = 'FAILED'
}

export type ResolvableInterface = {
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};

export type RootStorageStatistics = {
  __typename?: 'RootStorageStatistics';
  /** CI artifacts size in bytes. */
  buildArtifactsSize: Scalars['Float'];
  /** Container Registry size in bytes. */
  containerRegistrySize: Scalars['Float'];
  /** Dependency Proxy sizes in bytes. */
  dependencyProxySize: Scalars['Float'];
  /** LFS objects size in bytes. */
  lfsObjectsSize: Scalars['Float'];
  /** Packages size in bytes. */
  packagesSize: Scalars['Float'];
  /** CI pipeline artifacts size in bytes. */
  pipelineArtifactsSize: Scalars['Float'];
  /** Git repository size in bytes. */
  repositorySize: Scalars['Float'];
  /** Snippets size in bytes. */
  snippetsSize: Scalars['Float'];
  /** Total storage in bytes. */
  storageSize: Scalars['Float'];
  /** Uploads size in bytes. */
  uploadsSize: Scalars['Float'];
  /** Wiki size in bytes. */
  wikiSize: Scalars['Float'];
};

export type RunnerArchitecture = {
  __typename?: 'RunnerArchitecture';
  /** Download location for the runner for the platform architecture. */
  downloadLocation: Scalars['String'];
  /** Name of the runner platform architecture. */
  name: Scalars['String'];
};

/** The connection type for RunnerArchitecture. */
export type RunnerArchitectureConnection = {
  __typename?: 'RunnerArchitectureConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerArchitectureEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerArchitecture>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerArchitectureEdge = {
  __typename?: 'RunnerArchitectureEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerArchitecture>;
};

/** Autogenerated input type of RunnerDelete */
export type RunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the runner to delete. */
  id: Scalars['CiRunnerID'];
};

/** Autogenerated return type of RunnerDelete */
export type RunnerDeletePayload = {
  __typename?: 'RunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type RunnerPermissions = {
  __typename?: 'RunnerPermissions';
  /** Indicates the user can perform `assign_runner` on this resource */
  assignRunner: Scalars['Boolean'];
  /** Indicates the user can perform `delete_runner` on this resource */
  deleteRunner: Scalars['Boolean'];
  /** Indicates the user can perform `read_runner` on this resource */
  readRunner: Scalars['Boolean'];
  /** Indicates the user can perform `update_runner` on this resource */
  updateRunner: Scalars['Boolean'];
};

export type RunnerPlatform = {
  __typename?: 'RunnerPlatform';
  /** Runner architectures supported for the platform. */
  architectures?: Maybe<RunnerArchitectureConnection>;
  /** Human readable name of the runner platform. */
  humanReadableName: Scalars['String'];
  /** Name slug of the runner platform. */
  name: Scalars['String'];
};


export type RunnerPlatformArchitecturesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for RunnerPlatform. */
export type RunnerPlatformConnection = {
  __typename?: 'RunnerPlatformConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerPlatformEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerPlatform>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerPlatformEdge = {
  __typename?: 'RunnerPlatformEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerPlatform>;
};

export type RunnerSetup = {
  __typename?: 'RunnerSetup';
  /** Instructions for installing the runner on the specified architecture. */
  installInstructions: Scalars['String'];
  /**
   * Instructions for registering the runner. The actual registration tokens are
   * not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown.
   */
  registerInstructions?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RunnersRegistrationTokenReset */
export type RunnersRegistrationTokenResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Scope of the object to reset the token for. */
  type: CiRunnerType;
  /** ID of the project or group to reset the token for. Omit if resetting instance runner token. */
  id?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of RunnersRegistrationTokenReset */
export type RunnersRegistrationTokenResetPayload = {
  __typename?: 'RunnersRegistrationTokenResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Runner token after mutation. */
  token?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RunnerUpdate */
export type RunnerUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the runner to update. */
  id: Scalars['CiRunnerID'];
  /** Description of the runner. */
  description?: InputMaybe<Scalars['String']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: InputMaybe<Scalars['String']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: InputMaybe<Scalars['Int']>;
  /** Access level of the runner. */
  accessLevel?: InputMaybe<CiRunnerAccessLevel>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the runner is locked. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged?: InputMaybe<Scalars['Boolean']>;
  /** Tags associated with the runner. */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Projects associated with the runner. Available only for project runners. */
  associatedProjects?: InputMaybe<Array<Scalars['ProjectID']>>;
  /** Public projects' "minutes cost factor" associated with the runner (GitLab.com only). */
  publicProjectsMinutesCostFactor?: InputMaybe<Scalars['Float']>;
  /** Private projects' "minutes cost factor" associated with the runner (GitLab.com only). */
  privateProjectsMinutesCostFactor?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated return type of RunnerUpdate */
export type RunnerUpdatePayload = {
  __typename?: 'RunnerUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Runner after mutation. */
  runner?: Maybe<CiRunner>;
};

/** Represents a CI configuration of SAST */
export type SastCiConfiguration = {
  __typename?: 'SastCiConfiguration';
  /** List of analyzers entities attached to SAST configuration. */
  analyzers?: Maybe<SastCiConfigurationAnalyzersEntityConnection>;
  /** List of global entities related to SAST configuration. */
  global?: Maybe<SastCiConfigurationEntityConnection>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationAnalyzersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationGlobalArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationPipelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntity = {
  __typename?: 'SastCiConfigurationAnalyzersEntity';
  /** Analyzer description that is displayed on the form. */
  description?: Maybe<Scalars['String']>;
  /** Indicates whether an analyzer is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Analyzer label used in the config UI. */
  label?: Maybe<Scalars['String']>;
  /** Name of the analyzer. */
  name?: Maybe<Scalars['String']>;
  /** List of supported variables. */
  variables?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SastCiConfigurationAnalyzersEntity. */
export type SastCiConfigurationAnalyzersEntityConnection = {
  __typename?: 'SastCiConfigurationAnalyzersEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationAnalyzersEntityEdge = {
  __typename?: 'SastCiConfigurationAnalyzersEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationAnalyzersEntity>;
};

/** Represents the analyzers entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityInput = {
  /** Name of analyzer. */
  name: Scalars['String'];
  /** State of the analyzer. */
  enabled: Scalars['Boolean'];
  /** List of variables for the analyzer. */
  variables?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntity = {
  __typename?: 'SastCiConfigurationEntity';
  /** Default value that is used if value is empty. */
  defaultValue?: Maybe<Scalars['String']>;
  /** Entity description that is displayed on the form. */
  description?: Maybe<Scalars['String']>;
  /** CI keyword of entity. */
  field?: Maybe<Scalars['String']>;
  /** Label for entity used in the form. */
  label?: Maybe<Scalars['String']>;
  /** Different possible values of the field. */
  options?: Maybe<SastCiConfigurationOptionsEntityConnection>;
  /** Size of the UI component. */
  size?: Maybe<SastUiComponentSize>;
  /** Type of the field value. */
  type?: Maybe<Scalars['String']>;
  /** Current value of the entity. */
  value?: Maybe<Scalars['String']>;
};


/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityOptionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SastCiConfigurationEntity. */
export type SastCiConfigurationEntityConnection = {
  __typename?: 'SastCiConfigurationEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationEntityEdge = {
  __typename?: 'SastCiConfigurationEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationEntity>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityInput = {
  /** CI keyword of entity. */
  field: Scalars['String'];
  /** Default value that is used if value is empty. */
  defaultValue: Scalars['String'];
  /** Current value of the entity. */
  value: Scalars['String'];
};

/** Represents a CI configuration of SAST */
export type SastCiConfigurationInput = {
  /** List of global entities related to SAST configuration. */
  global?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
  /** List of analyzers and related variables for the SAST configuration. */
  analyzers?: InputMaybe<Array<SastCiConfigurationAnalyzersEntityInput>>;
};

/** Represents an entity for options in SAST CI configuration */
export type SastCiConfigurationOptionsEntity = {
  __typename?: 'SastCiConfigurationOptionsEntity';
  /** Label of option entity. */
  label?: Maybe<Scalars['String']>;
  /** Value of option entity. */
  value?: Maybe<Scalars['String']>;
};

/** The connection type for SastCiConfigurationOptionsEntity. */
export type SastCiConfigurationOptionsEntityConnection = {
  __typename?: 'SastCiConfigurationOptionsEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationOptionsEntityEdge = {
  __typename?: 'SastCiConfigurationOptionsEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationOptionsEntity>;
};

/** Size of UI component in SAST configuration page */
export enum SastUiComponentSize {
  /** Size of UI component in SAST configuration page is small. */
  Small = 'SMALL',
  /** Size of UI component in SAST configuration page is medium. */
  Medium = 'MEDIUM',
  /** Size of UI component in SAST configuration page is large. */
  Large = 'LARGE'
}

export type SavedReply = {
  __typename?: 'SavedReply';
  /** Content of the saved reply. */
  content: Scalars['String'];
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
  /** Name of the saved reply. */
  name: Scalars['String'];
};

/** The connection type for SavedReply. */
export type SavedReplyConnection = {
  __typename?: 'SavedReplyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of SavedReplyCreate */
export type SavedReplyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the saved reply. */
  name: Scalars['String'];
  /** Content of the saved reply. */
  content: Scalars['String'];
};

/** Autogenerated return type of SavedReplyCreate */
export type SavedReplyCreatePayload = {
  __typename?: 'SavedReplyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyDestroy */
export type SavedReplyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
};

/** Autogenerated return type of SavedReplyDestroy */
export type SavedReplyDestroyPayload = {
  __typename?: 'SavedReplyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** An edge in a connection. */
export type SavedReplyEdge = {
  __typename?: 'SavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyUpdate */
export type SavedReplyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
  /** Name of the saved reply. */
  name: Scalars['String'];
  /** Content of the saved reply. */
  content: Scalars['String'];
};

/** Autogenerated return type of SavedReplyUpdate */
export type SavedReplyUpdatePayload = {
  __typename?: 'SavedReplyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Represents the security scan information */
export type Scan = {
  __typename?: 'Scan';
  /** List of errors. */
  errors: Array<Scalars['String']>;
  /** Name of the scan. */
  name: Scalars['String'];
  /** Indicates the status of the scan. */
  status: ScanStatus;
  /** List of warnings. */
  warnings: Array<Scalars['String']>;
};

/** The connection type for Scan. */
export type ScanConnection = {
  __typename?: 'ScanConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Scan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanEdge = {
  __typename?: 'ScanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Scan>;
};

/** Represents the scan execution policy */
export type ScanExecutionPolicy = OrchestrationPolicy & {
  __typename?: 'ScanExecutionPolicy';
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Name of the policy. */
  name: Scalars['String'];
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** Autogenerated input type of ScanExecutionPolicyCommit */
export type ScanExecutionPolicyCommitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  fullPath?: InputMaybe<Scalars['String']>;
  /** YAML snippet of the policy. */
  policyYaml: Scalars['String'];
  /** Changes the operation mode. */
  operationMode: MutationOperationMode;
  /** Name of the policy. If the name is null, the `name` field from `policy_yaml` is used. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ScanExecutionPolicyCommit */
export type ScanExecutionPolicyCommitPayload = {
  __typename?: 'ScanExecutionPolicyCommitPayload';
  /** Name of the branch to which the policy changes are committed. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for ScanExecutionPolicy. */
export type ScanExecutionPolicyConnection = {
  __typename?: 'ScanExecutionPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanExecutionPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanExecutionPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanExecutionPolicyEdge = {
  __typename?: 'ScanExecutionPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanExecutionPolicy>;
};

/** Represents a resource scanned by a security scan */
export type ScannedResource = {
  __typename?: 'ScannedResource';
  /** HTTP request method used to access the URL. */
  requestMethod?: Maybe<Scalars['String']>;
  /** URL scanned by the scanner. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ScannedResource. */
export type ScannedResourceConnection = {
  __typename?: 'ScannedResourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScannedResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScannedResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScannedResourceEdge = {
  __typename?: 'ScannedResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScannedResource>;
};

/** Represents the scan result policy */
export type ScanResultPolicy = OrchestrationPolicy & {
  __typename?: 'ScanResultPolicy';
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Approvers of the group type. */
  groupApprovers?: Maybe<Array<Group>>;
  /** Name of the policy. */
  name: Scalars['String'];
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** Approvers of the user type. */
  userApprovers?: Maybe<Array<UserCore>>;
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** The connection type for ScanResultPolicy. */
export type ScanResultPolicyConnection = {
  __typename?: 'ScanResultPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanResultPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanResultPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanResultPolicyEdge = {
  __typename?: 'ScanResultPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanResultPolicy>;
};

/** The status of the security scan */
export enum ScanStatus {
  /** The scan has been created. */
  Created = 'CREATED',
  /** The report has been successfully prepared. */
  Succeeded = 'SUCCEEDED',
  /** The related CI build failed. */
  JobFailed = 'JOB_FAILED',
  /** The report artifact provided by the CI build couldn't be parsed. */
  ReportError = 'REPORT_ERROR',
  /** Preparing the report for the scan. */
  Preparing = 'PREPARING',
  /** Report couldn't be prepared. */
  PreparationFailed = 'PREPARATION_FAILED',
  /** Report for the scan has been removed from the database. */
  Purged = 'PURGED'
}

/** Autogenerated input type of SecurityFindingCreateIssue */
export type SecurityFindingCreateIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** UUID of the security finding to be used to create an issue. */
  uuid: Scalars['String'];
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID'];
};

/** Autogenerated return type of SecurityFindingCreateIssue */
export type SecurityFindingCreateIssuePayload = {
  __typename?: 'SecurityFindingCreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of SecurityFindingDismiss */
export type SecurityFindingDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** UUID of the finding to be dismissed. */
  uuid: Scalars['String'];
  /** Comment why finding should be dismissed. */
  comment?: InputMaybe<Scalars['String']>;
  /** Reason why finding should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
};

/** Autogenerated return type of SecurityFindingDismiss */
export type SecurityFindingDismissPayload = {
  __typename?: 'SecurityFindingDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** UUID of dismissed finding. */
  uuid?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SecurityPolicyProjectAssign */
export type SecurityPolicyProjectAssignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
  /** ID of the security policy project. */
  securityPolicyProjectId: Scalars['ProjectID'];
};

/** Autogenerated return type of SecurityPolicyProjectAssign */
export type SecurityPolicyProjectAssignPayload = {
  __typename?: 'SecurityPolicyProjectAssignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of SecurityPolicyProjectCreate */
export type SecurityPolicyProjectCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SecurityPolicyProjectCreate */
export type SecurityPolicyProjectCreatePayload = {
  __typename?: 'SecurityPolicyProjectCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Security Policy Project that was created. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of SecurityPolicyProjectUnassign */
export type SecurityPolicyProjectUnassignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of SecurityPolicyProjectUnassign */
export type SecurityPolicyProjectUnassignPayload = {
  __typename?: 'SecurityPolicyProjectUnassignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export enum SecurityPolicyRelationType {
  /** Policies defined for the project/group only. */
  Direct = 'DIRECT',
  /** Policies defined for the project/group and ancestor groups. */
  Inherited = 'INHERITED',
  /** Policies defined for the project/group's ancestor groups only. */
  InheritedOnly = 'INHERITED_ONLY'
}

/** Represents a policy source. Its fields depend on the source type. */
export type SecurityPolicySource = GroupSecurityPolicySource | ProjectSecurityPolicySource;

/** Represents summary of a security report */
export type SecurityReportSummary = {
  __typename?: 'SecurityReportSummary';
  /** Aggregated counts for the `api_fuzzing` scan */
  apiFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `cluster_image_scanning` scan */
  clusterImageScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `container_scanning` scan */
  containerScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `coverage_fuzzing` scan */
  coverageFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dast` scan */
  dast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dependency_scanning` scan */
  dependencyScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `generic` scan */
  generic?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `sast` scan */
  sast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `secret_detection` scan */
  secretDetection?: Maybe<SecurityReportSummarySection>;
};

/** Represents a section of a summary of a security report */
export type SecurityReportSummarySection = {
  __typename?: 'SecurityReportSummarySection';
  /** List of the first 20 scanned resources. */
  scannedResources?: Maybe<ScannedResourceConnection>;
  /** Total number of scanned resources. */
  scannedResourcesCount?: Maybe<Scalars['Int']>;
  /** Path to download all the scanned resources in CSV format. */
  scannedResourcesCsvPath?: Maybe<Scalars['String']>;
  /** List of security scans ran for the type. */
  scans: ScanConnection;
  /** Total number of vulnerabilities. */
  vulnerabilitiesCount?: Maybe<Scalars['Int']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScannedResourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScansArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum SecurityReportTypeEnum {
  /** SAST scan report */
  Sast = 'SAST',
  /** SAST IAC scan report */
  SastIac = 'SAST_IAC',
  /** DAST scan report */
  Dast = 'DAST',
  /** DEPENDENCY SCANNING scan report */
  DependencyScanning = 'DEPENDENCY_SCANNING',
  /** CONTAINER SCANNING scan report */
  ContainerScanning = 'CONTAINER_SCANNING',
  /** SECRET DETECTION scan report */
  SecretDetection = 'SECRET_DETECTION',
  /** COVERAGE FUZZING scan report */
  CoverageFuzzing = 'COVERAGE_FUZZING',
  /** API FUZZING scan report */
  ApiFuzzing = 'API_FUZZING',
  /** CLUSTER IMAGE SCANNING scan report */
  ClusterImageScanning = 'CLUSTER_IMAGE_SCANNING'
}

/** Represents a list of security scanners */
export type SecurityScanners = {
  __typename?: 'SecurityScanners';
  /** List of analyzers which are available for the project. */
  available?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which are enabled for the project. */
  enabled?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which ran successfully in the latest pipeline. */
  pipelineRun?: Maybe<Array<SecurityScannerType>>;
};

/** The type of the security scanner */
export enum SecurityScannerType {
  /** SAST scanner */
  Sast = 'SAST',
  /** Sast Iac scanner */
  SastIac = 'SAST_IAC',
  /** DAST scanner */
  Dast = 'DAST',
  /** Dependency Scanning scanner */
  DependencyScanning = 'DEPENDENCY_SCANNING',
  /** Container Scanning scanner */
  ContainerScanning = 'CONTAINER_SCANNING',
  /** Secret Detection scanner */
  SecretDetection = 'SECRET_DETECTION',
  /** Coverage Fuzzing scanner */
  CoverageFuzzing = 'COVERAGE_FUZZING',
  /** API Fuzzing scanner */
  ApiFuzzing = 'API_FUZZING',
  /** Cluster Image Scanning scanner */
  ClusterImageScanning = 'CLUSTER_IMAGE_SCANNING'
}

/** Autogenerated input type of SecurityTrainingUpdate */
export type SecurityTrainingUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** ID of the provider. */
  providerId: Scalars['SecurityTrainingProviderID'];
  /** Sets the training provider as enabled for the project. */
  isEnabled: Scalars['Boolean'];
  /** Sets the training provider as primary for the project. */
  isPrimary?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of SecurityTrainingUpdate */
export type SecurityTrainingUpdatePayload = {
  __typename?: 'SecurityTrainingUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Represents the training entity subject to mutation. */
  training?: Maybe<ProjectSecurityTraining>;
};

/** Represents a URL related to a security training */
export type SecurityTrainingUrl = {
  __typename?: 'SecurityTrainingUrl';
  /** Name of the vulnerability identifier. */
  identifier?: Maybe<Scalars['String']>;
  /** Name of the training provider. */
  name?: Maybe<Scalars['String']>;
  /** Status of the request to training provider. */
  status?: Maybe<TrainingUrlRequestStatus>;
  /** URL of the link for security training content. */
  url?: Maybe<Scalars['String']>;
};

/** A Sentry error */
export type SentryDetailedError = {
  __typename?: 'SentryDetailedError';
  /** Count of occurrences. */
  count: Scalars['Int'];
  /** Culprit of the error. */
  culprit: Scalars['String'];
  /** External Base URL of the Sentry Instance. */
  externalBaseUrl: Scalars['String'];
  /** External URL of the error. */
  externalUrl: Scalars['String'];
  /** Commit the error was first seen. */
  firstReleaseLastCommit?: Maybe<Scalars['String']>;
  /** Release short version the error was first seen. */
  firstReleaseShortVersion?: Maybe<Scalars['String']>;
  /** Release version the error was first seen. */
  firstReleaseVersion?: Maybe<Scalars['String']>;
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** GitLab commit SHA attributed to the Error based on the release version. */
  gitlabCommit?: Maybe<Scalars['String']>;
  /** Path to the GitLab page for the GitLab commit attributed to the error. */
  gitlabCommitPath?: Maybe<Scalars['String']>;
  /** URL of GitLab Issue. */
  gitlabIssuePath?: Maybe<Scalars['String']>;
  /** ID (global ID) of the error. */
  id: Scalars['ID'];
  /** Error tracking backend. */
  integrated?: Maybe<Scalars['Boolean']>;
  /** Commit the error was last seen. */
  lastReleaseLastCommit?: Maybe<Scalars['String']>;
  /** Release short version the error was last seen. */
  lastReleaseShortVersion?: Maybe<Scalars['String']>;
  /** Release version the error was last seen. */
  lastReleaseVersion?: Maybe<Scalars['String']>;
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Tags associated with the Sentry Error. */
  tags: SentryErrorTags;
  /** Title of the error. */
  title: Scalars['String'];
  /** Type of the error. */
  type: Scalars['String'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int'];
};

/** A Sentry error. A simplified version of SentryDetailedError */
export type SentryError = {
  __typename?: 'SentryError';
  /** Count of occurrences. */
  count: Scalars['Int'];
  /** Culprit of the error. */
  culprit: Scalars['String'];
  /** External URL of the error. */
  externalUrl: Scalars['String'];
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** ID (global ID) of the error. */
  id: Scalars['ID'];
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Title of the error. */
  title: Scalars['String'];
  /** Type of the error. */
  type: Scalars['String'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int'];
};

/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollection = {
  __typename?: 'SentryErrorCollection';
  /** Detailed version of a Sentry error on the project. */
  detailedError?: Maybe<SentryDetailedError>;
  /** Stack Trace of Sentry Error. */
  errorStackTrace?: Maybe<SentryErrorStackTrace>;
  /** Collection of Sentry Errors. */
  errors?: Maybe<SentryErrorConnection>;
  /** External URL for Sentry. */
  externalUrl?: Maybe<Scalars['String']>;
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorStackTraceArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorsArgs = {
  searchTerm?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SentryError. */
export type SentryErrorConnection = {
  __typename?: 'SentryErrorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SentryErrorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SentryError>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SentryErrorEdge = {
  __typename?: 'SentryErrorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SentryError>;
};

export type SentryErrorFrequency = {
  __typename?: 'SentryErrorFrequency';
  /** Count of errors received since the previously recorded time. */
  count: Scalars['Int'];
  /** Time the error frequency stats were recorded. */
  time: Scalars['Time'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTrace = {
  __typename?: 'SentryErrorStackTrace';
  /** Time the stack trace was received by Sentry. */
  dateReceived: Scalars['String'];
  /** ID of the Sentry error. */
  issueId: Scalars['String'];
  /** Stack trace entries for the Sentry error. */
  stackTraceEntries: Array<SentryErrorStackTraceEntry>;
};

/** An object context for a Sentry error stack trace */
export type SentryErrorStackTraceContext = {
  __typename?: 'SentryErrorStackTraceContext';
  /** Code number of the context. */
  code: Scalars['String'];
  /** Line number of the context. */
  line: Scalars['Int'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTraceEntry = {
  __typename?: 'SentryErrorStackTraceEntry';
  /** Function in which the Sentry error occurred. */
  col?: Maybe<Scalars['String']>;
  /** File in which the Sentry error occurred. */
  fileName?: Maybe<Scalars['String']>;
  /** Function in which the Sentry error occurred. */
  function?: Maybe<Scalars['String']>;
  /** Function in which the Sentry error occurred. */
  line?: Maybe<Scalars['String']>;
  /** Context of the Sentry error. */
  traceContext?: Maybe<Array<SentryErrorStackTraceContext>>;
};

/** State of a Sentry error */
export enum SentryErrorStatus {
  /** Error has been resolved. */
  Resolved = 'RESOLVED',
  /** Error has been ignored until next release. */
  ResolvedInNextRelease = 'RESOLVED_IN_NEXT_RELEASE',
  /** Error is unresolved. */
  Unresolved = 'UNRESOLVED',
  /** Error has been ignored. */
  Ignored = 'IGNORED'
}

/** State of a Sentry error */
export type SentryErrorTags = {
  __typename?: 'SentryErrorTags';
  /** Severity level of the Sentry Error. */
  level?: Maybe<Scalars['String']>;
  /** Logger of the Sentry Error. */
  logger?: Maybe<Scalars['String']>;
};

export type Service = {
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};

/** The connection type for Service. */
export type ServiceConnection = {
  __typename?: 'ServiceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ServiceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Service>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ServiceEdge = {
  __typename?: 'ServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Service>;
};

export enum ServiceType {
  /** AsanaService type */
  AsanaService = 'ASANA_SERVICE',
  /** AssemblaService type */
  AssemblaService = 'ASSEMBLA_SERVICE',
  /** BambooService type */
  BambooService = 'BAMBOO_SERVICE',
  /** BugzillaService type */
  BugzillaService = 'BUGZILLA_SERVICE',
  /** BuildkiteService type */
  BuildkiteService = 'BUILDKITE_SERVICE',
  /** CampfireService type */
  CampfireService = 'CAMPFIRE_SERVICE',
  /** ConfluenceService type */
  ConfluenceService = 'CONFLUENCE_SERVICE',
  /** CustomIssueTrackerService type */
  CustomIssueTrackerService = 'CUSTOM_ISSUE_TRACKER_SERVICE',
  /** DatadogService type */
  DatadogService = 'DATADOG_SERVICE',
  /** DiscordService type */
  DiscordService = 'DISCORD_SERVICE',
  /** DroneCiService type */
  DroneCiService = 'DRONE_CI_SERVICE',
  /** EmailsOnPushService type */
  EmailsOnPushService = 'EMAILS_ON_PUSH_SERVICE',
  /** EwmService type */
  EwmService = 'EWM_SERVICE',
  /** ExternalWikiService type */
  ExternalWikiService = 'EXTERNAL_WIKI_SERVICE',
  /** FlowdockService type */
  FlowdockService = 'FLOWDOCK_SERVICE',
  /** GithubService type */
  GithubService = 'GITHUB_SERVICE',
  /** HangoutsChatService type */
  HangoutsChatService = 'HANGOUTS_CHAT_SERVICE',
  /** HarborService type */
  HarborService = 'HARBOR_SERVICE',
  /** IrkerService type */
  IrkerService = 'IRKER_SERVICE',
  /** JenkinsService type */
  JenkinsService = 'JENKINS_SERVICE',
  /** JiraService type */
  JiraService = 'JIRA_SERVICE',
  /** MattermostService type */
  MattermostService = 'MATTERMOST_SERVICE',
  /** MattermostSlashCommandsService type */
  MattermostSlashCommandsService = 'MATTERMOST_SLASH_COMMANDS_SERVICE',
  /** MicrosoftTeamsService type */
  MicrosoftTeamsService = 'MICROSOFT_TEAMS_SERVICE',
  /** PackagistService type */
  PackagistService = 'PACKAGIST_SERVICE',
  /** PipelinesEmailService type */
  PipelinesEmailService = 'PIPELINES_EMAIL_SERVICE',
  /** PivotaltrackerService type */
  PivotaltrackerService = 'PIVOTALTRACKER_SERVICE',
  /** PrometheusService type */
  PrometheusService = 'PROMETHEUS_SERVICE',
  /** PumbleService type */
  PumbleService = 'PUMBLE_SERVICE',
  /** PushoverService type */
  PushoverService = 'PUSHOVER_SERVICE',
  /** RedmineService type */
  RedmineService = 'REDMINE_SERVICE',
  /** ShimoService type */
  ShimoService = 'SHIMO_SERVICE',
  /** SlackService type */
  SlackService = 'SLACK_SERVICE',
  /** SlackSlashCommandsService type */
  SlackSlashCommandsService = 'SLACK_SLASH_COMMANDS_SERVICE',
  /** TeamcityService type */
  TeamcityService = 'TEAMCITY_SERVICE',
  /** UnifyCircuitService type */
  UnifyCircuitService = 'UNIFY_CIRCUIT_SERVICE',
  /** WebexTeamsService type */
  WebexTeamsService = 'WEBEX_TEAMS_SERVICE',
  /** YoutrackService type */
  YoutrackService = 'YOUTRACK_SERVICE',
  /** ZentaoService type */
  ZentaoService = 'ZENTAO_SERVICE'
}

/** How to format SHA strings. */
export enum ShaFormat {
  /** Abbreviated format. Short SHAs are typically eight characters long. */
  Short = 'SHORT',
  /** Unabbreviated format. */
  Long = 'LONG'
}

export enum SharedRunnersSetting {
  /** Sharing of runners is disabled and unoverridable. */
  DisabledAndUnoverridable = 'DISABLED_AND_UNOVERRIDABLE',
  /** Sharing of runners is disabled with override. */
  DisabledWithOverride = 'DISABLED_WITH_OVERRIDE',
  /** Sharing of runners is enabled. */
  Enabled = 'ENABLED'
}

/** Represents a snippet entry */
export type Snippet = NoteableInterface & {
  __typename?: 'Snippet';
  /** Owner of the snippet. */
  author?: Maybe<UserCore>;
  /** Snippet blobs. */
  blobs?: Maybe<SnippetBlobConnection>;
  /** Timestamp this snippet was created. */
  createdAt: Scalars['Time'];
  /** Description of the snippet. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** File Name of the snippet. */
  fileName?: Maybe<Scalars['String']>;
  /** HTTP URL to the snippet repository. */
  httpUrlToRepo?: Maybe<Scalars['String']>;
  /** ID of the snippet. */
  id: Scalars['SnippetID'];
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Project the snippet is associated with. */
  project?: Maybe<Project>;
  /** Raw URL of the snippet. */
  rawUrl: Scalars['String'];
  /** SSH URL to the snippet repository. */
  sshUrlToRepo?: Maybe<Scalars['String']>;
  /** Title of the snippet. */
  title: Scalars['String'];
  /** Timestamp this snippet was updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: SnippetPermissions;
  /** Visibility Level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
  /** Web URL of the snippet. */
  webUrl: Scalars['String'];
};


/** Represents a snippet entry */
export type SnippetBlobsArgs = {
  paths?: InputMaybe<Array<Scalars['String']>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a snippet entry */
export type SnippetDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a snippet entry */
export type SnippetNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents the snippet blob */
export type SnippetBlob = {
  __typename?: 'SnippetBlob';
  /** Shows whether the blob is binary. */
  binary: Scalars['Boolean'];
  /** Blob external storage. */
  externalStorage?: Maybe<Scalars['String']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']>;
  /** Blob path. */
  path?: Maybe<Scalars['String']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']>;
  /** Blob raw content endpoint path. */
  rawPath: Scalars['String'];
  /** Raw content of the blob, if the blob is text data. */
  rawPlainData?: Maybe<Scalars['String']>;
  /** Shows whether the blob is rendered as text. */
  renderedAsText: Scalars['Boolean'];
  /** Blob highlighted data. */
  richData?: Maybe<Scalars['String']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<SnippetBlobViewer>;
  /** Blob content simple viewer. */
  simpleViewer: SnippetBlobViewer;
  /** Blob size. */
  size: Scalars['Int'];
};

/** Type of a snippet blob input action */
export enum SnippetBlobActionEnum {
  /** Create a snippet blob. */
  Create = 'create',
  /** Update a snippet blob. */
  Update = 'update',
  /** Delete a snippet blob. */
  Delete = 'delete',
  /** Move a snippet blob. */
  Move = 'move'
}

/** Represents an action to perform over a snippet file */
export type SnippetBlobActionInputType = {
  /** Type of input action. */
  action: SnippetBlobActionEnum;
  /** Previous path of the snippet file. */
  previousPath?: InputMaybe<Scalars['String']>;
  /** Path of the snippet file. */
  filePath: Scalars['String'];
  /** Snippet file content. */
  content?: InputMaybe<Scalars['String']>;
};

/** The connection type for SnippetBlob. */
export type SnippetBlobConnection = {
  __typename?: 'SnippetBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetBlobEdge>>>;
  /** Indicates if the snippet has unretrievable blobs. */
  hasUnretrievableBlobs: Scalars['Boolean'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetBlobEdge = {
  __typename?: 'SnippetBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetBlob>;
};

/** Represents how the blob content should be displayed */
export type SnippetBlobViewer = {
  __typename?: 'SnippetBlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean'];
  /** Content file type. */
  fileType: Scalars['String'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** The connection type for Snippet. */
export type SnippetConnection = {
  __typename?: 'SnippetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Snippet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetEdge = {
  __typename?: 'SnippetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Snippet>;
};

export type SnippetPermissions = {
  __typename?: 'SnippetPermissions';
  /** Indicates the user can perform `admin_snippet` on this resource */
  adminSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `read_snippet` on this resource */
  readSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `report_snippet` on this resource */
  reportSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `update_snippet` on this resource */
  updateSnippet: Scalars['Boolean'];
};

/** Represents the Geo sync and verification state of a snippet repository */
export type SnippetRepositoryRegistry = {
  __typename?: 'SnippetRepositoryRegistry';
  /** Timestamp when the SnippetRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the SnippetRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the SnippetRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the SnippetRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the SnippetRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the SnippetRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** ID of the Snippet Repository. */
  snippetRepositoryId: Scalars['ID'];
  /** Sync state of the SnippetRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the SnippetRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the SnippetRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for SnippetRepositoryRegistry. */
export type SnippetRepositoryRegistryConnection = {
  __typename?: 'SnippetRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetRepositoryRegistryEdge = {
  __typename?: 'SnippetRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetRepositoryRegistry>;
};

/** Common sort values */
export enum Sort {
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** Values for sort direction */
export enum SortDirectionEnum {
  /** Ascending order. */
  Asc = 'ASC',
  /** Descending order. */
  Desc = 'DESC'
}

export type StatusAction = {
  __typename?: 'StatusAction';
  /** Title for the button, for example: Retry this job. */
  buttonTitle?: Maybe<Scalars['String']>;
  /** Icon used in the action button. */
  icon?: Maybe<Scalars['String']>;
  /** ID for a status action. */
  id: Scalars['String'];
  /** Method for the action, for example: :post. */
  method?: Maybe<Scalars['String']>;
  /** Path for the action. */
  path?: Maybe<Scalars['String']>;
  /** Title for the action, for example: Retry. */
  title?: Maybe<Scalars['String']>;
};

export type StatusFilterInput = {
  /** Status of the work item. */
  status: RequirementStatusFilter;
};

export type StatusInput = {
  /** Status to assign to the work item. */
  status: TestReportState;
};

export type Submodule = Entry & {
  __typename?: 'Submodule';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Tree URL for the sub-module. */
  treeUrl?: Maybe<Scalars['String']>;
  /** Type of tree entry. */
  type: EntryType;
  /** Web URL for the sub-module. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for Submodule. */
export type SubmoduleConnection = {
  __typename?: 'SubmoduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubmoduleEdge = {
  __typename?: 'SubmoduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Submodule>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /** Triggered when the assignees of an issuable are updated. */
  issuableAssigneesUpdated?: Maybe<Issuable>;
  /** Triggered when the due date or start date of an issuable is updated. */
  issuableDatesUpdated?: Maybe<Issuable>;
  /** Triggered when the description of an issuable is updated. */
  issuableDescriptionUpdated?: Maybe<Issuable>;
  /** Triggered when the iteration of an issuable is updated. */
  issuableIterationUpdated?: Maybe<Issuable>;
  /** Triggered when the labels of an issuable are updated. */
  issuableLabelsUpdated?: Maybe<Issuable>;
  /** Triggered when the milestone of an issuable is updated. */
  issuableMilestoneUpdated?: Maybe<Issuable>;
  /** Triggered when the title of an issuable is updated. */
  issuableTitleUpdated?: Maybe<Issuable>;
  /** Triggered when the weight of an issuable is updated. */
  issuableWeightUpdated?: Maybe<Issuable>;
  /** Triggered when the crm contacts of an issuable are updated. */
  issueCrmContactsUpdated?: Maybe<Issuable>;
  /** Triggered when the merge status of a merge request is updated. */
  mergeRequestMergeStatusUpdated?: Maybe<Issuable>;
  /** Triggered when the reviewers of a merge request are updated. */
  mergeRequestReviewersUpdated?: Maybe<Issuable>;
};


export type SubscriptionIssuableAssigneesUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableDatesUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableDescriptionUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableIterationUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableLabelsUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableMilestoneUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableTitleUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableWeightUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssueCrmContactsUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionMergeRequestMergeStatusUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionMergeRequestReviewersUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};

/** Represents an entry from the future subscriptions */
export type SubscriptionFutureEntry = {
  __typename?: 'SubscriptionFutureEntry';
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of license the subscription will yield. */
  type: Scalars['String'];
  /** Number of paid user seats. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
};

/** The connection type for SubscriptionFutureEntry. */
export type SubscriptionFutureEntryConnection = {
  __typename?: 'SubscriptionFutureEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubscriptionFutureEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SubscriptionFutureEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubscriptionFutureEntryEdge = {
  __typename?: 'SubscriptionFutureEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SubscriptionFutureEntry>;
};

/** Represents a Suggested Reviewers result set */
export type SuggestedReviewersType = {
  __typename?: 'SuggestedReviewersType';
  /** List of reviewers. */
  reviewers: Array<Scalars['String']>;
  /** Number of reviewers returned. */
  topN?: Maybe<Scalars['Int']>;
  /** Suggested reviewer version. */
  version?: Maybe<Scalars['String']>;
};

/** Completion status of tasks */
export type TaskCompletionStatus = {
  __typename?: 'TaskCompletionStatus';
  /** Number of completed tasks. */
  completedCount: Scalars['Int'];
  /** Number of total tasks. */
  count: Scalars['Int'];
};

export type TerraformState = {
  __typename?: 'TerraformState';
  /** Timestamp the Terraform state was created. */
  createdAt: Scalars['Time'];
  /** Timestamp the Terraform state was deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** ID of the Terraform state. */
  id: Scalars['ID'];
  /** Latest version of the Terraform state. */
  latestVersion?: Maybe<TerraformStateVersion>;
  /** Timestamp the Terraform state was locked. */
  lockedAt?: Maybe<Scalars['Time']>;
  /** User currently holding a lock on the Terraform state. */
  lockedByUser?: Maybe<UserCore>;
  /** Name of the Terraform state. */
  name: Scalars['String'];
  /** Timestamp the Terraform state was updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for TerraformState. */
export type TerraformStateConnection = {
  __typename?: 'TerraformStateConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformState>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TerraformStateDelete */
export type TerraformStateDeleteInput = {
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TerraformStateDelete */
export type TerraformStateDeletePayload = {
  __typename?: 'TerraformStateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type TerraformStateEdge = {
  __typename?: 'TerraformStateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformState>;
};

/** Autogenerated input type of TerraformStateLock */
export type TerraformStateLockInput = {
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TerraformStateLock */
export type TerraformStateLockPayload = {
  __typename?: 'TerraformStateLockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of TerraformStateUnlock */
export type TerraformStateUnlockInput = {
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of TerraformStateUnlock */
export type TerraformStateUnlockPayload = {
  __typename?: 'TerraformStateUnlockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type TerraformStateVersion = {
  __typename?: 'TerraformStateVersion';
  /** Timestamp the version was created. */
  createdAt: Scalars['Time'];
  /** User that created this version. */
  createdByUser?: Maybe<UserCore>;
  /** URL for downloading the version's JSON file. */
  downloadPath?: Maybe<Scalars['String']>;
  /** ID of the Terraform state version. */
  id: Scalars['ID'];
  /** Job that created this version. */
  job?: Maybe<CiJob>;
  /** Serial number of the version. */
  serial?: Maybe<Scalars['Int']>;
  /** Timestamp the version was updated. */
  updatedAt: Scalars['Time'];
};

/** Represents the Geo sync and verification state of a terraform state version */
export type TerraformStateVersionRegistry = {
  __typename?: 'TerraformStateVersionRegistry';
  /** Timestamp when the TerraformStateVersionRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the TerraformStateVersionRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the TerraformStateVersionRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the TerraformStateVersionRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the TerraformStateVersionRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the TerraformStateVersionRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the TerraformStateVersionRegistry */
  state?: Maybe<RegistryState>;
  /** ID of the terraform state version. */
  terraformStateVersionId: Scalars['ID'];
  /** Timestamp after which the TerraformStateVersionRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the TerraformStateVersionRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for TerraformStateVersionRegistry. */
export type TerraformStateVersionRegistryConnection = {
  __typename?: 'TerraformStateVersionRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateVersionRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformStateVersionRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TerraformStateVersionRegistryEdge = {
  __typename?: 'TerraformStateVersionRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformStateVersionRegistry>;
};

/** Test case in pipeline test report. */
export type TestCase = {
  __typename?: 'TestCase';
  /** URL of the test case attachment file. */
  attachmentUrl?: Maybe<Scalars['String']>;
  /** Classname of the test case. */
  classname?: Maybe<Scalars['String']>;
  /** Test case execution time in seconds. */
  executionTime?: Maybe<Scalars['Float']>;
  /** Path to the file of the test case. */
  file?: Maybe<Scalars['String']>;
  /** Name of the test case. */
  name?: Maybe<Scalars['String']>;
  /** Recent failure history of the test case on the base branch. */
  recentFailures?: Maybe<RecentFailures>;
  /** Stack trace of the test case. */
  stackTrace?: Maybe<Scalars['String']>;
  /** Status of the test case (error, failed, success, skipped). */
  status?: Maybe<TestCaseStatus>;
  /** System output of the test case. */
  systemOutput?: Maybe<Scalars['String']>;
};

/** The connection type for TestCase. */
export type TestCaseConnection = {
  __typename?: 'TestCaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestCaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestCase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestCaseEdge = {
  __typename?: 'TestCaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestCase>;
};

export enum TestCaseStatus {
  /** Test case that has a status of error. */
  Error = 'error',
  /** Test case that has a status of failed. */
  Failed = 'failed',
  /** Test case that has a status of success. */
  Success = 'success',
  /** Test case that has a status of skipped. */
  Skipped = 'skipped'
}

/** Represents a requirement test report */
export type TestReport = {
  __typename?: 'TestReport';
  /** Author of the test report. */
  author?: Maybe<UserCore>;
  /** Timestamp of when the test report was created. */
  createdAt: Scalars['Time'];
  /** ID of the test report. */
  id: Scalars['ID'];
  /** State of the test report. */
  state: TestReportState;
};

/** The connection type for TestReport. */
export type TestReportConnection = {
  __typename?: 'TestReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestReportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestReport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestReportEdge = {
  __typename?: 'TestReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestReport>;
};

/** State of a test report */
export enum TestReportState {
  /** Passed test report. */
  Passed = 'PASSED',
  /** Failed test report. */
  Failed = 'FAILED'
}

/** Test report for a pipeline */
export type TestReportSummary = {
  __typename?: 'TestReportSummary';
  /** Test suites belonging to a pipeline test report. */
  testSuites: TestSuiteSummaryConnection;
  /** Total report statistics for a pipeline test report. */
  total: TestReportTotal;
};


/** Test report for a pipeline */
export type TestReportSummaryTestSuitesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Total test report statistics. */
export type TestReportTotal = {
  __typename?: 'TestReportTotal';
  /** Total number of the test cases. */
  count?: Maybe<Scalars['Int']>;
  /** Total number of test cases that had an error. */
  error?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed. */
  failed?: Maybe<Scalars['Int']>;
  /** Total number of test cases that were skipped. */
  skipped?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded. */
  success?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Total duration of the tests. */
  time?: Maybe<Scalars['Float']>;
};

/** Test suite in a pipeline test report. */
export type TestSuite = {
  __typename?: 'TestSuite';
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Test cases in the test suite. */
  testCases?: Maybe<TestCaseConnection>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']>;
};


/** Test suite in a pipeline test report. */
export type TestSuiteTestCasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Test suite summary in a pipeline test report. */
export type TestSuiteSummary = {
  __typename?: 'TestSuiteSummary';
  /** IDs of the builds used to run the test suite. */
  buildIds?: Maybe<Array<Scalars['ID']>>;
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']>;
};

/** The connection type for TestSuiteSummary. */
export type TestSuiteSummaryConnection = {
  __typename?: 'TestSuiteSummaryConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestSuiteSummaryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestSuiteSummary>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestSuiteSummaryEdge = {
  __typename?: 'TestSuiteSummaryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestSuiteSummary>;
};

/** Represents measured stats metrics for timeboxes */
export type TimeboxMetrics = {
  __typename?: 'TimeboxMetrics';
  /** Count metric. */
  count: Scalars['Int'];
  /** Weight metric. */
  weight: Scalars['Int'];
};

/** Represents a historically accurate report about the timebox */
export type TimeboxReport = {
  __typename?: 'TimeboxReport';
  /** Daily scope and completed totals for burnup charts. */
  burnupTimeSeries?: Maybe<Array<BurnupChartDailyTotals>>;
  /** If the report cannot be generated, information about why. */
  error?: Maybe<TimeboxReportError>;
  /** Represents the time report stats for the timebox. */
  stats?: Maybe<TimeReportStats>;
};

/** Explains why we could not generate a timebox report. */
export type TimeboxReportError = {
  __typename?: 'TimeboxReportError';
  /** Machine readable code, categorizing the error. */
  code?: Maybe<TimeboxReportErrorReason>;
  /** Human readable message explaining what happened. */
  message?: Maybe<Scalars['String']>;
};

/** Category of error. */
export enum TimeboxReportErrorReason {
  /** This type does not support timebox reports. */
  Unsupported = 'UNSUPPORTED',
  /** One or both of start_date and due_date is missing. */
  MissingDates = 'MISSING_DATES',
  /** There are too many events. */
  TooManyEvents = 'TOO_MANY_EVENTS',
  /** Priority by ascending order. */
  PriorityAsc = 'PRIORITY_ASC',
  /** Priority by descending order. */
  PriorityDesc = 'PRIORITY_DESC',
  /** Label priority by ascending order. */
  LabelPriorityAsc = 'LABEL_PRIORITY_ASC',
  /** Label priority by descending order. */
  LabelPriorityDesc = 'LABEL_PRIORITY_DESC',
  /** Milestone due date by ascending order. */
  MilestoneDueAsc = 'MILESTONE_DUE_ASC',
  /** Milestone due date by descending order. */
  MilestoneDueDesc = 'MILESTONE_DUE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

export type TimeboxReportInterface = {
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
};


export type TimeboxReportInterfaceReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** A time-frame defined as a closed inclusive range of two dates */
export type Timeframe = {
  /** Start of the range. */
  start: Scalars['Date'];
  /** End of the range. */
  end: Scalars['Date'];
};

/** Autogenerated input type of TimelineEventCreate */
export type TimelineEventCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Incident ID of the timeline event. */
  incidentId: Scalars['IssueID'];
  /** Text note of the timeline event. */
  note: Scalars['String'];
  /** Timestamp of when the event occurred. */
  occurredAt: Scalars['Time'];
  /** Tags for the incident timeline event. */
  timelineEventTagNames?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of TimelineEventCreate */
export type TimelineEventCreatePayload = {
  __typename?: 'TimelineEventCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventDestroy */
export type TimelineEventDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Timeline event ID to remove. */
  id: Scalars['IncidentManagementTimelineEventID'];
};

/** Autogenerated return type of TimelineEventDestroy */
export type TimelineEventDestroyPayload = {
  __typename?: 'TimelineEventDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventPromoteFromNote */
export type TimelineEventPromoteFromNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Note ID from which the timeline event promoted. */
  noteId: Scalars['NoteID'];
};

/** Autogenerated return type of TimelineEventPromoteFromNote */
export type TimelineEventPromoteFromNotePayload = {
  __typename?: 'TimelineEventPromoteFromNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventTagCreate */
export type TimelineEventTagCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the timeline event tag in. */
  projectPath: Scalars['ID'];
  /** Name of the tag. */
  name: Scalars['String'];
};

/** Autogenerated return type of TimelineEventTagCreate */
export type TimelineEventTagCreatePayload = {
  __typename?: 'TimelineEventTagCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event tag. */
  timelineEventTag?: Maybe<TimelineEventTagType>;
};

/** Describes a tag on an incident management timeline event. */
export type TimelineEventTagType = {
  __typename?: 'TimelineEventTagType';
  /** ID of the timeline event tag. */
  id: Scalars['IncidentManagementTimelineEventTagID'];
  /** Name of the timeline event tag. */
  name: Scalars['String'];
};

/** The connection type for TimelineEventTagType. */
export type TimelineEventTagTypeConnection = {
  __typename?: 'TimelineEventTagTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTagTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventTagType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTagTypeEdge = {
  __typename?: 'TimelineEventTagTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventTagType>;
};

/** Describes an incident management timeline event */
export type TimelineEventType = {
  __typename?: 'TimelineEventType';
  /** Indicates the timeline event icon. */
  action: Scalars['String'];
  /** User that created the timeline event. */
  author?: Maybe<UserCore>;
  /** Timestamp when the event created. */
  createdAt: Scalars['Time'];
  /** Indicates the timeline event is editable. */
  editable: Scalars['Boolean'];
  /** ID of the timeline event. */
  id: Scalars['IncidentManagementTimelineEventID'];
  /** Incident of the timeline event. */
  incident: Issue;
  /** Text note of the timeline event. */
  note?: Maybe<Scalars['String']>;
  /** HTML note of the timeline event. */
  noteHtml?: Maybe<Scalars['String']>;
  /** Timestamp when the event occurred. */
  occurredAt: Scalars['Time'];
  /** Note from which the timeline event was created. */
  promotedFromNote?: Maybe<Note>;
  /** Tags for the incident timeline event. */
  timelineEventTags?: Maybe<TimelineEventTagTypeConnection>;
  /** Timestamp when the event updated. */
  updatedAt: Scalars['Time'];
  /** User that updated the timeline event. */
  updatedByUser?: Maybe<UserCore>;
};


/** Describes an incident management timeline event */
export type TimelineEventTypeTimelineEventTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for TimelineEventType. */
export type TimelineEventTypeConnection = {
  __typename?: 'TimelineEventTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTypeEdge = {
  __typename?: 'TimelineEventTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventUpdate */
export type TimelineEventUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the timeline event to update. */
  id: Scalars['IncidentManagementTimelineEventID'];
  /** Text note of the timeline event. */
  note?: InputMaybe<Scalars['String']>;
  /** Timestamp when the event occurred. */
  occurredAt?: InputMaybe<Scalars['Time']>;
};

/** Autogenerated return type of TimelineEventUpdate */
export type TimelineEventUpdatePayload = {
  __typename?: 'TimelineEventUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

export type Timelog = {
  __typename?: 'Timelog';
  /** Internal ID of the timelog. */
  id: Scalars['ID'];
  /** Issue that logged time was added to. */
  issue?: Maybe<Issue>;
  /** Merge request that logged time was added to. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Note where the quick action was executed to add the logged time. */
  note?: Maybe<Note>;
  /** Timestamp of when the time tracked was spent at. */
  spentAt?: Maybe<Scalars['Time']>;
  /** Summary of how the time was spent. */
  summary?: Maybe<Scalars['String']>;
  /** Time spent displayed in seconds. */
  timeSpent: Scalars['Int'];
  /** User that logged the time. */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: TimelogPermissions;
};

/** The connection type for Timelog. */
export type TimelogConnection = {
  __typename?: 'TimelogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Timelog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TimelogCreate */
export type TimelogCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Amount of time spent. */
  timeSpent: Scalars['String'];
  /** When the time was spent. */
  spentAt: Scalars['Date'];
  /** Summary of time spent. */
  summary: Scalars['String'];
  /** Global ID of the issuable (Issue, WorkItem or MergeRequest). */
  issuableId: Scalars['IssuableID'];
};

/** Autogenerated return type of TimelogCreate */
export type TimelogCreatePayload = {
  __typename?: 'TimelogCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** Autogenerated input type of TimelogDelete */
export type TimelogDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the timelog. */
  id: Scalars['TimelogID'];
};

/** Autogenerated return type of TimelogDelete */
export type TimelogDeletePayload = {
  __typename?: 'TimelogDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** An edge in a connection. */
export type TimelogEdge = {
  __typename?: 'TimelogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Timelog>;
};

export type TimelogPermissions = {
  __typename?: 'TimelogPermissions';
  /** Indicates the user can perform `admin_timelog` on this resource */
  adminTimelog: Scalars['Boolean'];
};

/** Represents the time report stats for timeboxes */
export type TimeReportStats = {
  __typename?: 'TimeReportStats';
  /** Completed issues metrics. */
  complete?: Maybe<TimeboxMetrics>;
  /** Incomplete issues metrics. */
  incomplete?: Maybe<TimeboxMetrics>;
  /** Total issues metrics. */
  total?: Maybe<TimeboxMetrics>;
};

export type TimeTrackingTimelogCategory = {
  __typename?: 'TimeTrackingTimelogCategory';
  /** Whether the category is billable or not. */
  billable?: Maybe<Scalars['Boolean']>;
  /** Billing rate for the category. */
  billingRate?: Maybe<Scalars['Float']>;
  /** Color assigned to the category. */
  color?: Maybe<Scalars['Color']>;
  /** When the category was created. */
  createdAt: Scalars['Time'];
  /** Description of the category. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the timelog category. */
  id: Scalars['ID'];
  /** Name of the category. */
  name: Scalars['String'];
  /** When the category was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for TimeTrackingTimelogCategory. */
export type TimeTrackingTimelogCategoryConnection = {
  __typename?: 'TimeTrackingTimelogCategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimeTrackingTimelogCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimeTrackingTimelogCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimeTrackingTimelogCategoryEdge = {
  __typename?: 'TimeTrackingTimelogCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimeTrackingTimelogCategory>;
};

/** Representing a to-do entry */
export type Todo = {
  __typename?: 'Todo';
  /** Action of the to-do item. */
  action: TodoActionEnum;
  /** Author of this to-do item. */
  author: UserCore;
  /** Body of the to-do item. */
  body: Scalars['String'];
  /** Timestamp this to-do item was created. */
  createdAt: Scalars['Time'];
  /** Group this to-do item is associated with. */
  group?: Maybe<Group>;
  /** ID of the to-do item. */
  id: Scalars['ID'];
  /** Note which created this to-do item. */
  note?: Maybe<Note>;
  /** Project this to-do item is associated with. */
  project?: Maybe<Project>;
  /** State of the to-do item. */
  state: TodoStateEnum;
  /** Target of the to-do item. */
  target: Todoable;
  /** Target type of the to-do item. */
  targetType: TodoTargetEnum;
};

export type Todoable = {
  /** URL of this object. */
  webUrl?: Maybe<Scalars['String']>;
};

export enum TodoActionEnum {
  /** User was assigned. */
  Assigned = 'assigned',
  /** User was mentioned. */
  Mentioned = 'mentioned',
  /** Build triggered by the user failed. */
  BuildFailed = 'build_failed',
  /** User added a TODO. */
  Marked = 'marked',
  /** User was set as an approver. */
  ApprovalRequired = 'approval_required',
  /** Merge request authored by the user could not be merged. */
  Unmergeable = 'unmergeable',
  /** User was directly addressed. */
  DirectlyAddressed = 'directly_addressed',
  /** Merge request authored by the user was removed from the merge train. */
  MergeTrainRemoved = 'merge_train_removed',
  /** Review was requested from the user. */
  ReviewRequested = 'review_requested'
}

/** The connection type for Todo. */
export type TodoConnection = {
  __typename?: 'TodoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TodoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Todo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TodoCreate */
export type TodoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. */
  targetId: Scalars['TodoableID'];
};

/** Autogenerated return type of TodoCreate */
export type TodoCreatePayload = {
  __typename?: 'TodoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** To-do item created. */
  todo?: Maybe<Todo>;
};

/** An edge in a connection. */
export type TodoEdge = {
  __typename?: 'TodoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Todo>;
};

/** Autogenerated input type of TodoMarkDone */
export type TodoMarkDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item to mark as done. */
  id: Scalars['TodoID'];
};

/** Autogenerated return type of TodoMarkDone */
export type TodoMarkDonePayload = {
  __typename?: 'TodoMarkDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodoRestore */
export type TodoRestoreInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item to restore. */
  id: Scalars['TodoID'];
};

/** Autogenerated input type of TodoRestoreMany */
export type TodoRestoreManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global IDs of the to-do items to restore (a maximum of 50 is supported at once). */
  ids: Array<Scalars['TodoID']>;
};

/** Autogenerated return type of TodoRestoreMany */
export type TodoRestoreManyPayload = {
  __typename?: 'TodoRestoreManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated to-do items. */
  todos: Array<Todo>;
};

/** Autogenerated return type of TodoRestore */
export type TodoRestorePayload = {
  __typename?: 'TodoRestorePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodosMarkAllDone */
export type TodosMarkAllDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Global ID of the to-do item's parent. Issues, merge requests, designs, and
   * epics are supported. If argument is omitted, all pending to-do items of the
   * current user are marked as done.
   */
  targetId?: InputMaybe<Scalars['TodoableID']>;
};

/** Autogenerated return type of TodosMarkAllDone */
export type TodosMarkAllDonePayload = {
  __typename?: 'TodosMarkAllDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated to-do items. */
  todos: Array<Todo>;
};

export enum TodoStateEnum {
  /** State of the todo is pending. */
  Pending = 'pending',
  /** State of the todo is done. */
  Done = 'done'
}

export enum TodoTargetEnum {
  /** Commit. */
  Commit = 'COMMIT',
  /** Issue. */
  Issue = 'ISSUE',
  /** Work item. */
  Workitem = 'WORKITEM',
  /** Merge request. */
  Mergerequest = 'MERGEREQUEST',
  /** Design. */
  Design = 'DESIGN',
  /** Alert. */
  Alert = 'ALERT',
  /** An Epic. */
  Epic = 'EPIC'
}

export type Topic = {
  __typename?: 'Topic';
  /** URL to avatar image file of the topic. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Description of the topic. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** ID of the topic. */
  id: Scalars['ID'];
  /** Name of the topic. */
  name: Scalars['String'];
  /** Title of the topic. */
  title: Scalars['String'];
};

/** The connection type for Topic. */
export type TopicConnection = {
  __typename?: 'TopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Topic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TopicEdge = {
  __typename?: 'TopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Topic>;
};

/**
 * Status of the request to the training provider. The URL of a TrainingUrl is
 * calculated asynchronously. When PENDING, the URL of the TrainingUrl will be
 * null. When COMPLETED, the URL of the TrainingUrl will be available.
 */
export enum TrainingUrlRequestStatus {
  /** Pending request. */
  Pending = 'PENDING',
  /** Completed request. */
  Completed = 'COMPLETED'
}

export type Tree = {
  __typename?: 'Tree';
  /** Blobs of the tree. */
  blobs: BlobConnection;
  /** Last commit for the tree. */
  lastCommit?: Maybe<Commit>;
  /** Sub-modules of the tree. */
  submodules: SubmoduleConnection;
  /** Trees of the tree. */
  trees: TreeEntryConnection;
};


export type TreeBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type TreeSubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type TreeTreesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Tree. */
export type TreeConnection = {
  __typename?: 'TreeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Tree>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEdge = {
  __typename?: 'TreeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Tree>;
};

/** Represents a directory */
export type TreeEntry = Entry & {
  __typename?: 'TreeEntry';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path for the tree entry (directory). */
  webPath?: Maybe<Scalars['String']>;
  /** Web URL for the tree entry (directory). */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for TreeEntry. */
export type TreeEntryConnection = {
  __typename?: 'TreeEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TreeEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEntryEdge = {
  __typename?: 'TreeEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TreeEntry>;
};

export enum TypeEnum {
  /** Snippet created independent of any project. */
  Personal = 'personal',
  /** Snippet related to a specific project. */
  Project = 'project'
}

export type UnionedIssueFilterInput = {
  /** Filters issues that are assigned to at least one of the given users. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  /** Filters issues that are authored by one of the given users. */
  authorUsernames?: InputMaybe<Array<Scalars['String']>>;
};

/** Defines which user roles, users, or groups can unprotect a protected branch. */
export type UnprotectAccessLevel = {
  __typename?: 'UnprotectAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for UnprotectAccessLevel. */
export type UnprotectAccessLevelConnection = {
  __typename?: 'UnprotectAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UnprotectAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UnprotectAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UnprotectAccessLevelEdge = {
  __typename?: 'UnprotectAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UnprotectAccessLevel>;
};

/** Autogenerated input type of UpdateAlertStatus */
export type UpdateAlertStatusInput = {
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Status to set the alert. */
  status: AlertManagementStatus;
};

/** Autogenerated return type of UpdateAlertStatus */
export type UpdateAlertStatusPayload = {
  __typename?: 'UpdateAlertStatusPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of UpdateBoardEpicUserPreferences */
export type UpdateBoardEpicUserPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Board global ID. */
  boardId: Scalars['BoardID'];
  /** ID of an epic to set preferences for. */
  epicId: Scalars['EpicID'];
  /** Whether the epic should be collapsed in the board. */
  collapsed: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateBoardEpicUserPreferences */
export type UpdateBoardEpicUserPreferencesPayload = {
  __typename?: 'UpdateBoardEpicUserPreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** User preferences for the epic in the board after mutation. */
  epicUserPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateBoard */
export type UpdateBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** Board global ID. */
  id: Scalars['BoardID'];
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
};

/** Autogenerated input type of UpdateBoardList */
export type UpdateBoardListInput = {
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']>;
  /** Indicates if the list is collapsed for this user. */
  collapsed?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the list. */
  listId: Scalars['ListID'];
};

/** Autogenerated return type of UpdateBoardList */
export type UpdateBoardListPayload = {
  __typename?: 'UpdateBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Mutated list. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of UpdateBoard */
export type UpdateBoardPayload = {
  __typename?: 'UpdateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateComplianceFramework */
export type UpdateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the compliance framework to update. */
  id: Scalars['ComplianceManagementFrameworkID'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of UpdateComplianceFramework */
export type UpdateComplianceFrameworkPayload = {
  __typename?: 'UpdateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Compliance framework after mutation. */
  complianceFramework?: Maybe<ComplianceFramework>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateContainerExpirationPolicy */
export type UpdateContainerExpirationPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project path where the container expiration policy is located. */
  projectPath: Scalars['ID'];
  /** Indicates whether this container expiration policy is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** This container expiration policy schedule. */
  cadence?: InputMaybe<ContainerExpirationPolicyCadenceEnum>;
  /** Tags older that this will expire. */
  olderThan?: InputMaybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Number of tags to retain. */
  keepN?: InputMaybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching this regex pattern will expire. */
  nameRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Tags with names matching this regex pattern will be preserved. */
  nameRegexKeep?: InputMaybe<Scalars['UntrustedRegexp']>;
};

/** Autogenerated return type of UpdateContainerExpirationPolicy */
export type UpdateContainerExpirationPolicyPayload = {
  __typename?: 'UpdateContainerExpirationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Container expiration policy after mutation. */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateDependencyProxyImageTtlGroupPolicy */
export type UpdateDependencyProxyImageTtlGroupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group path for the group dependency proxy image TTL policy. */
  groupPath: Scalars['ID'];
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Number of days to retain a cached image file. */
  ttl?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateDependencyProxyImageTtlGroupPolicy */
export type UpdateDependencyProxyImageTtlGroupPolicyPayload = {
  __typename?: 'UpdateDependencyProxyImageTtlGroupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Group image TTL policy after mutation. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateDependencyProxySettings */
export type UpdateDependencyProxySettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group path for the group dependency proxy. */
  groupPath: Scalars['ID'];
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateDependencyProxySettings */
export type UpdateDependencyProxySettingsPayload = {
  __typename?: 'UpdateDependencyProxySettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Group dependency proxy settings after mutation. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type UpdateDiffImagePositionInput = {
  /** X position of the note. */
  x?: InputMaybe<Scalars['Int']>;
  /** Y position of the note. */
  y?: InputMaybe<Scalars['Int']>;
  /** Total width of the image. */
  width?: InputMaybe<Scalars['Int']>;
  /** Total height of the image. */
  height?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of UpdateEpicBoardList */
export type UpdateEpicBoardListInput = {
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']>;
  /** Indicates if the list is collapsed for this user. */
  collapsed?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic list. */
  listId: Scalars['BoardsEpicListID'];
};

/** Autogenerated return type of UpdateEpicBoardList */
export type UpdateEpicBoardListPayload = {
  __typename?: 'UpdateEpicBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Mutated epic list. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of UpdateEpic */
export type UpdateEpicInput = {
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID'];
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']>>;
  /**
   * Color of the epic. Available only when feature flag `epic_color_highlight` is
   * enabled. This flag is disabled by default, because the feature is experimental
   * and is subject to change without notice.
   */
  color?: InputMaybe<Scalars['Color']>;
  /** State event for the epic. */
  stateEvent?: InputMaybe<EpicStateEvent>;
  /** Array of labels to be removed from the epic. */
  removeLabels?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of UpdateEpic */
export type UpdateEpicPayload = {
  __typename?: 'UpdateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateImageDiffNote */
export type UpdateImageDiffNoteInput = {
  /** Global ID of the note to update. */
  id: Scalars['NoteID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']>;
  /** Position of this note on a diff. */
  position?: InputMaybe<UpdateDiffImagePositionInput>;
};

/** Autogenerated return type of UpdateImageDiffNote */
export type UpdateImageDiffNotePayload = {
  __typename?: 'UpdateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Title of the issue. */
  title?: InputMaybe<Scalars['String']>;
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** IDs of labels to be added to the issue. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** IDs of labels to be removed from the issue. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** IDs of labels to be set. Replaces existing issue labels. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Close or reopen an issue. */
  stateEvent?: InputMaybe<IssueStateEvent>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']>;
  /** ID of the parent epic. NULL when removing the association. */
  epicId?: InputMaybe<Scalars['EpicID']>;
};

/** Autogenerated return type of UpdateIssue */
export type UpdateIssuePayload = {
  __typename?: 'UpdateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateIteration */
export type UpdateIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group of the iteration. */
  groupPath: Scalars['ID'];
  /** Global ID of the iteration. */
  id: Scalars['ID'];
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIteration */
export type UpdateIterationPayload = {
  __typename?: 'UpdateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of UpdateNamespacePackageSettings */
export type UpdateNamespacePackageSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Namespace path where the namespace package setting is located. */
  namespacePath: Scalars['ID'];
  /** Indicates whether duplicate Maven packages are allowed for this namespace. */
  mavenDuplicatesAllowed?: InputMaybe<Scalars['Boolean']>;
  /**
   * When maven_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  mavenDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate generic packages are allowed for this namespace. */
  genericDuplicatesAllowed?: InputMaybe<Scalars['Boolean']>;
  /**
   * When generic_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  genericDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether Maven package forwarding is allowed for this namespace. */
  mavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether npm package forwarding is allowed for this namespace. */
  npmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding is allowed for this namespace. */
  pypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateNamespacePackageSettings */
export type UpdateNamespacePackageSettingsPayload = {
  __typename?: 'UpdateNamespacePackageSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace package setting after mutation. */
  packageSettings?: Maybe<PackageSettings>;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  /** Global ID of the note to update. */
  id: Scalars['NoteID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateNote */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of UpdatePackagesCleanupPolicy */
export type UpdatePackagesCleanupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID'];
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles?: InputMaybe<PackagesCleanupKeepDuplicatedPackageFilesEnum>;
};

/** Autogenerated return type of UpdatePackagesCleanupPolicy */
export type UpdatePackagesCleanupPolicyPayload = {
  __typename?: 'UpdatePackagesCleanupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Packages cleanup policy after mutation. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
};

/** Autogenerated input type of UpdateRequirement */
export type UpdateRequirementInput = {
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** State of the requirement. */
  state?: InputMaybe<RequirementState>;
  /** IID of the requirement to update. */
  iid: Scalars['String'];
  /** Creates a test report for the requirement with the given state. */
  lastTestReportState?: InputMaybe<TestReportState>;
};

/** Autogenerated return type of UpdateRequirement */
export type UpdateRequirementPayload = {
  __typename?: 'UpdateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of UpdateSnippet */
export type UpdateSnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID'];
  /** Title of the snippet. */
  title?: InputMaybe<Scalars['String']>;
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']>;
  /** Visibility level of the snippet. */
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
};

/** Autogenerated return type of UpdateSnippet */
export type UpdateSnippetPayload = {
  __typename?: 'UpdateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Autogenerated input type of UploadDelete */
export type UploadDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Secret part of upload path. */
  secret: Scalars['String'];
  /** Upload filename. */
  filename: Scalars['String'];
};

/** Autogenerated return type of UploadDelete */
export type UploadDeletePayload = {
  __typename?: 'UploadDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted upload. */
  upload?: Maybe<FileUpload>;
};

/** Represents the Geo replication and verification state of an upload. */
export type UploadRegistry = {
  __typename?: 'UploadRegistry';
  /** Timestamp when the UploadRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Upload. */
  fileId: Scalars['ID'];
  /** ID of the UploadRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the UploadRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the UploadRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the UploadRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the UploadRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the UploadRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the UploadRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the UploadRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for UploadRegistry. */
export type UploadRegistryConnection = {
  __typename?: 'UploadRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UploadRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UploadRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UploadRegistryEdge = {
  __typename?: 'UploadRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UploadRegistry>;
};

/** Represents a recorded measurement (object count) for the Admins */
export type UsageTrendsMeasurement = {
  __typename?: 'UsageTrendsMeasurement';
  /** Object count. */
  count: Scalars['Int'];
  /** Type of objects being measured. */
  identifier: MeasurementIdentifier;
  /** Time the measurement was recorded. */
  recordedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for UsageTrendsMeasurement. */
export type UsageTrendsMeasurementConnection = {
  __typename?: 'UsageTrendsMeasurementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UsageTrendsMeasurementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UsageTrendsMeasurement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UsageTrendsMeasurementEdge = {
  __typename?: 'UsageTrendsMeasurementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UsageTrendsMeasurement>;
};

/** Representation of a GitLab user. */
export type User = {
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** Representation of a GitLab user. */
export type UserAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type UserCallout = {
  __typename?: 'UserCallout';
  /** Date when the callout was dismissed. */
  dismissedAt?: Maybe<Scalars['Time']>;
  /** Name of the feature that the callout is for. */
  featureName?: Maybe<UserCalloutFeatureNameEnum>;
};

/** The connection type for UserCallout. */
export type UserCalloutConnection = {
  __typename?: 'UserCalloutConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCalloutEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCallout>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserCalloutCreate */
export type UserCalloutCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Feature name you want to dismiss the callout for. */
  featureName: Scalars['String'];
};

/** Autogenerated return type of UserCalloutCreate */
export type UserCalloutCreatePayload = {
  __typename?: 'UserCalloutCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User callout dismissed. */
  userCallout: UserCallout;
};

/** An edge in a connection. */
export type UserCalloutEdge = {
  __typename?: 'UserCalloutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCallout>;
};

/** Name of the feature that the callout is for. */
export enum UserCalloutFeatureNameEnum {
  /** Callout feature name for gke_cluster_integration. */
  GkeClusterIntegration = 'GKE_CLUSTER_INTEGRATION',
  /** Callout feature name for gcp_signup_offer. */
  GcpSignupOffer = 'GCP_SIGNUP_OFFER',
  /** Callout feature name for cluster_security_warning. */
  ClusterSecurityWarning = 'CLUSTER_SECURITY_WARNING',
  /** Callout feature name for ultimate_trial. */
  UltimateTrial = 'ULTIMATE_TRIAL',
  /** Callout feature name for geo_enable_hashed_storage. */
  GeoEnableHashedStorage = 'GEO_ENABLE_HASHED_STORAGE',
  /** Callout feature name for geo_migrate_hashed_storage. */
  GeoMigrateHashedStorage = 'GEO_MIGRATE_HASHED_STORAGE',
  /** Callout feature name for canary_deployment. */
  CanaryDeployment = 'CANARY_DEPLOYMENT',
  /** Callout feature name for gold_trial_billings. */
  GoldTrialBillings = 'GOLD_TRIAL_BILLINGS',
  /** Callout feature name for suggest_popover_dismissed. */
  SuggestPopoverDismissed = 'SUGGEST_POPOVER_DISMISSED',
  /** Callout feature name for tabs_position_highlight. */
  TabsPositionHighlight = 'TABS_POSITION_HIGHLIGHT',
  /** Callout feature name for threat_monitoring_info. */
  ThreatMonitoringInfo = 'THREAT_MONITORING_INFO',
  /** Callout feature name for two_factor_auth_recovery_settings_check. */
  TwoFactorAuthRecoverySettingsCheck = 'TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK',
  /** Callout feature name for web_ide_alert_dismissed. */
  WebIdeAlertDismissed = 'WEB_IDE_ALERT_DISMISSED',
  /** Callout feature name for active_user_count_threshold. */
  ActiveUserCountThreshold = 'ACTIVE_USER_COUNT_THRESHOLD',
  /** Callout feature name for buy_pipeline_minutes_notification_dot. */
  BuyPipelineMinutesNotificationDot = 'BUY_PIPELINE_MINUTES_NOTIFICATION_DOT',
  /** Callout feature name for personal_access_token_expiry. */
  PersonalAccessTokenExpiry = 'PERSONAL_ACCESS_TOKEN_EXPIRY',
  /** Callout feature name for suggest_pipeline. */
  SuggestPipeline = 'SUGGEST_PIPELINE',
  /** Callout feature name for feature_flags_new_version. */
  FeatureFlagsNewVersion = 'FEATURE_FLAGS_NEW_VERSION',
  /** Callout feature name for registration_enabled_callout. */
  RegistrationEnabledCallout = 'REGISTRATION_ENABLED_CALLOUT',
  /** Callout feature name for new_user_signups_cap_reached. */
  NewUserSignupsCapReached = 'NEW_USER_SIGNUPS_CAP_REACHED',
  /** Callout feature name for unfinished_tag_cleanup_callout. */
  UnfinishedTagCleanupCallout = 'UNFINISHED_TAG_CLEANUP_CALLOUT',
  /** Callout feature name for eoa_bronze_plan_banner. */
  EoaBronzePlanBanner = 'EOA_BRONZE_PLAN_BANNER',
  /** Callout feature name for pipeline_needs_banner. */
  PipelineNeedsBanner = 'PIPELINE_NEEDS_BANNER',
  /** Callout feature name for pipeline_needs_hover_tip. */
  PipelineNeedsHoverTip = 'PIPELINE_NEEDS_HOVER_TIP',
  /** Callout feature name for web_ide_ci_environments_guidance. */
  WebIdeCiEnvironmentsGuidance = 'WEB_IDE_CI_ENVIRONMENTS_GUIDANCE',
  /** Callout feature name for security_configuration_upgrade_banner. */
  SecurityConfigurationUpgradeBanner = 'SECURITY_CONFIGURATION_UPGRADE_BANNER',
  /** Callout feature name for cloud_licensing_subscription_activation_banner. */
  CloudLicensingSubscriptionActivationBanner = 'CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER',
  /** Callout feature name for trial_status_reminder_d14. */
  TrialStatusReminderD14 = 'TRIAL_STATUS_REMINDER_D14',
  /** Callout feature name for trial_status_reminder_d3. */
  TrialStatusReminderD3 = 'TRIAL_STATUS_REMINDER_D3',
  /** Callout feature name for security_configuration_devops_alert. */
  SecurityConfigurationDevopsAlert = 'SECURITY_CONFIGURATION_DEVOPS_ALERT',
  /** Callout feature name for profile_personal_access_token_expiry. */
  ProfilePersonalAccessTokenExpiry = 'PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY',
  /** Callout feature name for terraform_notification_dismissed. */
  TerraformNotificationDismissed = 'TERRAFORM_NOTIFICATION_DISMISSED',
  /** Callout feature name for security_newsletter_callout. */
  SecurityNewsletterCallout = 'SECURITY_NEWSLETTER_CALLOUT',
  /** Callout feature name for verification_reminder. */
  VerificationReminder = 'VERIFICATION_REMINDER',
  /** Callout feature name for ci_deprecation_warning_for_types_keyword. */
  CiDeprecationWarningForTypesKeyword = 'CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD',
  /** Callout feature name for security_training_feature_promotion. */
  SecurityTrainingFeaturePromotion = 'SECURITY_TRAINING_FEATURE_PROMOTION',
  /** Callout feature name for storage_enforcement_banner_first_enforcement_threshold. */
  StorageEnforcementBannerFirstEnforcementThreshold = 'STORAGE_ENFORCEMENT_BANNER_FIRST_ENFORCEMENT_THRESHOLD',
  /** Callout feature name for storage_enforcement_banner_second_enforcement_threshold. */
  StorageEnforcementBannerSecondEnforcementThreshold = 'STORAGE_ENFORCEMENT_BANNER_SECOND_ENFORCEMENT_THRESHOLD',
  /** Callout feature name for storage_enforcement_banner_third_enforcement_threshold. */
  StorageEnforcementBannerThirdEnforcementThreshold = 'STORAGE_ENFORCEMENT_BANNER_THIRD_ENFORCEMENT_THRESHOLD',
  /** Callout feature name for storage_enforcement_banner_fourth_enforcement_threshold. */
  StorageEnforcementBannerFourthEnforcementThreshold = 'STORAGE_ENFORCEMENT_BANNER_FOURTH_ENFORCEMENT_THRESHOLD',
  /** Callout feature name for preview_user_over_limit_free_plan_alert. */
  PreviewUserOverLimitFreePlanAlert = 'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT',
  /** Callout feature name for user_reached_limit_free_plan_alert. */
  UserReachedLimitFreePlanAlert = 'USER_REACHED_LIMIT_FREE_PLAN_ALERT',
  /** Callout feature name for submit_license_usage_data_banner. */
  SubmitLicenseUsageDataBanner = 'SUBMIT_LICENSE_USAGE_DATA_BANNER',
  /** Callout feature name for personal_project_limitations_banner. */
  PersonalProjectLimitationsBanner = 'PERSONAL_PROJECT_LIMITATIONS_BANNER',
  /** Callout feature name for mr_experience_survey. */
  MrExperienceSurvey = 'MR_EXPERIENCE_SURVEY',
  /** Callout feature name for namespace_storage_limit_banner_info_threshold. */
  NamespaceStorageLimitBannerInfoThreshold = 'NAMESPACE_STORAGE_LIMIT_BANNER_INFO_THRESHOLD',
  /** Callout feature name for namespace_storage_limit_banner_warning_threshold. */
  NamespaceStorageLimitBannerWarningThreshold = 'NAMESPACE_STORAGE_LIMIT_BANNER_WARNING_THRESHOLD',
  /** Callout feature name for namespace_storage_limit_banner_alert_threshold. */
  NamespaceStorageLimitBannerAlertThreshold = 'NAMESPACE_STORAGE_LIMIT_BANNER_ALERT_THRESHOLD',
  /** Callout feature name for namespace_storage_limit_banner_error_threshold. */
  NamespaceStorageLimitBannerErrorThreshold = 'NAMESPACE_STORAGE_LIMIT_BANNER_ERROR_THRESHOLD',
  /** Callout feature name for project_quality_summary_feedback. */
  ProjectQualitySummaryFeedback = 'PROJECT_QUALITY_SUMMARY_FEEDBACK',
  /** Callout feature name for merge_request_settings_moved_callout. */
  MergeRequestSettingsMovedCallout = 'MERGE_REQUEST_SETTINGS_MOVED_CALLOUT',
  /** Callout feature name for new_top_level_group_alert. */
  NewTopLevelGroupAlert = 'NEW_TOP_LEVEL_GROUP_ALERT',
  /** Callout feature name for artifacts_management_page_feedback_banner. */
  ArtifactsManagementPageFeedbackBanner = 'ARTIFACTS_MANAGEMENT_PAGE_FEEDBACK_BANNER'
}

/** Core represention of a GitLab user. */
export type UserCore = User & {
  __typename?: 'UserCore';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};


/** Core represention of a GitLab user. */
export type UserCoreAssignedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreAuthoredMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreGroupsArgs = {
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreReviewRequestedMergeRequestsArgs = {
  iids?: InputMaybe<Array<Scalars['String']>>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  draft?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectPath?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreSnippetsArgs = {
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
  type?: InputMaybe<TypeEnum>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreStarredProjectsArgs = {
  search?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreTimelogsArgs = {
  startDate?: InputMaybe<Scalars['Time']>;
  endDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  username?: InputMaybe<Scalars['String']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for UserCore. */
export type UserCoreConnection = {
  __typename?: 'UserCoreConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCoreEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCore>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserCoreEdge = {
  __typename?: 'UserCoreEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCore>;
};

/**
 * Information about a merge request given a specific user.
 *
 * This object has two parts to its state: a `User` and a `MergeRequest`. All
 * fields relate to interactions between the two entities.
 */
export type UserMergeRequestInteraction = {
  __typename?: 'UserMergeRequestInteraction';
  /** Approval rules that apply to this user for this merge request. */
  applicableApprovalRules?: Maybe<Array<ApprovalRule>>;
  /** Whether this user has approved this merge request. */
  approved: Scalars['Boolean'];
  /** Whether this user can merge this merge request. */
  canMerge: Scalars['Boolean'];
  /** Whether this user can update this merge request. */
  canUpdate: Scalars['Boolean'];
  /** State of the review by this user. */
  reviewState?: Maybe<MergeRequestReviewState>;
  /** Whether this user has provided a review for this merge request. */
  reviewed: Scalars['Boolean'];
};

export type UserPermissions = {
  __typename?: 'UserPermissions';
  /** Indicates the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean'];
};

export type UserPreferences = {
  __typename?: 'UserPreferences';
  /** Sort order for issue lists. */
  issuesSort?: Maybe<IssueSort>;
};

/** Autogenerated input type of UserPreferencesUpdate */
export type UserPreferencesUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sort order for issue lists. */
  issuesSort?: InputMaybe<IssueSort>;
};

/** Autogenerated return type of UserPreferencesUpdate */
export type UserPreferencesUpdatePayload = {
  __typename?: 'UserPreferencesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User preferences after mutation. */
  userPreferences?: Maybe<UserPreferences>;
};

/** Possible states of a user */
export enum UserState {
  /** User is active and is able to use the system. */
  Active = 'active',
  /** User has been blocked and is prevented from using the system. */
  Blocked = 'blocked',
  /** User is no longer active and is unable to use the system. */
  Deactivated = 'deactivated'
}

export type UserStatus = {
  __typename?: 'UserStatus';
  /** User availability status. */
  availability: AvailabilityEnum;
  /** String representation of emoji. */
  emoji?: Maybe<Scalars['String']>;
  /** User status message. */
  message?: Maybe<Scalars['String']>;
  /** HTML of the user status message */
  messageHtml?: Maybe<Scalars['String']>;
};

export enum VerificationStateEnum {
  /** Verification process has not started. */
  Pending = 'PENDING',
  /** Verification process is in progress. */
  Started = 'STARTED',
  /** Verification process finished successfully. */
  Succeeded = 'SUCCEEDED',
  /** Verification process finished but failed. */
  Failed = 'FAILED',
  /** Verification process is disabled. */
  Disabled = 'DISABLED'
}

/** Verification status of a GPG or X.509 signature for a commit. */
export enum VerificationStatus {
  /** unverified verification status. */
  Unverified = 'UNVERIFIED',
  /** verified verification status. */
  Verified = 'VERIFIED',
  /** same_user_different_email verification status. */
  SameUserDifferentEmail = 'SAME_USER_DIFFERENT_EMAIL',
  /** other_user verification status. */
  OtherUser = 'OTHER_USER',
  /** unverified_key verification status. */
  UnverifiedKey = 'UNVERIFIED_KEY',
  /** unknown_key verification status. */
  UnknownKey = 'UNKNOWN_KEY',
  /** multiple_signatures verification status. */
  MultipleSignatures = 'MULTIPLE_SIGNATURES'
}

export enum VisibilityLevelsEnum {
  /** Private visibility level. */
  Private = 'private',
  /** Internal visibility level. */
  Internal = 'internal',
  /** Public visibility level. */
  Public = 'public'
}

export enum VisibilityScopesEnum {
  /** Snippet is visible only to the snippet creator. */
  Private = 'private',
  /** Snippet is visible for any logged in user except external users. */
  Internal = 'internal',
  /** Snippet can be accessed without any authentication. */
  Public = 'public'
}

/** Represents the count of vulnerabilities by severity on a particular day. This data is retained for 365 days */
export type VulnerabilitiesCountByDay = {
  __typename?: 'VulnerabilitiesCountByDay';
  /** Total number of vulnerabilities on a particular day with critical severity */
  critical: Scalars['Int'];
  /** Date for the count. */
  date: Scalars['ISO8601Date'];
  /** Total number of vulnerabilities on a particular day with high severity */
  high: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with info severity */
  info: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with low severity */
  low: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with medium severity */
  medium: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day. */
  total: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with unknown severity */
  unknown: Scalars['Int'];
};

/** The connection type for VulnerabilitiesCountByDay. */
export type VulnerabilitiesCountByDayConnection = {
  __typename?: 'VulnerabilitiesCountByDayConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilitiesCountByDayEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilitiesCountByDay>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilitiesCountByDayEdge = {
  __typename?: 'VulnerabilitiesCountByDayEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilitiesCountByDay>;
};

/** Represents a vulnerability */
export type Vulnerability = NoteableInterface & {
  __typename?: 'Vulnerability';
  /** Timestamp of when the vulnerability state was changed to confirmed. */
  confirmedAt?: Maybe<Scalars['Time']>;
  /** User that confirmed the vulnerability. */
  confirmedBy?: Maybe<UserCore>;
  /** Description of the vulnerability. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Details of the vulnerability. */
  details: Array<VulnerabilityDetail>;
  /** Timestamp of when the vulnerability was first detected. */
  detectedAt: Scalars['Time'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Timestamp of when the vulnerability state was changed to dismissed. */
  dismissedAt?: Maybe<Scalars['Time']>;
  /** User that dismissed the vulnerability. */
  dismissedBy?: Maybe<UserCore>;
  /** List of external issue links related to the vulnerability. */
  externalIssueLinks: VulnerabilityExternalIssueLinkConnection;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']>;
  /** Indicates whether there is a solution available for this vulnerability. */
  hasSolutions?: Maybe<Scalars['Boolean']>;
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID'];
  /** Identifiers of the vulnerability. */
  identifiers: Array<VulnerabilityIdentifier>;
  /** List of issue links related to the vulnerability. */
  issueLinks: VulnerabilityIssueLinkConnection;
  /** List of links associated with the vulnerability. */
  links: Array<VulnerabilityLink>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Short text description of the vulnerability. This may include the finding's specific information. */
  message?: Maybe<Scalars['String']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Primary identifier of the vulnerability. */
  primaryIdentifier?: Maybe<VulnerabilityIdentifier>;
  /** Project on which the vulnerability was found. */
  project?: Maybe<Project>;
  /**
   * Type of the security report that found the vulnerability (SAST,
   * DEPENDENCY_SCANNING, CONTAINER_SCANNING, DAST, SECRET_DETECTION,
   * COVERAGE_FUZZING, API_FUZZING, CLUSTER_IMAGE_SCANNING, GENERIC). `Scan Type` in the UI.
   */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Timestamp of when the vulnerability state was changed to resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User that resolved the vulnerability. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether the vulnerability is fixed on the default branch or not. */
  resolvedOnDefaultBranch: Scalars['Boolean'];
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability (INFO, UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL) */
  severity?: Maybe<VulnerabilitySeverity>;
  /** State of the vulnerability (DETECTED, CONFIRMED, RESOLVED, DISMISSED) */
  state?: Maybe<VulnerabilityState>;
  /** Title of the vulnerability. */
  title?: Maybe<Scalars['String']>;
  /** Number of user notes attached to the vulnerability. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: VulnerabilityPermissions;
  /** Path to the vulnerability's details page. */
  vulnerabilityPath?: Maybe<Scalars['String']>;
  /** URL to the vulnerability's details page. */
  webUrl?: Maybe<Scalars['String']>;
};


/** Represents a vulnerability */
export type VulnerabilityDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityExternalIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityIssueLinksArgs = {
  linkType?: InputMaybe<VulnerabilityIssueLinkType>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Confidence that a given vulnerability is present in the codebase. */
export enum VulnerabilityConfidence {
  /** Ignore confidence */
  Ignore = 'IGNORE',
  /** Unknown confidence */
  Unknown = 'UNKNOWN',
  /** Experimental confidence */
  Experimental = 'EXPERIMENTAL',
  /** Low confidence */
  Low = 'LOW',
  /** Medium confidence */
  Medium = 'MEDIUM',
  /** High confidence */
  High = 'HIGH',
  /** Confirmed confidence */
  Confirmed = 'CONFIRMED'
}

/** Autogenerated input type of VulnerabilityConfirm */
export type VulnerabilityConfirmInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be confirmed. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityConfirm */
export type VulnerabilityConfirmPayload = {
  __typename?: 'VulnerabilityConfirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** The connection type for Vulnerability. */
export type VulnerabilityConnection = {
  __typename?: 'VulnerabilityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Vulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a container image reported on the related vulnerability */
export type VulnerabilityContainerImage = {
  __typename?: 'VulnerabilityContainerImage';
  /** Name of the container image. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for VulnerabilityContainerImage. */
export type VulnerabilityContainerImageConnection = {
  __typename?: 'VulnerabilityContainerImageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityContainerImageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityContainerImage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityContainerImageEdge = {
  __typename?: 'VulnerabilityContainerImageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityContainerImage>;
};

/** Autogenerated input type of VulnerabilityCreate */
export type VulnerabilityCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to attach the vulnerability to. */
  project: Scalars['ProjectID'];
  /** Name of the vulnerability. */
  name: Scalars['String'];
  /** Long text section that describes the vulnerability in more detail. */
  description: Scalars['String'];
  /** Information about the scanner used to discover the vulnerability. */
  scanner: VulnerabilityScannerInput;
  /** Array of CVE or CWE identifiers for the vulnerability. */
  identifiers: Array<VulnerabilityIdentifierInput>;
  /** State of the vulnerability (defaults to `detected`). */
  state?: InputMaybe<VulnerabilityState>;
  /** Severity of the vulnerability (defaults to `unknown`). */
  severity?: InputMaybe<VulnerabilitySeverity>;
  /** Instructions for how to fix the vulnerability. */
  solution?: InputMaybe<Scalars['String']>;
  /** Short text section that describes the vulnerability. This may include the finding's specific information. */
  message?: InputMaybe<Scalars['String']>;
  /** Timestamp of when the vulnerability was first detected (defaults to creation time). */
  detectedAt?: InputMaybe<Scalars['Time']>;
  /** Timestamp of when the vulnerability state changed to confirmed (defaults to creation time if status is `confirmed`). */
  confirmedAt?: InputMaybe<Scalars['Time']>;
  /** Timestamp of when the vulnerability state changed to resolved (defaults to creation time if status is `resolved`). */
  resolvedAt?: InputMaybe<Scalars['Time']>;
  /** Timestamp of when the vulnerability state changed to dismissed (defaults to creation time if status is `dismissed`). */
  dismissedAt?: InputMaybe<Scalars['Time']>;
};

/** Autogenerated return type of VulnerabilityCreate */
export type VulnerabilityCreatePayload = {
  __typename?: 'VulnerabilityCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability created. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability detail field. The fields with data will depend on the vulnerability detail type */
export type VulnerabilityDetail = VulnerabilityDetailBase | VulnerabilityDetailBoolean | VulnerabilityDetailCode | VulnerabilityDetailCommit | VulnerabilityDetailDiff | VulnerabilityDetailFileLocation | VulnerabilityDetailInt | VulnerabilityDetailList | VulnerabilityDetailMarkdown | VulnerabilityDetailModuleLocation | VulnerabilityDetailTable | VulnerabilityDetailText | VulnerabilityDetailUrl;

/** Represents the vulnerability details base */
export type VulnerabilityDetailBase = {
  __typename?: 'VulnerabilityDetailBase';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details boolean value */
export type VulnerabilityDetailBoolean = {
  __typename?: 'VulnerabilityDetailBoolean';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the field. */
  value: Scalars['Boolean'];
};

/** Represents the vulnerability details code field */
export type VulnerabilityDetailCode = {
  __typename?: 'VulnerabilityDetailCode';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Language of the code. */
  lang?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Source code. */
  value: Scalars['String'];
};

/** Represents the vulnerability details commit field */
export type VulnerabilityDetailCommit = {
  __typename?: 'VulnerabilityDetailCommit';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Commit SHA value. */
  value: Scalars['String'];
};

/** Represents the vulnerability details diff field */
export type VulnerabilityDetailDiff = {
  __typename?: 'VulnerabilityDetailDiff';
  /** Value of the field after the change. */
  after: Scalars['String'];
  /** Value of the field before the change. */
  before: Scalars['String'];
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailFileLocation = {
  __typename?: 'VulnerabilityDetailFileLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** File name. */
  fileName: Scalars['String'];
  /** End line number of the file location. */
  lineEnd: Scalars['Int'];
  /** Start line number of the file location. */
  lineStart: Scalars['Int'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details integer value */
export type VulnerabilityDetailInt = {
  __typename?: 'VulnerabilityDetailInt';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the field. */
  value: Scalars['Int'];
};

/** Represents the vulnerability details list value */
export type VulnerabilityDetailList = {
  __typename?: 'VulnerabilityDetailList';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** List of details. */
  items: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details Markdown field */
export type VulnerabilityDetailMarkdown = {
  __typename?: 'VulnerabilityDetailMarkdown';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the Markdown field. */
  value: Scalars['String'];
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailModuleLocation = {
  __typename?: 'VulnerabilityDetailModuleLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Module name. */
  moduleName: Scalars['String'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Offset of the module location. */
  offset: Scalars['Int'];
};

/** Represents the vulnerability details table value */
export type VulnerabilityDetailTable = {
  __typename?: 'VulnerabilityDetailTable';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Table headers. */
  headers: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Table rows. */
  rows: Array<VulnerabilityDetail>;
};

/** Represents the vulnerability details text field */
export type VulnerabilityDetailText = {
  __typename?: 'VulnerabilityDetailText';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the text field. */
  value: Scalars['String'];
};

/** Represents the vulnerability details URL field */
export type VulnerabilityDetailUrl = {
  __typename?: 'VulnerabilityDetailUrl';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Href of the URL. */
  href: Scalars['String'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Text of the URL. */
  text?: Maybe<Scalars['String']>;
};

/** The dismissal reason of the Vulnerability */
export enum VulnerabilityDismissalReason {
  /** The vulnerability is known, and has not been remediated or mitigated, but is considered to be an acceptable business risk. */
  AcceptableRisk = 'ACCEPTABLE_RISK',
  /**
   * An error in reporting in which a test result incorrectly indicates the
   * presence of a vulnerability in a system when the vulnerability is not present.
   */
  FalsePositive = 'FALSE_POSITIVE',
  /**
   * A management, operational, or technical control (that is, safeguard or
   * countermeasure) employed by an organization that provides equivalent or
   * comparable protection for an information system.
   */
  MitigatingControl = 'MITIGATING_CONTROL',
  /** The finding is not a vulnerability because it is part of a test or is test data. */
  UsedInTests = 'USED_IN_TESTS',
  /**
   * The vulnerability is known, and has not been remediated or mitigated, but is
   * considered to be in a part of the application that will not be updated.
   */
  NotApplicable = 'NOT_APPLICABLE'
}

/** Autogenerated input type of VulnerabilityDismiss */
export type VulnerabilityDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be dismissed. */
  id: Scalars['VulnerabilityID'];
  /** Comment why vulnerability should be dismissed. */
  comment?: InputMaybe<Scalars['String']>;
  /** Reason why vulnerability should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
};

/** Autogenerated return type of VulnerabilityDismiss */
export type VulnerabilityDismissPayload = {
  __typename?: 'VulnerabilityDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after dismissal. */
  vulnerability?: Maybe<Vulnerability>;
};

/** An edge in a connection. */
export type VulnerabilityEdge = {
  __typename?: 'VulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Evidence */
export type VulnerabilityEvidence = {
  __typename?: 'VulnerabilityEvidence';
  /** HTTP request of the Vulnerability Evidence. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the Vulnerability Evidence. */
  response?: Maybe<VulnerabilityResponse>;
  /** Source of the Vulnerability Evidence. */
  source?: Maybe<VulnerabilityEvidenceSource>;
  /** Summary of the Vulnerability Evidence. */
  summary?: Maybe<Scalars['String']>;
  /** Supporting messages of the Vulnerability Evidence. */
  supportingMessages?: Maybe<Array<VulnerabilityEvidenceSupportingMessage>>;
};

/** Represents a vulnerability evidence */
export type VulnerabilityEvidenceSource = {
  __typename?: 'VulnerabilityEvidenceSource';
  /** ID of the Vulnerability Evidence Source. */
  identifier: Scalars['String'];
  /** Name of the Vulnerability Evidence Source. */
  name: Scalars['String'];
  /** URL of the Vulnerability Evidence Source. */
  url?: Maybe<Scalars['String']>;
};

/** Represents a vulnerability evidence supporting message */
export type VulnerabilityEvidenceSupportingMessage = {
  __typename?: 'VulnerabilityEvidenceSupportingMessage';
  /** Name of the vulnerability supporting message. */
  name: Scalars['String'];
  /** HTTP request of the vulnerability evidence supporting message. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the vulnerability evidence supporting message. */
  response?: Maybe<VulnerabilityResponse>;
};

/** Represents an external issue link of a vulnerability */
export type VulnerabilityExternalIssueLink = {
  __typename?: 'VulnerabilityExternalIssueLink';
  /** The external issue attached to the issue link. */
  externalIssue?: Maybe<ExternalIssue>;
  /** GraphQL ID of the external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
};

/** The connection type for VulnerabilityExternalIssueLink. */
export type VulnerabilityExternalIssueLinkConnection = {
  __typename?: 'VulnerabilityExternalIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityExternalIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityExternalIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkCreate */
export type VulnerabilityExternalIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability. */
  id: Scalars['VulnerabilityID'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
  /** External tracker type of the external issue link. */
  externalTracker: VulnerabilityExternalIssueLinkExternalTracker;
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkCreate */
export type VulnerabilityExternalIssueLinkCreatePayload = {
  __typename?: 'VulnerabilityExternalIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created external issue link. */
  externalIssueLink?: Maybe<VulnerabilityExternalIssueLink>;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkDestroy */
export type VulnerabilityExternalIssueLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the vulnerability external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID'];
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkDestroy */
export type VulnerabilityExternalIssueLinkDestroyPayload = {
  __typename?: 'VulnerabilityExternalIssueLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type VulnerabilityExternalIssueLinkEdge = {
  __typename?: 'VulnerabilityExternalIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityExternalIssueLink>;
};

/** The external tracker of the external issue link related to a vulnerability */
export enum VulnerabilityExternalIssueLinkExternalTracker {
  /** Jira external tracker */
  Jira = 'JIRA'
}

/** The type of the external issue link related to a vulnerability */
export enum VulnerabilityExternalIssueLinkType {
  /** Created link type */
  Created = 'CREATED'
}

/** Autogenerated input type of VulnerabilityFindingDismiss */
export type VulnerabilityFindingDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** UUID of the finding to be dismissed. */
  uuid?: InputMaybe<Scalars['String']>;
  /** Comment why finding should be dismissed. */
  comment?: InputMaybe<Scalars['String']>;
  /** Reason why finding should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
};

/** Autogenerated return type of VulnerabilityFindingDismiss */
export type VulnerabilityFindingDismissPayload = {
  __typename?: 'VulnerabilityFindingDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Finding after dismissal. */
  finding?: Maybe<PipelineSecurityReportFinding>;
};

/** The grade of the vulnerable project */
export enum VulnerabilityGrade {
  /** A grade */
  A = 'A',
  /** B grade */
  B = 'B',
  /** C grade */
  C = 'C',
  /** D grade */
  D = 'D',
  /** F grade */
  F = 'F'
}

/** Represents a vulnerability identifier */
export type VulnerabilityIdentifier = {
  __typename?: 'VulnerabilityIdentifier';
  /** External ID of the vulnerability identifier. */
  externalId?: Maybe<Scalars['String']>;
  /** External type of the vulnerability identifier. */
  externalType?: Maybe<Scalars['String']>;
  /** Name of the vulnerability identifier. */
  name?: Maybe<Scalars['String']>;
  /** URL of the vulnerability identifier. */
  url?: Maybe<Scalars['String']>;
};

export type VulnerabilityIdentifierInput = {
  /** Name of the vulnerability identifier. */
  name: Scalars['String'];
  /** URL of the vulnerability identifier. */
  url: Scalars['String'];
  /** External type of the vulnerability identifier. */
  externalType?: InputMaybe<Scalars['String']>;
  /** External ID of the vulnerability identifier. */
  externalId?: InputMaybe<Scalars['String']>;
};

/** Represents an issue link of a vulnerability */
export type VulnerabilityIssueLink = {
  __typename?: 'VulnerabilityIssueLink';
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID'];
  /** Issue attached to issue link. */
  issue?: Maybe<Issue>;
  /** Type of the issue link. */
  linkType: VulnerabilityIssueLinkType;
};

/** The connection type for VulnerabilityIssueLink. */
export type VulnerabilityIssueLinkConnection = {
  __typename?: 'VulnerabilityIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityIssueLinkEdge = {
  __typename?: 'VulnerabilityIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityIssueLink>;
};

/** The type of the issue link related to a vulnerability */
export enum VulnerabilityIssueLinkType {
  /** Has a related issue */
  Related = 'RELATED',
  /** Issue is created for the vulnerability */
  Created = 'CREATED'
}

/** Represents a link related to a vulnerability */
export type VulnerabilityLink = {
  __typename?: 'VulnerabilityLink';
  /** Name of the link. */
  name?: Maybe<Scalars['String']>;
  /** URL of the link. */
  url: Scalars['String'];
};

/** Represents a vulnerability location. The fields with data will depend on the vulnerability report type */
export type VulnerabilityLocation = VulnerabilityLocationClusterImageScanning | VulnerabilityLocationContainerScanning | VulnerabilityLocationCoverageFuzzing | VulnerabilityLocationDast | VulnerabilityLocationDependencyScanning | VulnerabilityLocationGeneric | VulnerabilityLocationSast | VulnerabilityLocationSecretDetection;

/** Represents the location of a vulnerability found by a cluster image scan */
export type VulnerabilityLocationClusterImageScanning = {
  __typename?: 'VulnerabilityLocationClusterImageScanning';
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']>;
  /** Kubernetes resource which uses the vulnerable container image. */
  kubernetesResource?: Maybe<VulnerableKubernetesResource>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a container security scan */
export type VulnerabilityLocationContainerScanning = {
  __typename?: 'VulnerabilityLocationContainerScanning';
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a Coverage Fuzzing scan */
export type VulnerabilityLocationCoverageFuzzing = {
  __typename?: 'VulnerabilityLocationCoverageFuzzing';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Relative address in memory were the crash occurred. */
  crashAddress?: Maybe<Scalars['String']>;
  /** Type of the crash. */
  crashType?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Stack trace recorded during fuzzing resulting the crash. */
  stacktraceSnippet?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a DAST scan */
export type VulnerabilityLocationDast = {
  __typename?: 'VulnerabilityLocationDast';
  /** Domain name of the vulnerable request. */
  hostname?: Maybe<Scalars['String']>;
  /** Query parameter for the URL on which the vulnerability occurred. */
  param?: Maybe<Scalars['String']>;
  /** URL path and query string of the vulnerable request. */
  path?: Maybe<Scalars['String']>;
  /** HTTP method of the vulnerable request. */
  requestMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a dependency security scan */
export type VulnerabilityLocationDependencyScanning = {
  __typename?: 'VulnerabilityLocationDependencyScanning';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a generic scanner. */
export type VulnerabilityLocationGeneric = {
  __typename?: 'VulnerabilityLocationGeneric';
  /** Free-form description of where the vulnerability is located. */
  description?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a SAST scan */
export type VulnerabilityLocationSast = {
  __typename?: 'VulnerabilityLocationSast';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a secret detection scan */
export type VulnerabilityLocationSecretDetection = {
  __typename?: 'VulnerabilityLocationSecretDetection';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Check permissions for the current user on a vulnerability */
export type VulnerabilityPermissions = {
  __typename?: 'VulnerabilityPermissions';
  /** Indicates the user can perform `admin_vulnerability` on this resource */
  adminVulnerability: Scalars['Boolean'];
  /** Indicates the user can perform `admin_vulnerability_external_issue_link` on this resource */
  adminVulnerabilityExternalIssueLink: Scalars['Boolean'];
  /** Indicates the user can perform `admin_vulnerability_issue_link` on this resource */
  adminVulnerabilityIssueLink: Scalars['Boolean'];
  /** Indicates the user can perform `create_vulnerability` on this resource */
  createVulnerability: Scalars['Boolean'];
  /** Indicates the user can perform `create_vulnerability_export` on this resource */
  createVulnerabilityExport: Scalars['Boolean'];
  /** Indicates the user can perform `create_vulnerability_feedback` on this resource */
  createVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_vulnerability_feedback` on this resource */
  destroyVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `read_vulnerability_feedback` on this resource */
  readVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `update_vulnerability_feedback` on this resource */
  updateVulnerabilityFeedback: Scalars['Boolean'];
};

/** The type of the security scan that found the vulnerability */
export enum VulnerabilityReportType {
  /** SAST report */
  Sast = 'SAST',
  /** Dependency Scanning report */
  DependencyScanning = 'DEPENDENCY_SCANNING',
  /** Container Scanning report */
  ContainerScanning = 'CONTAINER_SCANNING',
  /** DAST report */
  Dast = 'DAST',
  /** Secret Detection report */
  SecretDetection = 'SECRET_DETECTION',
  /** Coverage Fuzzing report */
  CoverageFuzzing = 'COVERAGE_FUZZING',
  /** API Fuzzing report */
  ApiFuzzing = 'API_FUZZING',
  /** Cluster Image Scanning report */
  ClusterImageScanning = 'CLUSTER_IMAGE_SCANNING',
  /** Generic report */
  Generic = 'GENERIC'
}

/** Represents a Vulnerability Request */
export type VulnerabilityRequest = {
  __typename?: 'VulnerabilityRequest';
  /** Body of the Vulnerability Request. */
  body?: Maybe<Scalars['String']>;
  /** HTTP headers of the Vulnerability Request. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Method of the Vulnerability Request. */
  method?: Maybe<Scalars['String']>;
  /** URL of the Vulnerability Request. */
  url?: Maybe<Scalars['String']>;
};

/** Represents a Vulnerability Request/Response Header */
export type VulnerabilityRequestResponseHeader = {
  __typename?: 'VulnerabilityRequestResponseHeader';
  /** Name of the Vulnerability Request/Response Header. */
  name?: Maybe<Scalars['String']>;
  /** Value of the Vulnerability Request/Response Header. */
  value?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of VulnerabilityResolve */
export type VulnerabilityResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be resolved. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityResolve */
export type VulnerabilityResolvePayload = {
  __typename?: 'VulnerabilityResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Response */
export type VulnerabilityResponse = {
  __typename?: 'VulnerabilityResponse';
  /** Body of the Vulnerability Response. */
  body?: Maybe<Scalars['String']>;
  /** HTTP headers of the Vulnerability Response. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Reason Phrase of the Vulnerability Response. */
  reasonPhrase?: Maybe<Scalars['String']>;
  /** Status Code of the Vulnerability Response. */
  statusCode?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of VulnerabilityRevertToDetected */
export type VulnerabilityRevertToDetectedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be reverted. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityRevertToDetected */
export type VulnerabilityRevertToDetectedPayload = {
  __typename?: 'VulnerabilityRevertToDetectedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after revert. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability scanner */
export type VulnerabilityScanner = {
  __typename?: 'VulnerabilityScanner';
  /** External ID of the vulnerability scanner. */
  externalId?: Maybe<Scalars['String']>;
  /** ID of the scanner. */
  id?: Maybe<Scalars['ID']>;
  /** Name of the vulnerability scanner. */
  name?: Maybe<Scalars['String']>;
  /** Type of the vulnerability report. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Humanized type of the vulnerability report. */
  reportTypeHumanized?: Maybe<Scalars['String']>;
  /** Vendor of the vulnerability scanner. */
  vendor?: Maybe<Scalars['String']>;
};

/** The connection type for VulnerabilityScanner. */
export type VulnerabilityScannerConnection = {
  __typename?: 'VulnerabilityScannerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityScannerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityScanner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityScannerEdge = {
  __typename?: 'VulnerabilityScannerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityScanner>;
};

export type VulnerabilityScannerInput = {
  /** Unique ID that identifies the scanner. */
  id: Scalars['String'];
  /** Human readable value that identifies the analyzer, not required to be unique. */
  name: Scalars['String'];
  /** Link to more information about the analyzer. */
  url: Scalars['String'];
  /** Information about vendor/maintainer of the scanner. */
  vendor?: InputMaybe<VulnerabilityScannerVendorInput>;
  /** Version of the scanner. */
  version: Scalars['String'];
};

export type VulnerabilityScannerVendorInput = {
  /** Name of the vendor/maintainer. */
  name: Scalars['String'];
};

/** Represents vulnerability counts by severity */
export type VulnerabilitySeveritiesCount = {
  __typename?: 'VulnerabilitySeveritiesCount';
  /** Number of vulnerabilities of CRITICAL severity of the project */
  critical?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of HIGH severity of the project */
  high?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of INFO severity of the project */
  info?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of LOW severity of the project */
  low?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of MEDIUM severity of the project */
  medium?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of UNKNOWN severity of the project */
  unknown?: Maybe<Scalars['Int']>;
};

/** The severity of the vulnerability */
export enum VulnerabilitySeverity {
  /** Info severity */
  Info = 'INFO',
  /** Unknown severity */
  Unknown = 'UNKNOWN',
  /** Low severity */
  Low = 'LOW',
  /** Medium severity */
  Medium = 'MEDIUM',
  /** High severity */
  High = 'HIGH',
  /** Critical severity */
  Critical = 'CRITICAL'
}

/** Vulnerability sort values */
export enum VulnerabilitySort {
  /** Severity in descending order. */
  SeverityDesc = 'severity_desc',
  /** Severity in ascending order. */
  SeverityAsc = 'severity_asc',
  /** Detection timestamp in descending order. */
  DetectedDesc = 'detected_desc',
  /** Detection timestamp in ascending order. */
  DetectedAsc = 'detected_asc'
}

/** The state of the vulnerability */
export enum VulnerabilityState {
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  Confirmed = 'CONFIRMED',
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  Detected = 'DETECTED',
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  Dismissed = 'DISMISSED',
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  Resolved = 'RESOLVED'
}

/** Represents a vulnerable dependency. Used in vulnerability location data */
export type VulnerableDependency = {
  __typename?: 'VulnerableDependency';
  /** Package associated with the vulnerable dependency. */
  package?: Maybe<VulnerablePackage>;
  /** Version of the vulnerable dependency. */
  version?: Maybe<Scalars['String']>;
};

/** Represents a vulnerable Kubernetes resource. Used in vulnerability location data */
export type VulnerableKubernetesResource = {
  __typename?: 'VulnerableKubernetesResource';
  /** Kubernetes Agent which performed the scan. */
  agent?: Maybe<ClusterAgent>;
  /** ID of the Cluster integration which was used to perform the scan. */
  clusterId?: Maybe<Scalars['ClustersClusterID']>;
  /** Name of the container that had its image scanned. */
  containerName: Scalars['String'];
  /** Kind of the Kubernetes resource. */
  kind: Scalars['String'];
  /** Name of the Kubernetes resource. */
  name: Scalars['String'];
  /** Kubernetes namespace which the resource resides in. */
  namespace: Scalars['String'];
};

/** Represents a vulnerable package. Used in vulnerability dependency data */
export type VulnerablePackage = {
  __typename?: 'VulnerablePackage';
  /** Name of the vulnerable package. */
  name?: Maybe<Scalars['String']>;
};

/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGrade = {
  __typename?: 'VulnerableProjectsByGrade';
  /** Number of projects within this grade. */
  count: Scalars['Int'];
  /** Grade based on the highest severity vulnerability present. */
  grade: VulnerabilityGrade;
  /** Projects within this grade. */
  projects: ProjectConnection;
};


/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGradeProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Weight ID wildcard values */
export enum WeightWildcardId {
  /** No weight is assigned. */
  None = 'NONE',
  /** Weight is assigned. */
  Any = 'ANY'
}

export type WorkItem = Todoable & {
  __typename?: 'WorkItem';
  /** Timestamp of when the work item was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Indicates the work item is confidential. */
  confidential: Scalars['Boolean'];
  /** Timestamp of when the work item was created. */
  createdAt: Scalars['Time'];
  /** Description of the work item. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Internal ID of the work item. */
  iid: Scalars['ID'];
  /** Lock version of the work item. Incremented each time the work item is updated. */
  lockVersion: Scalars['Int'];
  /**
   * Project the work item belongs to. Introduced in 15.3: This feature is in Alpha. It can be changed or removed at any time.
   * @deprecated This feature is in Alpha. It can be changed or removed at any time. Introduced in 15.3.
   */
  project: Project;
  /** State of the work item. */
  state: WorkItemState;
  /** Title of the work item. */
  title: Scalars['String'];
  /** The GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the work item was last updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: WorkItemPermissions;
  /** URL of this object. */
  webUrl?: Maybe<Scalars['String']>;
  /** Collection of widgets that belong to the work item. */
  widgets?: Maybe<Array<WorkItemWidget>>;
  /** Type assigned to the work item. */
  workItemType: WorkItemType;
};

/** The connection type for WorkItem. */
export type WorkItemConnection = {
  __typename?: 'WorkItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type WorkItemConvertTaskInput = {
  /** Last line in the Markdown source that defines the list item task. */
  lineNumberEnd: Scalars['Int'];
  /** First line in the Markdown source that defines the list item task. */
  lineNumberStart: Scalars['Int'];
  /** Current lock version of the work item containing the task in the description. */
  lockVersion: Scalars['Int'];
  /** Full string of the task to be replaced. New title for the created work item. */
  title: Scalars['String'];
  /** Global ID of the work item type used to create the new work item. */
  workItemTypeId: Scalars['WorkItemsTypeID'];
};

/** Autogenerated input type of WorkItemCreateFromTask */
export type WorkItemCreateFromTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Arguments necessary to convert a task into a work item. */
  workItemData: WorkItemConvertTaskInput;
};

/** Autogenerated return type of WorkItemCreateFromTask */
export type WorkItemCreateFromTaskPayload = {
  __typename?: 'WorkItemCreateFromTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** New work item created from task. */
  newWorkItem?: Maybe<WorkItem>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemCreate */
export type WorkItemCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Description of the work item. */
  description?: InputMaybe<Scalars['String']>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyCreateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Full path of the project the work item is associated with. */
  projectPath: Scalars['ID'];
  /** Title of the work item. */
  title: Scalars['String'];
  /** Global ID of a work item type. */
  workItemTypeId: Scalars['WorkItemsTypeID'];
};

/** Autogenerated return type of WorkItemCreate */
export type WorkItemCreatePayload = {
  __typename?: 'WorkItemCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemDeletedTaskInput = {
  /** Global ID of the task referenced in the work item's description. */
  id: Scalars['WorkItemID'];
  /** Last line in the Markdown source that defines the list item task. */
  lineNumberEnd: Scalars['Int'];
  /** First line in the Markdown source that defines the list item task. */
  lineNumberStart: Scalars['Int'];
};

/** Autogenerated input type of WorkItemDelete */
export type WorkItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
};

/** Autogenerated return type of WorkItemDelete */
export type WorkItemDeletePayload = {
  __typename?: 'WorkItemDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project the deleted work item belonged to. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of WorkItemDeleteTask */
export type WorkItemDeleteTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Current lock version of the work item containing the task in the description. */
  lockVersion: Scalars['Int'];
  /** Arguments necessary to delete a task from a work item's description. */
  taskData: WorkItemDeletedTaskInput;
};

/** Autogenerated return type of WorkItemDeleteTask */
export type WorkItemDeleteTaskPayload = {
  __typename?: 'WorkItemDeleteTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** An edge in a connection. */
export type WorkItemEdge = {
  __typename?: 'WorkItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItem>;
};

/** Check permissions for the current user on a work item */
export type WorkItemPermissions = {
  __typename?: 'WorkItemPermissions';
  /** Indicates the user can perform `delete_work_item` on this resource */
  deleteWorkItem: Scalars['Boolean'];
  /** Indicates the user can perform `read_work_item` on this resource */
  readWorkItem: Scalars['Boolean'];
  /** Indicates the user can perform `update_work_item` on this resource */
  updateWorkItem: Scalars['Boolean'];
};

/** Values for sorting work items */
export enum WorkItemSort {
  /** Title by ascending order. */
  TitleAsc = 'TITLE_ASC',
  /** Title by descending order. */
  TitleDesc = 'TITLE_DESC',
  /** Updated at descending order. */
  UpdatedDesc = 'UPDATED_DESC',
  /** Updated at ascending order. */
  UpdatedAsc = 'UPDATED_ASC',
  /** Created at descending order. */
  CreatedDesc = 'CREATED_DESC',
  /** Created at ascending order. */
  CreatedAsc = 'CREATED_ASC'
}

/** State of a GitLab work item */
export enum WorkItemState {
  /** In open state. */
  Open = 'OPEN',
  /** In closed state. */
  Closed = 'CLOSED'
}

/** Values for work item state events */
export enum WorkItemStateEvent {
  /** Reopens the work item. */
  Reopen = 'REOPEN',
  /** Closes the work item. */
  Close = 'CLOSE'
}

export type WorkItemType = {
  __typename?: 'WorkItemType';
  /** Icon name of the work item type. */
  iconName?: Maybe<Scalars['String']>;
  /** Global ID of the work item type. */
  id: Scalars['WorkItemsTypeID'];
  /** Name of the work item type. */
  name: Scalars['String'];
};

/** The connection type for WorkItemType. */
export type WorkItemTypeConnection = {
  __typename?: 'WorkItemTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemTypeEdge = {
  __typename?: 'WorkItemTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemType>;
};

export type WorkItemUpdatedTaskInput = {
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Close or reopen a work item. */
  stateEvent?: InputMaybe<WorkItemStateEvent>;
  /** Title of the work item. */
  title?: InputMaybe<Scalars['String']>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyUpdateInput>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
};

/** Autogenerated input type of WorkItemUpdate */
export type WorkItemUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Close or reopen a work item. */
  stateEvent?: InputMaybe<WorkItemStateEvent>;
  /** Title of the work item. */
  title?: InputMaybe<Scalars['String']>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyUpdateInput>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Input for iteration widget. */
  iterationWidget?: InputMaybe<WorkItemWidgetIterationInput>;
  /** Input for weight widget. */
  weightWidget?: InputMaybe<WorkItemWidgetWeightInput>;
  /** Input for status widget. */
  statusWidget?: InputMaybe<StatusInput>;
};

/** Autogenerated return type of WorkItemUpdate */
export type WorkItemUpdatePayload = {
  __typename?: 'WorkItemUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemUpdateTask */
export type WorkItemUpdateTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Arguments necessary to update a task. */
  taskData: WorkItemUpdatedTaskInput;
};

/** Autogenerated return type of WorkItemUpdateTask */
export type WorkItemUpdateTaskPayload = {
  __typename?: 'WorkItemUpdateTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated task. */
  task?: Maybe<WorkItem>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemWidget = {
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents an assignees widget */
export type WorkItemWidgetAssignees = WorkItemWidget & {
  __typename?: 'WorkItemWidgetAssignees';
  /** Indicates whether multiple assignees are allowed. */
  allowsMultipleAssignees?: Maybe<Scalars['Boolean']>;
  /** Assignees of the work item. */
  assignees?: Maybe<UserCoreConnection>;
  /** Indicates whether the current user can invite members to the work item's project. */
  canInviteMembers: Scalars['Boolean'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents an assignees widget */
export type WorkItemWidgetAssigneesAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetAssigneesInput = {
  /** Global IDs of assignees. */
  assigneeIds: Array<Scalars['UserID']>;
};

/** Represents a description widget */
export type WorkItemWidgetDescription = WorkItemWidget & {
  __typename?: 'WorkItemWidgetDescription';
  /** Description of the work item. */
  description?: Maybe<Scalars['String']>;
  /** The GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Whether the description has been edited since the work item was created. */
  edited: Scalars['Boolean'];
  /** Timestamp of when the work item's description was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']>;
  /** User that made the last edit to the work item's description. */
  lastEditedBy?: Maybe<UserCore>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetDescriptionInput = {
  /** Description of the work item. */
  description: Scalars['String'];
};

/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchy = WorkItemWidget & {
  __typename?: 'WorkItemWidgetHierarchy';
  /** Child work items. */
  children?: Maybe<WorkItemConnection>;
  /** Parent work item. */
  parent?: Maybe<WorkItem>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchyChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetHierarchyCreateInput = {
  /** Global ID of the parent work item. */
  parentId?: InputMaybe<Scalars['WorkItemID']>;
};

export type WorkItemWidgetHierarchyUpdateInput = {
  /** Global ID of the parent work item. Use `null` to remove the association. */
  parentId?: InputMaybe<Scalars['WorkItemID']>;
  /** Global IDs of children work items. */
  childrenIds?: InputMaybe<Array<Scalars['WorkItemID']>>;
};

/** Represents an iteration widget */
export type WorkItemWidgetIteration = WorkItemWidget & {
  __typename?: 'WorkItemWidgetIteration';
  /** Iteration of the work item. */
  iteration?: Maybe<Iteration>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetIterationInput = {
  /** Iteration to assign to the work item. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
};

/** Represents the labels widget */
export type WorkItemWidgetLabels = WorkItemWidget & {
  __typename?: 'WorkItemWidgetLabels';
  /** Indicates whether a scoped label is allowed. */
  allowsScopedLabels?: Maybe<Scalars['Boolean']>;
  /** Labels assigned to the work item. */
  labels?: Maybe<LabelConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the labels widget */
export type WorkItemWidgetLabelsLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetLabelsUpdateInput = {
  /** Global IDs of labels to be added to the work item. */
  addLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Global IDs of labels to be removed from the work item. */
  removeLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
};

/** Represents a milestone widget */
export type WorkItemWidgetMilestone = WorkItemWidget & {
  __typename?: 'WorkItemWidgetMilestone';
  /** Milestone of the work item. */
  milestone?: Maybe<Milestone>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetMilestoneInput = {
  /** Milestone to assign to the work item. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
};

/** Represents a start and due date widget */
export type WorkItemWidgetStartAndDueDate = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStartAndDueDate';
  /** Due date of the work item. */
  dueDate?: Maybe<Scalars['Date']>;
  /** Start date of the work item. */
  startDate?: Maybe<Scalars['Date']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetStartAndDueDateUpdateInput = {
  /** Due date for the work item. */
  dueDate?: InputMaybe<Scalars['Date']>;
  /** Start date for the work item. */
  startDate?: InputMaybe<Scalars['Date']>;
};

/** Represents a status widget */
export type WorkItemWidgetStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStatus';
  /** Status of the work item. */
  status?: Maybe<Scalars['String']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Type of a work item widget */
export enum WorkItemWidgetType {
  /** Iteration widget. */
  Iteration = 'ITERATION',
  /** Weight widget. */
  Weight = 'WEIGHT',
  /** Status widget. */
  Status = 'STATUS',
  /** Assignees widget. */
  Assignees = 'ASSIGNEES',
  /** Labels widget. */
  Labels = 'LABELS',
  /** Description widget. */
  Description = 'DESCRIPTION',
  /** Hierarchy widget. */
  Hierarchy = 'HIERARCHY',
  /** Start And Due Date widget. */
  StartAndDueDate = 'START_AND_DUE_DATE',
  /** Milestone widget. */
  Milestone = 'MILESTONE'
}

/** Represents a weight widget */
export type WorkItemWidgetWeight = WorkItemWidget & {
  __typename?: 'WorkItemWidgetWeight';
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Weight of the work item. */
  weight?: Maybe<Scalars['Int']>;
};

export type WorkItemWidgetWeightInput = {
  /** Weight of the work item. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Represents an X.509 certificate. */
export type X509Certificate = {
  __typename?: 'X509Certificate';
  /** Indicates if the certificate is good or revoked. */
  certificateStatus: Scalars['String'];
  /** Timestamp of when the certificate was saved. */
  createdAt: Scalars['Time'];
  /** Email associated with the cerificate. */
  email: Scalars['String'];
  /** ID of the certificate. */
  id: Scalars['ID'];
  /** Serial number of the certificate. */
  serialNumber: Scalars['String'];
  /** Subject of the certificate. */
  subject: Scalars['String'];
  /** Subject key identifier of the certificate. */
  subjectKeyIdentifier: Scalars['String'];
  /** Timestamp of when the certificate was last updated. */
  updatedAt: Scalars['Time'];
  /** Issuer of the certificate. */
  x509Issuer: X509Issuer;
};

/** Issuer of an X.509 certificate. */
export type X509Issuer = {
  __typename?: 'X509Issuer';
  /** Timestamp of when the issuer was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Certificate revokation list of the issuer. */
  crlUrl?: Maybe<Scalars['String']>;
  /** ID of the issuer. */
  id?: Maybe<Scalars['ID']>;
  /** Subject of the issuer. */
  subject?: Maybe<Scalars['String']>;
  /** Subject key identifier of the issuer. */
  subjectKeyIdentifier?: Maybe<Scalars['String']>;
  /** Timestamp of when the issuer was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** X.509 signature for a signed commit */
export type X509Signature = CommitSignature & {
  __typename?: 'X509Signature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
  /** Certificate used for the signature. */
  x509Certificate?: Maybe<X509Certificate>;
};
